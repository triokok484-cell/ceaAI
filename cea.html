<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEA201 - Master Tool (Categorized)</title>
    <style>
        :root {
            --primary-color: #6f42c1;
            --primary-light: #e0d4fc;
            --secondary-color: #28a745;
            --danger-color: #dc3545;
            --light-bg: #f3eefc;
            --dark-text: #333;
            --border-radius: 12px;
        }
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');
        
        * { box-sizing: border-box; }
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--light-bg);
            color: var(--dark-text);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* HEADER */
        .top-bar {
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            flex-shrink: 0;
        }

        .tabs {
            display: flex;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 25px;
        }

        .tab-btn {
            padding: 8px 20px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 20px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 5px rgba(111, 66, 193, 0.3);
        }

        .lang-btn {
            background: white;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        /* LAYOUT */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .content-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
            padding-bottom: 100px;
        }

        /* DROPDOWN STYLE */
        .custom-select {
            padding: 10px;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            font-size: 16px;
            color: var(--dark-text);
            outline: none;
            background: white;
            max-width: 100%;
            cursor: pointer;
        }

        /* SETUP SCREEN */
        #quiz-setup {
            text-align: center;
            margin-top: 30px;
            background: white;
            padding: 40px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .input-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 18px;
            width: 120px;
            text-align: center;
            color: var(--primary-color);
            font-weight: bold;
        }

        .start-btn, .nav-btn, .submit-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: bold;
        }
        .start-btn:hover, .nav-btn:hover { transform: scale(1.05); opacity: 0.9; }
        
        .submit-btn { background: var(--secondary-color); }
        .nav-btn.secondary { background: #e0e0e0; color: #333; }

        /* RESULT SCREEN */
        .result-header {
            text-align: center;
            background: white;
            padding: 30px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
        }
        .score-number {
            font-size: 48px;
            font-weight: bold;
            color: var(--primary-color);
            margin: 10px 0;
        }

        /* FLASHCARD */
        .flashcard-wrapper {
            display: flex;
            justify-content: center;
            perspective: 1000px;
            margin-bottom: 20px;
        }
        .flashcard {
            width: 100%;
            max-width: 600px;
            height: 400px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
        }
        .flashcard.flipped { transform: rotateY(180deg); }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            background: white;
            padding: 30px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border: 2px solid var(--primary-light);
            overflow-y: auto;
        }
        .card-back { transform: rotateY(180deg); background: #fff9db; justify-content: flex-start; padding-top: 40px; }

        /* QUIZ QUESTION */
        .question-card {
            background: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        #question-text { font-size: 18px; font-weight: 500; margin-bottom: 20px; line-height: 1.5; }
        
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: left;
        }

        .options-list { list-style: none; padding: 0; }
        .options-list li {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px 15px 15px 50px;
            margin-bottom: 10px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        
        .options-list li::before {
            content: attr(data-label);
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            background: #f0f0f0;
            color: #555;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            font-size: 12px;
            font-weight: bold;
        }

        /* Option States */
        .options-list li:hover:not(.disabled) { border-color: var(--primary-color); }
        .options-list li.disabled { cursor: default; pointer-events: none; }
        
        .options-list li.correct {
            border-color: var(--secondary-color);
            background-color: #d4edda;
            color: #155724;
        }
        .options-list li.correct::before { background: var(--secondary-color); color: white; }

        .options-list li.wrong {
            border-color: var(--danger-color);
            background-color: #f8d7da;
            color: #721c24;
        }
        .options-list li.wrong::before { background: var(--danger-color); color: white; }

        /* Review Mode Specifics */
        .review-card li { opacity: 0.6; }
        .review-card li.correct, .review-card li.wrong { opacity: 1; }

        .explanation-box {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            background: #e7f3fe;
            border-left: 5px solid #2196f3;
            display: none; 
        }

        /* SIDEBAR MAP */
        .quiz-sidebar {
            width: 280px;
            background: white;
            border-left: 1px solid #eee;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }

        .map-btn {
            width: 100%;
            aspect-ratio: 1;
            border: none;
            border-radius: 8px;
            background: #f0f0f0;
            color: #666;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .map-btn:hover { background: #e0e0e0; }
        .map-btn.active { border: 2px solid var(--primary-color); }
        .map-btn.correct { background: var(--secondary-color); color: white; }
        .map-btn.wrong { background: var(--danger-color); color: white; }

        .hidden { display: none !important; }
        .flex-between { display: flex; justify-content: space-between; align-items: center; }
        .shortcut-hint {
            text-align: center; margin-top: 10px; color: #888; font-size: 12px; font-style: italic;
        }

        /* UTILS */
        .filter-container {
            text-align: center; 
            margin-bottom: 20px; 
            background: white; 
            padding: 10px; 
            border-radius: 12px;
        }

        @media (max-width: 768px) {
            .main-container { flex-direction: column; }
            .quiz-sidebar { 
                width: 100%; 
                height: auto; 
                max-height: 150px; 
                border-left: none; 
                border-top: 1px solid #eee;
                order: -1;
            }
            .question-grid { grid-template-columns: repeat(8, 1fr); }
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('flashcard')">üìö Flashcards</button>
            <button class="tab-btn" onclick="switchTab('quiz')">üìù Quiz (Luy·ªán t·∫≠p)</button>
        </div>
        <button class="lang-btn" onclick="toggleLanguage()">üåê VN / EN</button>
    </div>

    <div class="main-container">
        
        <div class="content-area">

            <div id="flashcard-view">
                <div class="filter-container">
                    <label style="font-weight:bold; color:var(--primary-color);">üìñ L·ªçc theo ch·ªß ƒë·ªÅ:</label>
                    <select id="fc-category-select" onchange="updateFlashcardFilter()" class="custom-select" style="margin-left:10px;">
                        <option value="all">T·∫•t c·∫£</option>
                    </select>
                </div>

                <div class="flashcard-wrapper">
                    <div class="flashcard" onclick="this.classList.toggle('flipped')">
                        <div class="card-face card-front">
                            <div style="position: absolute; top: 15px; left: 20px; font-size: 12px; color: #999; font-weight: bold; background: #f0f0f0; padding: 4px 8px; border-radius: 4px;" id="fc-category-tag">Category</div>
                            <small style="color: #888; margin-bottom: 10px;">Click th·∫ª ƒë·ªÉ l·∫≠t</small>
                            <div id="fc-content" style="width: 100%;"></div>
                        </div>
                        <div class="card-face card-back">
                            <h3 style="color: var(--secondary-color); margin-bottom: 10px;" id="txt-fc-ans">ƒê√°p √Ån</h3>
                            <div id="fc-answer" style="font-size: 20px; font-weight: bold; margin-bottom: 20px;"></div>
                            <div style="text-align: left; width: 100%;">
                                <strong id="txt-fc-exp">Gi·∫£i th√≠ch:</strong>
                                <div id="fc-explanation"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display:flex; justify-content:center; gap:20px;">
                    <button class="nav-btn secondary" onclick="navFlashcard(-1)">Prev</button>
                    <span id="fc-counter" style="align-self:center; font-weight:bold;">1 / 1</span>
                    <button class="nav-btn" onclick="navFlashcard(1)">Next</button>
                </div>
                <div class="shortcut-hint">
                    Ph√≠m t·∫Øt: ‚¨ÖÔ∏è ‚û°Ô∏è (Chuy·ªÉn th·∫ª) | Space/Enter (L·∫≠t th·∫ª)
                </div>
            </div>

            <div id="quiz-setup" class="hidden">
                <h2 id="txt-setup-title">C·∫•u h√¨nh luy·ªán t·∫≠p</h2>
                
                <div style="margin-bottom: 20px; text-align: left;">
                    <label style="font-weight:bold;">1. Ch·ªçn n·ªôi dung √¥n t·∫≠p:</label><br>
                    <select id="quiz-category-select" onchange="updateQuizCountMax()" class="custom-select" style="width:100%; margin-top:10px;">
                        <option value="all">To√†n b·ªô ng√¢n h√†ng c√¢u h·ªèi</option>
                    </select>
                </div>

                <div style="margin-bottom: 30px; text-align: left;">
                    <label style="font-weight:bold;" id="txt-q-count">2. S·ªë l∆∞·ª£ng c√¢u h·ªèi:</label>
                    <div style="display: flex; align-items: center; margin-top: 10px; justify-content: space-between;">
                        <input type="number" id="quiz-count-input" min="1" value="10">
                        <div style="font-size: 14px; color: #666;">
                            <span id="txt-total">C√≥ s·∫µn:</span> <span id="total-qs" style="font-weight:bold; color:var(--primary-color)">0</span>
                        </div>
                    </div>
                </div>
                
                <button class="start-btn" onclick="startQuiz()" id="txt-start" style="width: 100%;">B·∫Øt ƒë·∫ßu ngay üöÄ</button>
            </div>

            <div id="quiz-active" class="hidden">
                <div class="question-card">
                    <div class="flex-between" style="margin-bottom:15px; color:#666;">
                        <span id="quiz-progress">Question 1/10</span>
                        <span style="color:var(--primary-color); font-weight:bold;" id="txt-doing">Ch·∫ø ƒë·ªô luy·ªán t·∫≠p</span>
                    </div>
                    <div id="q-content"></div>
                    <ul class="options-list" id="q-options"></ul>

                    <div class="explanation-box" id="q-explanation"></div>
                </div>

                <div class="flex-between">
                    <button class="nav-btn secondary" onclick="navQuiz(-1)" id="btn-prev">Tr∆∞·ªõc</button>
                    
                    <button class="submit-btn" onclick="finishQuiz()" id="btn-submit">N·ªôp b√†i & Xem ƒëi·ªÉm</button>
                    
                    <button class="nav-btn" onclick="navQuiz(1)" id="btn-next">Sau</button>
                </div>
                <div class="shortcut-hint">
                    Ph√≠m t·∫Øt: ‚¨ÖÔ∏è ‚û°Ô∏è (Chuy·ªÉn c√¢u) | Ph√≠m 1-4 ho·∫∑c A-D (Ch·ªçn ƒë√°p √°n)
                </div>
            </div>

            <div id="quiz-result" class="hidden">
                <div class="result-header">
                    <h2 id="txt-result-title">K·∫øt qu·∫£ b√†i l√†m</h2>
                    <div class="score-number" id="score-val">0/0</div>
                    <p id="score-percent">(0%)</p>
                    <button class="start-btn" onclick="resetQuiz()">L√†m ƒë·ªÅ m·ªõi üîÑ</button>
                </div>

                <div id="review-list">
                </div>
            </div>

        </div>

        <div class="quiz-sidebar hidden" id="quiz-sidebar">
            <div style="font-weight:bold; margin-bottom:15px;" id="txt-map">B·∫£n ƒë·ªì c√¢u h·ªèi</div>
            <div class="question-grid" id="map-grid"></div>
            
            <div style="margin-top:20px; font-size:12px; color:#666;">
                <div class="flex-between" style="justify-content: flex-start; margin-bottom:5px;">
                    <div style="width:12px; height:12px; border:2px solid var(--primary-color); margin-right:8px;"></div> 
                    <span id="leg-current">ƒêang l√†m</span>
                </div>
                <div class="flex-between" style="justify-content: flex-start; margin-bottom:5px;">
                    <div style="width:12px; height:12px; background:var(--secondary-color); margin-right:8px;"></div> 
                    <span id="leg-correct">ƒê√∫ng</span>
                </div>
                <div class="flex-between" style="justify-content: flex-start;">
                    <div style="width:12px; height:12px; background:var(--danger-color); margin-right:8px;"></div> 
                    <span id="leg-wrong">Sai</span>
                </div>
            </div>
        </div>

    </div>

<script>
    // ======================================================
    // 1. D·ªÆ LI·ªÜU NG√ÇN H√ÄNG C√ÇU H·ªéI
    // ======================================================
   const quizData = [
    // Chuy√™n m·ª•c 1: Introduction (Gi·ªõi thi·ªáu) - 15 c√¢u
    {
        "id": 1,
        "en": {
            "question": "What are the four basic functions that a computer performs?",
            "options": [
                "A. Data processing, Data storage, Data movement, Control.",
                "B. Data processing, Data storage, Data movement, Interrupt.",
                "C. Data processing, Data storage, Interrupt, Control.",
                "D. Data processing, Interrupt, Data movement, Control."
            ],
            "answer": "A. Data processing, Data storage, Data movement, Control.",
            "explanation": "These are the four core functions. An 'Interrupt' is a mechanism for managing these functions, not a fundamental function in this model."
        },
        "vi": {
            "question": "B·ªën ch·ª©c nƒÉng c∆° b·∫£n m√† m·ªôt m√°y t√≠nh th·ª±c hi·ªán l√† g√¨?",
            "options": [
                "A. X·ª≠ l√Ω d·ªØ li·ªáu, L∆∞u tr·ªØ d·ªØ li·ªáu, Di chuy·ªÉn d·ªØ li·ªáu, ƒêi·ªÅu khi·ªÉn.",
                "B. X·ª≠ l√Ω d·ªØ li·ªáu, L∆∞u tr·ªØ d·ªØ li·ªáu, Di chuy·ªÉn d·ªØ li·ªáu, Ng·∫Øt.",
                "C. X·ª≠ l√Ω d·ªØ li·ªáu, L∆∞u tr·ªØ d·ªØ li·ªáu, Ng·∫Øt, ƒêi·ªÅu khi·ªÉn.",
                "D. X·ª≠ l√Ω d·ªØ li·ªáu, Ng·∫Øt, Di chuy·ªÉn d·ªØ li·ªáu, ƒêi·ªÅu khi·ªÉn."
            ],
            "answer": "A. X·ª≠ l√Ω d·ªØ li·ªáu, L∆∞u tr·ªØ d·ªØ li·ªáu, Di chuy·ªÉn d·ªØ li·ªáu, ƒêi·ªÅu khi·ªÉn.",
            "explanation": "ƒê√¢y l√† b·ªën ch·ª©c nƒÉng c·ªët l√µi. 'Ng·∫Øt' l√† m·ªôt c∆° ch·∫ø ƒë·ªÉ qu·∫£n l√Ω c√°c ch·ª©c nƒÉng n√†y, kh√¥ng ph·∫£i l√† m·ªôt ch·ª©c nƒÉng c∆° b·∫£n trong m√¥ h√¨nh n√†y."
        }
    },
    {
        "id": 2,
        "en": {
            "question": "What is the function of the system bus in a computer?",
            "options": [
                "A. To expand the communication functionality of the computer.",
                "B. To connect the components within the computer.",
                "C. To control peripheral devices.",
                "D. To transform signals within the computer."
            ],
            "answer": "B. To connect the components within the computer.",
            "explanation": "The system bus is the communication pathway connecting the major components of a computer, such as the CPU, memory, and I/O modules."
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng c·ªßa bus h·ªá th·ªëng trong m√°y t√≠nh l√† g√¨?",
            "options": [
                "A. M·ªü r·ªông ch·ª©c nƒÉng giao ti·∫øp c·ªßa m√°y t√≠nh.",
                "B. K·∫øt n·ªëi c√°c th√†nh ph·∫ßn trong m√°y t√≠nh.",
                "C. ƒêi·ªÅu khi·ªÉn c√°c thi·∫øt b·ªã ngo·∫°i vi.",
                "D. Bi·∫øn ƒë·ªïi c√°c t√≠n hi·ªáu trong m√°y t√≠nh."
            ],
            "answer": "B. K·∫øt n·ªëi c√°c th√†nh ph·∫ßn trong m√°y t√≠nh.",
            "explanation": "Bus h·ªá th·ªëng l√† ƒë∆∞·ªùng truy·ªÅn th√¥ng k·∫øt n·ªëi c√°c th√†nh ph·∫ßn ch√≠nh c·ªßa m√°y t√≠nh, nh∆∞ CPU, b·ªô nh·ªõ, v√† c√°c m√¥-ƒëun I/O."
        }
    },
    {
        "id": 3,
        "en": {
            "question": "The basic components of a computer are:",
            "options": [
                "A. Main memory, CPU, I/O modules, and system interconnection.",
                "B. Main memory, CPU, I/O modules, and storage devices.",
                "C. Main memory, CPU, peripherals, and storage devices.",
                "D. Main memory, CPU, I/O modules, and peripherals."
            ],
            "answer": "A. Main memory, CPU, I/O modules, and system interconnection.",
            "explanation": "Structurally, a computer consists of a CPU, main memory, I/O modules, and the system interconnection (like the system bus) that links them all."
        },
        "vi": {
            "question": "C√°c th√†nh ph·∫ßn c∆° b·∫£n c·ªßa m·ªôt m√°y t√≠nh l√†:",
            "options": [
                "A. B·ªô nh·ªõ ch√≠nh, CPU, m√¥-ƒëun I/O v√† k·∫øt n·ªëi h·ªá th·ªëng.",
                "B. B·ªô nh·ªõ ch√≠nh, CPU, m√¥-ƒëun I/O v√† thi·∫øt b·ªã l∆∞u tr·ªØ.",
                "C. B·ªô nh·ªõ ch√≠nh, CPU, thi·∫øt b·ªã ngo·∫°i vi v√† thi·∫øt b·ªã l∆∞u tr·ªØ.",
                "D. B·ªô nh·ªõ ch√≠nh, CPU, m√¥-ƒëun I/O v√† thi·∫øt b·ªã ngo·∫°i vi."
            ],
            "answer": "A. B·ªô nh·ªõ ch√≠nh, CPU, m√¥-ƒëun I/O v√† k·∫øt n·ªëi h·ªá th·ªëng.",
            "explanation": "V·ªÅ m·∫∑t c·∫•u tr√∫c, m·ªôt m√°y t√≠nh bao g·ªìm CPU, b·ªô nh·ªõ ch√≠nh, c√°c m√¥-ƒëun I/O, v√† k·∫øt n·ªëi h·ªá th·ªëng (nh∆∞ bus h·ªá th·ªëng) ƒë·ªÉ li√™n k·∫øt t·∫•t c·∫£ ch√∫ng."
        }
    },
    {
        "id": 4,
        "en": {
            "question": "The Von Neumann architecture is based on which concept?",
            "options": [
                "A. data and instructions are stored in a single read-write memory",
                "B. the contents of this memory are addressable by location",
                "C. execution occurs in a sequential fashion",
                "D. all of the above"
            ],
            "answer": "D. all of the above",
            "explanation": "The Von Neumann architecture is defined by three key concepts: a single memory for both data and instructions, addressable memory locations, and sequential instruction execution."
        },
        "vi": {
            "question": "Ki·∫øn tr√∫c von Neumann d·ª±a tr√™n kh√°i ni·ªám n√†o?",
            "options": [
                "A. d·ªØ li·ªáu v√† l·ªánh ƒë∆∞·ª£c l∆∞u tr·ªØ trong m·ªôt b·ªô nh·ªõ ƒë·ªçc-ghi duy nh·∫•t",
                "B. n·ªôi dung c·ªßa b·ªô nh·ªõ n√†y c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·ªãnh ƒë·ªãa ch·ªâ theo v·ªã tr√≠",
                "C. vi·ªác th·ª±c thi di·ªÖn ra theo m·ªôt tr√¨nh t·ª± tu·∫ßn t·ª±",
                "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n"
            ],
            "answer": "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n",
            "explanation": "Ki·∫øn tr√∫c von Neumann ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi ba kh√°i ni·ªám ch√≠nh: m·ªôt b·ªô nh·ªõ duy nh·∫•t cho c·∫£ d·ªØ li·ªáu v√† l·ªánh, c√°c v·ªã tr√≠ b·ªô nh·ªõ c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ, v√† vi·ªác th·ª±c thi l·ªánh tu·∫ßn t·ª±."
        }
    },
    {
        "id": 5,
        "en": {
            "question": "Which of the following is NOT part of the Von Neumann principles?",
            "options": [
                "A. The computer can operate according to a stored program.",
                "B. The computer uses a program counter to indicate the location of the next instruction.",
                "C. The computer's memory is addressable.",
                "D. Each instruction must have a memory area containing the address of the next instruction."
            ],
            "answer": "D. Each instruction must have a memory area containing the address of the next instruction.",
            "explanation": "In the Von Neumann model, the Program Counter (PC) holds the address of the next instruction. The instruction itself does not need to store this address."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y KH√îNG ph·∫£i l√† m·ªôt ph·∫ßn c·ªßa nguy√™n l√Ω Von Neumann?",
            "options": [
                "A. M√°y t√≠nh c√≥ th·ªÉ ho·∫°t ƒë·ªông theo m·ªôt ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ.",
                "B. M√°y t√≠nh s·ª≠ d·ª•ng m·ªôt b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh ƒë·ªÉ ch·ªâ ra v·ªã tr√≠ c·ªßa c√¢u l·ªánh ti·∫øp theo.",
                "C. B·ªô nh·ªõ c·ªßa m√°y t√≠nh c√≥ th·ªÉ ƒë·ªãa ch·ªâ h√≥a ƒë∆∞·ª£c.",
                "D. M·ªói c√¢u l·ªánh ph·∫£i c√≥ m·ªôt v√πng nh·ªõ ch·ª©a ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo."
            ],
            "answer": "D. M·ªói c√¢u l·ªánh ph·∫£i c√≥ m·ªôt v√πng nh·ªõ ch·ª©a ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo.",
            "explanation": "Trong m√¥ h√¨nh Von Neumann, B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) gi·ªØ ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo. B·∫£n th√¢n l·ªánh kh√¥ng c·∫ßn ph·∫£i l∆∞u tr·ªØ ƒë·ªãa ch·ªâ n√†y."
        }
    },
    {
        "id": 6,
        "en": {
            "question": "What is the difference between Computer Architecture and Computer Organization?",
            "options": [
                "A. Computer Architecture is how the system is structured, while Computer Organization is the attributes of a system visible to the user.",
                "B. Computer Architecture is the attributes of a system visible to the programmer, while Computer Organization is how those features are implemented.",
                "C. Computer Architecture and Computer Organization are the same.",
                "D. Computer Architecture is slower than Computer Organization."
            ],
            "answer": "B. Computer Architecture is the attributes of a system visible to the programmer, while Computer Organization is how those features are implemented.",
            "explanation": "Architecture is the 'what' (e.g., instruction set, data types), while Organization is the 'how' (e.g., control signals, memory technology)."
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát gi·ªØa Ki·∫øn tr√∫c m√°y t√≠nh (Computer Architecture) v√† T·ªï ch·ª©c m√°y t√≠nh (Computer Organization) l√† g√¨?",
            "options": [
                "A. Ki·∫øn tr√∫c m√°y t√≠nh l√† c√°ch h·ªá th·ªëng ƒë∆∞·ª£c c·∫•u tr√∫c, trong khi T·ªï ch·ª©c m√°y t√≠nh l√† nh·ªØng thu·ªôc t√≠nh c·ªßa m·ªôt h·ªá th·ªëng c√≥ th·ªÉ nh√¨n th·∫•y b·ªüi ng∆∞·ªùi d√πng.",
                "B. Ki·∫øn tr√∫c m√°y t√≠nh l√† nh·ªØng thu·ªôc t√≠nh c·ªßa m·ªôt h·ªá th·ªëng c√≥ th·ªÉ nh√¨n th·∫•y b·ªüi l·∫≠p tr√¨nh vi√™n, trong khi T·ªï ch·ª©c m√°y t√≠nh l√† c√°ch c√°c t√≠nh nƒÉng ƒë√≥ ƒë∆∞·ª£c tri·ªÉn khai.",
                "C. Ki·∫øn tr√∫c m√°y t√≠nh v√† T·ªï ch·ª©c m√°y t√≠nh l√† gi·ªëng nhau.",
                "D. Ki·∫øn tr√∫c m√°y t√≠nh ch·∫≠m h∆°n T·ªï ch·ª©c m√°y t√≠nh."
            ],
            "answer": "B. Ki·∫øn tr√∫c m√°y t√≠nh l√† nh·ªØng thu·ªôc t√≠nh c·ªßa m·ªôt h·ªá th·ªëng c√≥ th·ªÉ nh√¨n th·∫•y b·ªüi l·∫≠p tr√¨nh vi√™n, trong khi T·ªï ch·ª©c m√°y t√≠nh l√† c√°ch c√°c t√≠nh nƒÉng ƒë√≥ ƒë∆∞·ª£c tri·ªÉn khai.",
            "explanation": "Ki·∫øn tr√∫c l√† 'c√°i g√¨' (v√≠ d·ª•: t·∫≠p l·ªánh, ki·ªÉu d·ªØ li·ªáu), trong khi T·ªï ch·ª©c l√† 'l√†m th·∫ø n√†o' (v√≠ d·ª•: t√≠n hi·ªáu ƒëi·ªÅu khi·ªÉn, c√¥ng ngh·ªá b·ªô nh·ªõ)."
        }
    },
    {
        "id": 7,
        "en": {
            "question": "Which of the following attributes does not belong to computer architecture?",
            "options": [
                "A. The number of bits used to represent data types.",
                "B. The instruction set.",
                "C. The interface between the computer and peripherals.",
                "D. Techniques for addressing memory.",
                "E. The memory technology used.",
                "F. I/O mechanisms."
            ],
            "answer": "C. The interface between the computer and peripherals.",
            "explanation": "Interfaces, memory technology, and specific I/O mechanisms are part of Computer Organization, which deals with implementation details. Architecture deals with attributes visible to the programmer, like the instruction set and data types."
        },
        "vi": {
            "question": "Thu·ªôc t√≠nh n√†o sau ƒë√¢y kh√¥ng thu·ªôc v·ªÅ ki·∫øn tr√∫c m√°y t√≠nh?",
            "options": [
                "A. S·ªë bit ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ bi·ªÉu di·ªÖn c√°c ki·ªÉu d·ªØ li·ªáu.",
                "B. T·∫≠p l·ªánh.",
                "C. Giao di·ªán gi·ªØa m√°y t√≠nh v√† c√°c thi·∫øt b·ªã ngo·∫°i vi.",
                "D. C√°c k·ªπ thu·∫≠t ƒë·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ b·ªô nh·ªõ.",
                "E. C√¥ng ngh·ªá b·ªô nh·ªõ ƒë∆∞·ª£c s·ª≠ d·ª•ng.",
                "F. C∆° ch·∫ø I/O."
            ],
            "answer": "C. Giao di·ªán gi·ªØa m√°y t√≠nh v√† c√°c thi·∫øt b·ªã ngo·∫°i vi.",
            "explanation": "Giao di·ªán, c√¥ng ngh·ªá b·ªô nh·ªõ, v√† c∆° ch·∫ø I/O c·ª• th·ªÉ l√† m·ªôt ph·∫ßn c·ªßa T·ªï ch·ª©c m√°y t√≠nh, li√™n quan ƒë·∫øn chi ti·∫øt tri·ªÉn khai. Ki·∫øn tr√∫c li√™n quan ƒë·∫øn c√°c thu·ªôc t√≠nh m√† l·∫≠p tr√¨nh vi√™n c√≥ th·ªÉ th·∫•y, nh∆∞ t·∫≠p l·ªánh v√† ki·ªÉu d·ªØ li·ªáu. (ƒê√°p √°n E v√† F c≈©ng thu·ªôc v·ªÅ T·ªï ch·ª©c)."
        }
    },
    {
        "id": 8,
        "en": {
            "question": "Which part of the computer consists of an ALU, a control unit, and registers, used to fetch and execute instructions?",
            "options": [
                "A. Main memory",
                "B. CPU",
                "C. I/O",
                "D. System interconnection"
            ],
            "answer": "B. CPU",
            "explanation": "The Central Processing Unit (CPU) is the core component that contains the Arithmetic Logic Unit (ALU), Control Unit (CU), and registers."
        },
        "vi": {
            "question": "Ph·∫ßn n√†o c·ªßa m√°y t√≠nh bao g·ªìm m·ªôt ALU, m·ªôt ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn v√† c√°c thanh ghi, s·ª≠ d·ª•ng ƒë·ªÉ t√¨m n·∫°p v√† th·ª±c thi c√°c l·ªánh?",
            "options": [
                "A. B·ªô nh·ªõ ch√≠nh (Main memory)",
                "B. CPU",
                "C. I/O",
                "D. K·∫øt n·ªëi h·ªá th·ªëng (System interconnection)"
            ],
            "answer": "B. CPU",
            "explanation": "ƒê∆°n v·ªã x·ª≠ l√Ω trung t√¢m (CPU) l√† th√†nh ph·∫ßn c·ªët l√µi ch·ª©a ƒê∆°n v·ªã s·ªë h·ªçc v√† logic (ALU), ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn (CU), v√† c√°c thanh ghi."
        }
    },
    {
        "id": 9,
        "en": {
            "question": "Which component interprets instructions in memory and causes them to be executed?",
            "options": [
                "A. Registers",
                "B. CPU interconnection",
                "C. Arithmetic and Logic Unit (ALU)",
                "D. I/O Module",
                "E. Control Unit (CU)"
            ],
            "answer": "E. Control Unit (CU)",
            "explanation": "The Control Unit is responsible for fetching, decoding, and orchestrating the execution of instructions."
        },
        "vi": {
            "question": "___ di·ªÖn gi·∫£i c√°c l·ªánh trong b·ªô nh·ªõ v√† khi·∫øn ch√∫ng ƒë∆∞·ª£c th·ª±c thi.",
            "options": [
                "A. Thanh ghi",
                "B. K·∫øt n·ªëi CPU",
                "C. ƒê∆°n v·ªã s·ªë h·ªçc v√† logic (ALU)",
                "D. M√¥-ƒëun I/O",
                "E. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn (CU)"
            ],
            "answer": "E. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn (CU)",
            "explanation": "ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn ch·ªãu tr√°ch nhi·ªám t√¨m n·∫°p, gi·∫£i m√£ v√† ƒëi·ªÅu ph·ªëi vi·ªác th·ª±c thi c√°c l·ªánh."
        }
    },
    {
        "id": 10,
        "en": {
            "question": "Which component performs the computer's data processing functions?",
            "options": [
                "A. Arithmetic and Logic Unit (ALU)",
                "B. Control Unit",
                "C. CPU Interconnection",
                "D. Registers"
            ],
            "answer": "A. Arithmetic and Logic Unit (ALU)",
            "explanation": "The ALU (Arithmetic and Logic Unit) is the part of the CPU that performs arithmetic (addition, subtraction) and logical (AND, OR, NOT) operations."
        },
        "vi": {
            "question": "___ th·ª±c hi·ªán c√°c ch·ª©c nƒÉng x·ª≠ l√Ω d·ªØ li·ªáu c·ªßa m√°y t√≠nh.",
            "options": [
                "A. ƒê∆°n v·ªã s·ªë h·ªçc v√† logic (ALU)",
                "B. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn",
                "C. K·∫øt n·ªëi CPU",
                "D. Thanh ghi"
            ],
            "answer": "A. ƒê∆°n v·ªã s·ªë h·ªçc v√† logic (ALU)",
            "explanation": "ALU (ƒê∆°n v·ªã s·ªë h·ªçc v√† logic) l√† b·ªô ph·∫≠n c·ªßa CPU th·ª±c hi·ªán c√°c ph√©p to√°n s·ªë h·ªçc (c·ªông, tr·ª´) v√† logic (AND, OR, NOT)."
        }
    },
    {
        "id": 11,
        "en": {
            "question": "Which component controls the movement of data and instructions into and out of the processor?",
            "options": [
                "A. shifter",
                "B. ALU",
                "C. branch",
                "D. control unit"
            ],
            "answer": "D. control unit",
            "explanation": "The Control Unit manages and coordinates all of the processor's operations, including data movement."
        },
        "vi": {
            "question": "____ ƒëi·ªÅu khi·ªÉn s·ª± di chuy·ªÉn c·ªßa d·ªØ li·ªáu v√† c√°c l·ªánh v√†o v√† ra kh·ªèi b·ªô x·ª≠ l√Ω.",
            "options": [
                "A. shifter",
                "B. ALU",
                "C. branch",
                "D. control unit"
            ],
            "answer": "D. control unit",
            "explanation": "ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn qu·∫£n l√Ω v√† ph·ªëi h·ª£p t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông c·ªßa b·ªô x·ª≠ l√Ω, bao g·ªìm c·∫£ vi·ªác di chuy·ªÉn d·ªØ li·ªáu."
        }
    },
    {
        "id": 12,
        "en": {
            "question": "A specific architecture can last for many years and encompass a number of different computer models, its organization changing with changing technology.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "This is a key concept. For example, the x86 architecture has persisted for decades across countless models with vastly different internal organizations."
        },
        "vi": {
            "question": "M·ªôt ki·∫øn tr√∫c c·ª• th·ªÉ c√≥ th·ªÉ t·ªìn t·∫°i trong nhi·ªÅu nƒÉm v√† bao g·ªìm m·ªôt s·ªë m√¥ h√¨nh m√°y t√≠nh kh√°c nhau, t·ªï ch·ª©c c·ªßa n√≥ thay ƒë·ªïi theo c√¥ng ngh·ªá thay ƒë·ªïi.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "ƒê√¢y l√† m·ªôt kh√°i ni·ªám quan tr·ªçng. V√≠ d·ª•, ki·∫øn tr√∫c x86 ƒë√£ t·ªìn t·∫°i trong nhi·ªÅu th·∫≠p k·ª∑ qua v√¥ s·ªë m√¥ h√¨nh v·ªõi c√°c t·ªï ch·ª©c n·ªôi b·ªô r·∫•t kh√°c nhau."
        }
    },
    {
        "id": 13,
        "en": {
            "question": "Changes in technology not only influence organization but also result in the introduction of more powerful and more complex architectures.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Advances in technology (like multicore processing) enable new architectural features that were previously not feasible."
        },
        "vi": {
            "question": "Nh·ªØng thay ƒë·ªïi trong c√¥ng ngh·ªá kh√¥ng ch·ªâ ·∫£nh h∆∞·ªüng ƒë·∫øn t·ªï ch·ª©c m√† c√≤n d·∫´n ƒë·∫øn s·ª± ra ƒë·ªùi c·ªßa c√°c ki·∫øn tr√∫c m·∫°nh m·∫Ω v√† ph·ª©c t·∫°p h∆°n.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Nh·ªØng ti·∫øn b·ªô trong c√¥ng ngh·ªá (nh∆∞ x·ª≠ l√Ω ƒëa l√µi) cho ph√©p c√°c t√≠nh nƒÉng ki·∫øn tr√∫c m·ªõi m√† tr∆∞·ªõc ƒë√¢y kh√¥ng kh·∫£ thi."
        }
    },
    {
        "id": 14,
        "en": {
            "question": "The hierarchical nature of complex systems is essential to both their design and their description.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Complex systems like computers are designed and understood by breaking them down into hierarchical levels, from gates to functional units to the full system."
        },
        "vi": {
            "question": "B·∫£n ch·∫•t ph√¢n c·∫•p c·ªßa c√°c h·ªá th·ªëng ph·ª©c t·∫°p l√† c·∫ßn thi·∫øt cho c·∫£ thi·∫øt k·∫ø v√† m√¥ t·∫£ c·ªßa ch√∫ng.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "C√°c h·ªá th·ªëng ph·ª©c t·∫°p nh∆∞ m√°y t√≠nh ƒë∆∞·ª£c thi·∫øt k·∫ø v√† hi·ªÉu b·∫±ng c√°ch chia ch√∫ng th√†nh c√°c c·∫•p b·∫≠c, t·ª´ c√°c c·ªïng logic ƒë·∫øn c√°c ƒë∆°n v·ªã ch·ª©c nƒÉng v√† to√†n b·ªô h·ªá th·ªëng."
        }
    },
    {
        "id": 15,
        "en": {
            "question": "Both the structure and functioning of a computer are, in essence, simple.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "At its most fundamental level, a computer operates on simple binary logic (on/off, true/false). The complexity arises from combining billions of these simple operations."
        },
        "vi": {
            "question": "C·∫£ c·∫•u tr√∫c v√† ch·ª©c nƒÉng c·ªßa m·ªôt m√°y t√≠nh v·ªÅ b·∫£n ch·∫•t ƒë·ªÅu ƒë∆°n gi·∫£n.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "·ªû c·∫•p ƒë·ªô c∆° b·∫£n nh·∫•t, m·ªôt m√°y t√≠nh ho·∫°t ƒë·ªông d·ª±a tr√™n logic nh·ªã ph√¢n ƒë∆°n gi·∫£n (b·∫≠t/t·∫Øt, ƒë√∫ng/sai). S·ª± ph·ª©c t·∫°p n·∫£y sinh t·ª´ vi·ªác k·∫øt h·ª£p h√†ng t·ª∑ ho·∫°t ƒë·ªông ƒë∆°n gi·∫£n n√†y."
        }
    },
    // Chuy√™n m·ª•c 2: Computer Evolution and Performance (L·ªãch s·ª≠ v√† Hi·ªáu nƒÉng) - 42 c√¢u
    {
        "id": 16,
        "en": {
            "question": "The world's first general-purpose electronic digital computer was designed and constructed at The Ohio State University.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The ENIAC (Electronic Numerical Integrator And Computer) was designed and constructed at the University of Pennsylvania."
        },
        "vi": {
            "question": "M√°y t√≠nh ƒëi·ªán t·ª≠ k·ªπ thu·∫≠t s·ªë ƒëa nƒÉng ƒë·∫ßu ti√™n tr√™n th·∫ø gi·ªõi ƒë∆∞·ª£c thi·∫øt k·∫ø v√† ch·∫ø t·∫°o t·∫°i ƒê·∫°i h·ªçc bang Ohio.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ENIAC (Electronic Numerical Integrator And Computer) ƒë∆∞·ª£c thi·∫øt k·∫ø v√† ch·∫ø t·∫°o t·∫°i ƒê·∫°i h·ªçc Pennsylvania."
        }
    },
    {
        "id": 17,
        "en": {
            "question": "John Mauchly and John Eckert designed the ENIAC.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "John Mauchly and J. Presper Eckert were the principal designers of the ENIAC at the Moore School of Electrical Engineering, University of Pennsylvania."
        },
        "vi": {
            "question": "John Mauchly v√† John Eckert ƒë√£ thi·∫øt k·∫ø ENIAC.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "John Mauchly v√† J. Presper Eckert l√† nh·ªØng nh√† thi·∫øt k·∫ø ch√≠nh c·ªßa ENIAC t·∫°i Tr∆∞·ªùng K·ªπ thu·∫≠t ƒêi·ªán Moore, ƒê·∫°i h·ªçc Pennsylvania."
        }
    },
    {
        "id": 18,
        "en": {
            "question": "The major drawback of the EDVAC was that it had to be programmed manually by setting switches and plugging and unplugging cables.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "This was the major drawback of the ENIAC. The EDVAC (Electronic Discrete Variable Automatic Computer) was designed with the stored-program concept to overcome this limitation."
        },
        "vi": {
            "question": "H·∫°n ch·∫ø l·ªõn c·ªßa EDVAC l√† n√≥ ph·∫£i ƒë∆∞·ª£c l·∫≠p tr√¨nh th·ªß c√¥ng b·∫±ng c√°ch c√†i ƒë·∫∑t c√°c c√¥ng t·∫Øc v√† c·∫Øm c√°p.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ƒê√¢y l√† h·∫°n ch·∫ø l·ªõn c·ªßa ENIAC. EDVAC (Electronic Discrete Variable Automatic Computer) ƒë∆∞·ª£c thi·∫øt k·∫ø v·ªõi kh√°i ni·ªám ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ ƒë·ªÉ kh·∫Øc ph·ª•c h·∫°n ch·∫ø n√†y."
        }
    },
    {
        "id": 19,
        "en": {
            "question": "The IAS machine operates by repetitively performing an instruction cycle.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "The IAS computer, a prototype of modern computers, was based on the Von Neumann architecture and operated using the fetch-execute instruction cycle."
        },
        "vi": {
            "question": "M√°y IAS ho·∫°t ƒë·ªông b·∫±ng c√°ch th·ª±c hi·ªán l·∫∑p ƒëi l·∫∑p l·∫°i m·ªôt chu k·ª≥ l·ªánh.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "M√°y t√≠nh IAS, m·ªôt nguy√™n m·∫´u c·ªßa m√°y t√≠nh hi·ªán ƒë·∫°i, d·ª±a tr√™n ki·∫øn tr√∫c Von Neumann v√† ho·∫°t ƒë·ªông b·∫±ng c√°ch s·ª≠ d·ª•ng chu tr√¨nh l·ªánh t√¨m n·∫°p-th·ª±c thi."
        }
    },
    {
        "id": 20,
        "en": {
            "question": "Backward compatibility means that programs written for older machines can be executed on new machines.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Backward compatibility is a crucial feature in computer evolution, allowing software to remain usable as hardware evolves."
        },
        "vi": {
            "question": "T∆∞∆°ng th√≠ch ng∆∞·ª£c c√≥ nghƒ©a l√† c√°c ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c vi·∫øt cho c√°c m√°y c≈© h∆°n c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c thi tr√™n m√°y m·ªõi.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "T∆∞∆°ng th√≠ch ng∆∞·ª£c l√† m·ªôt t√≠nh nƒÉng quan tr·ªçng trong qu√° tr√¨nh ph√°t tri·ªÉn m√°y t√≠nh, cho ph√©p ph·∫ßn m·ªÅm v·∫´n c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë∆∞·ª£c khi ph·∫ßn c·ª©ng ph√°t tri·ªÉn."
        }
    },
    {
        "id": 21,
        "en": {
            "question": "Computers are classified into generations based on the fundamental hardware technology employed.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "The generations are typically defined by: 1st (Vacuum Tubes), 2nd (Transistors), 3rd (Integrated Circuits), 4th (Microprocessors/VLSI)."
        },
        "vi": {
            "question": "M√°y t√≠nh ƒë∆∞·ª£c ph√¢n lo·∫°i th√†nh c√°c th·∫ø h·ªá d·ª±a tr√™n c√¥ng ngh·ªá ph·∫ßn c·ª©ng c∆° b·∫£n ƒë∆∞·ª£c s·ª≠ d·ª•ng.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "C√°c th·∫ø h·ªá th∆∞·ªùng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi: 1 (ƒê√®n ch√¢n kh√¥ng), 2 (B√≥ng b√°n d·∫´n), 3 (M·∫°ch t√≠ch h·ª£p), 4 (Vi x·ª≠ l√Ω/VLSI)."
        }
    },
    {
        "id": 22,
        "en": {
            "question": "System software was introduced in the third generation of computers.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "The third generation, with the advent of integrated circuits, saw the development of more complex system software, including sophisticated operating systems like OS/360."
        },
        "vi": {
            "question": "Ph·∫ßn m·ªÅm h·ªá th·ªëng th·ª±c s·ª± ƒë√£ ƒë∆∞·ª£c gi·ªõi thi·ªáu trong th·∫ø h·ªá m√°y t√≠nh th·ª© ba.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Th·∫ø h·ªá th·ª© ba, v·ªõi s·ª± ra ƒë·ªùi c·ªßa m·∫°ch t√≠ch h·ª£p, ƒë√£ ch·ª©ng ki·∫øn s·ª± ph√°t tri·ªÉn c·ªßa ph·∫ßn m·ªÅm h·ªá th·ªëng ph·ª©c t·∫°p h∆°n, bao g·ªìm c√°c h·ªá ƒëi·ªÅu h√†nh tinh vi nh∆∞ OS/360."
        }
    },
    {
        "id": 23,
        "en": {
            "question": "IBM's System/360 was the industry's first planned family of computers.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "The System/360 was a landmark series that featured a range of models with different price points and performance levels but shared the same architecture and instruction set."
        },
        "vi": {
            "question": "IBM's System/360 l√† d√≤ng m√°y t√≠nh ƒë∆∞·ª£c l√™n k·∫ø ho·∫°ch ƒë·∫ßu ti√™n c·ªßa ng√†nh c√¥ng nghi·ªáp.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "System/360 l√† m·ªôt d√≤ng m√°y t√≠nh mang t√≠nh b∆∞·ªõc ngo·∫∑t v·ªõi m·ªôt lo·∫°t c√°c m√¥ h√¨nh c√≥ c√°c m·ª©c gi√° v√† hi·ªáu su·∫•t kh√°c nhau nh∆∞ng chia s·∫ª c√πng m·ªôt ki·∫øn tr√∫c v√† t·∫≠p l·ªánh."
        }
    },
    {
        "id": 24,
        "en": {
            "question": "Intel's 4004 was the first chip to contain all of the components of a CPU on a single chip.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "The Intel 4004, released in 1971, is widely considered the first commercially available microprocessor, integrating all CPU components onto one chip."
        },
        "vi": {
            "question": "Intel's 4004 l√† chip ƒë·∫ßu ti√™n ch·ª©a t·∫•t c·∫£ c√°c th√†nh ph·∫ßn c·ªßa m·ªôt CPU tr√™n m·ªôt chip duy nh·∫•t.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Intel 4004, ƒë∆∞·ª£c ph√°t h√†nh v√†o nƒÉm 1971, ƒë∆∞·ª£c coi l√† b·ªô vi x·ª≠ l√Ω th∆∞∆°ng m·∫°i ƒë·∫ßu ti√™n, t√≠ch h·ª£p t·∫•t c·∫£ c√°c th√†nh ph·∫ßn CPU tr√™n m·ªôt con chip."
        }
    },
    {
        "id": 25,
        "en": {
            "question": "The Intel x86 evolved from RISC design principles and is used in embedded systems.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The Intel x86 architecture is the quintessential example of a CISC (Complex Instruction Set Computer) design. ARM processors, which are RISC, are commonly used in embedded systems."
        },
        "vi": {
            "question": "Intel x86 ph√°t tri·ªÉn t·ª´ c√°c nguy√™n t·∫Øc thi·∫øt k·∫ø RISC v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h·ªá th·ªëng nh√∫ng.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "Ki·∫øn tr√∫c Intel x86 l√† v√≠ d·ª• tinh t√∫y c·ªßa thi·∫øt k·∫ø CISC (M√°y t√≠nh t·∫≠p l·ªánh ph·ª©c t·∫°p). B·ªô x·ª≠ l√Ω ARM, l√† RISC, th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h·ªá th·ªëng nh√∫ng."
        }
    },
    {
        "id": 26,
        "en": {
            "question": "A common performance measure for a processor is the rate at which instructions are executed, expressed as billions of instructions per second (BIPS).",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The common performance measure is MIPS (Millions of Instructions Per Second). While BIPS is a valid unit, MIPS is the more standard and widely used term."
        },
        "vi": {
            "question": "M·ªôt th∆∞·ªõc ƒëo hi·ªáu su·∫•t ph·ªï bi·∫øn cho m·ªôt b·ªô x·ª≠ l√Ω l√† t·ªëc ƒë·ªô th·ª±c thi l·ªánh, ƒë∆∞·ª£c bi·ªÉu th·ªã b·∫±ng h√†ng t·ª∑ l·ªánh m·ªói gi√¢y (BIPS).",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "Th∆∞·ªõc ƒëo hi·ªáu su·∫•t ph·ªï bi·∫øn l√† MIPS (H√†ng tri·ªáu l·ªánh m·ªói gi√¢y). M·∫∑c d√π BIPS l√† m·ªôt ƒë∆°n v·ªã h·ª£p l·ªá, MIPS l√† thu·∫≠t ng·ªØ chu·∫©n v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i h∆°n."
        }
    },
    {
        "id": 27,
        "en": {
            "question": "A benchmark program is running on a 400 MHz processor... Calculate the MIPS rate for this case. [Data: (300*1 + 100*2 + 100*2) cycles for 500 instructions]",
            "options": [
                "A. MIPS rate = 285.7",
                "B. MIPS rate = 275.7",
                "C. MIPS rate = 265.7",
                "D. MIPS rate = 295.7"
            ],
            "answer": "A. MIPS rate = 285.7",
            "explanation": "Total cycles = (300*1) + (100*2) + (100*2) = 300 + 200 + 200 = 700 cycles. Execution time = 700 cycles / (400 * 10^6 cycles/sec). MIPS = (Total Instructions / Execution Time) / 10^6 = (500 / (700 / 400*10^6)) / 10^6 = (500 * 400) / 700 = 200000 / 700 ‚âà 285.7"
        },
        "vi": {
            "question": "M·ªôt ch∆∞∆°ng tr√¨nh benchmark ƒëang ch·∫°y tr√™n m·ªôt b·ªô x·ª≠ l√Ω 400 MHz... T√≠nh t·ª∑ l·ªá MIPS cho tr∆∞·ªùng h·ª£p n√†y. [D·ªØ li·ªáu: (300*1 + 100*2 + 100*2) chu k·ª≥ cho 500 l·ªánh]",
            "options": [
                "A. MIPS rate = 285.7",
                "B. MIPS rate = 275.7",
                "C. MIPS rate = 265.7",
                "D. MIPS rate = 295.7"
            ],
            "answer": "A. MIPS rate = 285.7",
            "explanation": "T·ªïng chu k·ª≥ = (300*1) + (100*2) + (100*2) = 700 chu k·ª≥. Th·ªùi gian th·ª±c thi = 700 / (400 * 10^6) gi√¢y. MIPS = (T·ªïng s·ªë l·ªánh / Th·ªùi gian th·ª±c thi) / 10^6 = (500 / (700 / (400*10^6))) / 10^6 = (500 * 400) / 700 = 200000 / 700 ‚âà 285.7"
        }
    },
    {
        "id": 28,
        "en": {
            "question": "According to Amdahl's law for multiprocessors, if only 20% of the code is inherently serial (f = 0.8), running the program on a multicore system with 8 processors, the performance increase (speedup factor) will be ___.",
            "options": [
                "A. 333%",
                "B. 303%",
                "C. 313%",
                "D. 323%"
            ],
            "answer": "A. 333%",
            "explanation": "Speedup = 1 / ((1 - f) + (f / N)) = 1 / ((1 - 0.8) + (0.8 / 8)) = 1 / (0.2 + 0.1) = 1 / 0.3 ‚âà 3.33. This represents a 333% increase."
        },
        "vi": {
            "question": "Theo ƒë·ªãnh lu·∫≠t Amdahl cho c√°c b·ªô ƒëa x·ª≠ l√Ω, n·∫øu ch·ªâ c√≥ 20% m√£ l√† n·ªëi ti·∫øp v·ªën c√≥ (f = 0.8), ch·∫°y ch∆∞∆°ng tr√¨nh tr√™n m·ªôt h·ªá th·ªëng ƒëa l√µi v·ªõi 8 b·ªô x·ª≠ l√Ω, m·ª©c tƒÉng hi·ªáu su·∫•t (h·ªá s·ªë tƒÉng t·ªëc) s·∫Ω l√† ___.",
            "options": [
                "A. 333%",
                "B. 303%",
                "C. 313%",
                "D. 323%"
            ],
            "answer": "A. 333%",
            "explanation": "TƒÉng t·ªëc = 1 / ((1 - f) + (f / N)) = 1 / ((1 - 0.8) + (0.8 / 8)) = 1 / (0.2 + 0.1) = 1 / 0.3 ‚âà 3.33. T·ª©c l√† tƒÉng kho·∫£ng 333%."
        }
    },
    {
        "id": 29,
        "en": {
            "question": "According to Amdahl's law for multiprocessors, if only 10% of the code is inherently serial (f = 0.9), running the program on a multicore system with 4 processors, the performance increase (speedup factor) will be ___.",
            "options": [
                "A. 307%",
                "B. 297%",
                "C. 317%",
                "D. 327%"
            ],
            "answer": "A. 307%",
            "explanation": "Speedup = 1 / ((1 - f) + (f / N)) = 1 / ((1 - 0.9) + (0.9 / 4)) = 1 / (0.1 + 0.225) = 1 / 0.325 ‚âà 3.07. This represents a 307% increase."
        },
        "vi": {
            "question": "Theo ƒë·ªãnh lu·∫≠t Amdahl cho c√°c b·ªô ƒëa x·ª≠ l√Ω, n·∫øu ch·ªâ 10% m√£ l√† n·ªëi ti·∫øp v·ªën c√≥ (f = 0.9), ch·∫°y ch∆∞∆°ng tr√¨nh tr√™n h·ªá th·ªëng ƒëa l√µi v·ªõi 4 b·ªô x·ª≠ l√Ω, m·ª©c tƒÉng hi·ªáu su·∫•t (h·ªá s·ªë tƒÉng t·ªëc) s·∫Ω l√† ___.",
            "options": [
                "A. 307%",
                "B. 297%",
                "C. 317%",
                "D. 327%"
            ],
            "answer": "A. 307%",
            "explanation": "TƒÉng t·ªëc = 1 / ((1 - f) + (f / N)) = 1 / ((1 - 0.9) + (0.9 / 4)) = 1 / (0.1 + 0.225) = 1 / 0.325 ‚âà 3.07. T·ª©c l√† tƒÉng kho·∫£ng 307%."
        }
    },
    {
        "id": 30,
        "en": {
            "question": "What is the primary benefit of using an ARM processor over other processors?",
            "options": [
                "A. Low cost and low power consumption.",
                "B. Higher level of multitasking.",
                "C. Fewer errors or glitches.",
                "D. Efficient memory management."
            ],
            "answer": "A. Low cost and low power consumption.",
            "explanation": "ARM's RISC architecture is designed for efficiency, making it ideal for mobile and embedded devices where battery life and cost are critical."
        },
        "vi": {
            "question": "L·ª£i √≠ch ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng b·ªô x·ª≠ l√Ω ARM so v·ªõi c√°c b·ªô x·ª≠ l√Ω kh√°c l√† g√¨?",
            "options": [
                "A. Chi ph√≠ th·∫•p v√† ti√™u th·ª• ƒëi·ªán nƒÉng th·∫•p.",
                "B. M·ª©c ƒë·ªô ƒëa nhi·ªám cao h∆°n.",
                "C. √çt l·ªói ho·∫∑c tr·ª•c tr·∫∑c h∆°n.",
                "D. Qu·∫£n l√Ω b·ªô nh·ªõ hi·ªáu qu·∫£."
            ],
            "answer": "A. Chi ph√≠ th·∫•p v√† ti√™u th·ª• ƒëi·ªán nƒÉng th·∫•p.",
            "explanation": "Ki·∫øn tr√∫c RISC c·ªßa ARM ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ mang l·∫°i hi·ªáu qu·∫£, l√†m cho n√≥ tr·ªü n√™n l√Ω t∆∞·ªüng cho c√°c thi·∫øt b·ªã di ƒë·ªông v√† nh√∫ng, n∆°i tu·ªïi th·ªç pin v√† chi ph√≠ l√† r·∫•t quan tr·ªçng."
        }
    },
    {
        "id": 31,
        "en": {
            "question": "The ____ was the world's first general-purpose electronic digital computer.",
            "options": [
                "A. UNIVAC",
                "B. MARK IV",
                "C. ENIAC",
                "D. Hollerith's Counting Machine"
            ],
            "answer": "C. ENIAC",
            "explanation": "The ENIAC (Electronic Numerical Integrator And Computer), completed in 1945, is considered the first large-scale, general-purpose electronic digital computer."
        },
        "vi": {
            "question": "____ l√† m√°y t√≠nh ƒëi·ªán t·ª≠ k·ªπ thu·∫≠t s·ªë ƒëa nƒÉng ƒë·∫ßu ti√™n tr√™n th·∫ø gi·ªõi.",
            "options": [
                "A. UNIVAC",
                "B. MARK IV",
                "C. ENIAC",
                "D. Hollerith's Counting Machine"
            ],
            "answer": "C. ENIAC",
            "explanation": "ENIAC (Electronic Numerical Integrator And Computer), ho√†n th√†nh nƒÉm 1945, ƒë∆∞·ª£c coi l√† m√°y t√≠nh ƒëi·ªán t·ª≠ k·ªπ thu·∫≠t s·ªë ƒëa nƒÉng quy m√¥ l·ªõn ƒë·∫ßu ti√™n."
        }
    },
    {
        "id": 32,
        "en": {
            "question": "The ____ project was a response to U.S. needs during ____.",
            "options": [
                "A. Civil War",
                "B. French-American War",
                "C. World War I",
                "D. World War II"
            ],
            "answer": "D. World War II",
            "explanation": "This refers to the ENIAC project, which was funded by the US Army during World War II to calculate artillery firing tables."
        },
        "vi": {
            "question": "D·ª± √°n ____ l√† m·ªôt ph·∫£n ·ª©ng ƒë·ªëi v·ªõi nhu c·∫ßu c·ªßa Hoa K·ª≥ trong ____.",
            "options": [
                "A. N·ªôi chi·∫øn",
                "B. Chi·∫øn tranh Ph√°p-M·ªπ",
                "C. Th·∫ø chi·∫øn I",
                "D. Th·∫ø chi·∫øn II"
            ],
            "answer": "D. Th·∫ø chi·∫øn II",
            "explanation": "C√¢u n√†y √°m ch·ªâ ƒë·∫øn d·ª± √°n ENIAC, ƒë∆∞·ª£c Qu√¢n ƒë·ªôi Hoa K·ª≥ t√†i tr·ª£ trong Th·∫ø chi·∫øn II ƒë·ªÉ t√≠nh to√°n c√°c b·∫£ng b·∫Øn ph√°o."
        }
    },
    {
        "id": 33,
        "en": {
            "question": "The ENIAC is an example of a ____ generation computer.",
            "options": [
                "A. first",
                "B. second",
                "C. third",
                "D. fourth"
            ],
            "answer": "A. first",
            "explanation": "First-generation computers were characterized by their use of vacuum tubes, and ENIAC was a prime example."
        },
        "vi": {
            "question": "ENIAC l√† m·ªôt v√≠ d·ª• c·ªßa m√°y t√≠nh th·∫ø h·ªá ____.",
            "options": [
                "A. th·ª© nh·∫•t",
                "B. th·ª© hai",
                "C. th·ª© ba",
                "D. th·ª© t∆∞"
            ],
            "answer": "A. th·ª© nh·∫•t",
            "explanation": "M√°y t√≠nh th·∫ø h·ªá th·ª© nh·∫•t ƒë∆∞·ª£c ƒë·∫∑c tr∆∞ng b·ªüi vi·ªác s·ª≠ d·ª•ng ƒë√®n ch√¢n kh√¥ng, v√† ENIAC l√† m·ªôt v√≠ d·ª• ƒëi·ªÉn h√¨nh."
        }
    },
    {
        "id": 34,
        "en": {
            "question": "____ defines the third generation of computers.",
            "options": [
                "A. integrated circuits",
                "B. transistors",
                "C. vacuum tubes",
                "D. large-scale integration"
            ],
            "answer": "A. integrated circuits",
            "explanation": "The invention of the integrated circuit (IC) allowed for smaller, faster, and more reliable computers, defining the third generation."
        },
        "vi": {
            "question": "____ x√°c ƒë·ªãnh th·∫ø h·ªá m√°y t√≠nh th·ª© ba.",
            "options": [
                "A. m·∫°ch t√≠ch h·ª£p",
                "B. b√≥ng b√°n d·∫´n",
                "C. ƒë√®n ch√¢n kh√¥ng",
                "D. t√≠ch h·ª£p quy m√¥ l·ªõn"
            ],
            "answer": "A. m·∫°ch t√≠ch h·ª£p",
            "explanation": "S·ª± ph√°t minh ra m·∫°ch t√≠ch h·ª£p (IC) cho ph√©p m√°y t√≠nh nh·ªè h∆°n, nhanh h∆°n v√† ƒë√°ng tin c·∫≠y h∆°n, ƒë·ªãnh h√¨nh n√™n th·∫ø h·ªá th·ª© ba."
        }
    },
    {
        "id": 35,
        "en": {
            "question": "The use of multiple processors on the same chip is referred to as ____ and provides the potential to increase performance without increasing the clock rate.",
            "options": [
                "A. multicore",
                "B. GPU",
                "C. data channel",
                "D. MPC"
            ],
            "answer": "A. multicore",
            "explanation": "Multicore architecture places multiple processing cores on a single die to improve performance through parallel processing rather than by simply increasing clock speed."
        },
        "vi": {
            "question": "Vi·ªác s·ª≠ d·ª•ng nhi·ªÅu b·ªô x·ª≠ l√Ω tr√™n c√πng m·ªôt chip ƒë∆∞·ª£c g·ªçi l√† ____ v√† cung c·∫•p ti·ªÅm nƒÉng tƒÉng hi·ªáu su·∫•t m√† kh√¥ng l√†m tƒÉng t·ªëc ƒë·ªô xung nh·ªãp.",
            "options": [
                "A. ƒëa l√µi (multicore)",
                "B. GPU",
                "C. k√™nh d·ªØ li·ªáu",
                "D. MPC"
            ],
            "answer": "A. ƒëa l√µi (multicore)",
            "explanation": "Ki·∫øn tr√∫c ƒëa l√µi ƒë·∫∑t nhi·ªÅu l√µi x·ª≠ l√Ω tr√™n m·ªôt ƒë·∫ø duy nh·∫•t ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t th√¥ng qua x·ª≠ l√Ω song song thay v√¨ ch·ªâ ƒë∆°n gi·∫£n l√† tƒÉng t·ªëc ƒë·ªô xung nh·ªãp."
        }
    },
    {
        "id": 36,
        "en": {
            "question": "Which of the following components was used in the first ENIAC computer?",
            "options": [
                "A. Bipolar transistors",
                "B. Field transistors",
                "C. Vacuum tubes",
                "D. Semiconductor ICs"
            ],
            "answer": "C. Vacuum tubes",
            "explanation": "The ENIAC was a first-generation computer and relied on thousands of vacuum tubes for its logic and computation."
        },
        "vi": {
            "question": "Th√†nh ph·∫ßn n√†o sau ƒë√¢y ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong m√°y t√≠nh ENIAC ƒë·∫ßu ti√™n?",
            "options": [
                "A. B√≥ng b√°n d·∫´n l∆∞·ª°ng c·ª±c (Bipolar transistors)",
                "B. B√≥ng b√°n d·∫´n hi·ªáu ·ª©ng tr∆∞·ªùng (Field transistors)",
                "C. ƒê√®n ch√¢n kh√¥ng (Vacuum tubes)",
                "D. M·∫°ch t√≠ch h·ª£p b√°n d·∫´n (Semiconductor ICs)"
            ],
            "answer": "C. ƒê√®n ch√¢n kh√¥ng (Vacuum tubes)",
            "explanation": "ENIAC l√† m·ªôt m√°y t√≠nh th·∫ø h·ªá ƒë·∫ßu ti√™n v√† ph·ª• thu·ªôc v√†o h√†ng ng√†n ƒë√®n ch√¢n kh√¥ng cho logic v√† t√≠nh to√°n c·ªßa n√≥."
        }
    },
    {
        "id": 37,
        "en": {
            "question": "In the evolution of the I/O function, what was the first step?",
            "options": [
                "A. The I/O module is enhanced to become a processor in its own right.",
                "B. A controller or I/O module is added, and programmed I/O without interrupts is used.",
                "C. The CPU directly controls a peripheral device.",
                "D. The I/O module is granted direct access to memory via DMA."
            ],
            "answer": "C. The CPU directly controls a peripheral device.",
            "explanation": "The earliest and simplest form of I/O involved the CPU having direct control over the peripheral, managing all aspects of the transfer."
        },
        "vi": {
            "question": "B∆∞·ªõc ti·∫øn h√≥a ƒë·∫ßu ti√™n trong s·ª± ph√°t tri·ªÉn c·ªßa ch·ª©c nƒÉng I/O l√† g√¨?",
            "options": [
                "A. M√¥-ƒëun I/O ƒë∆∞·ª£c tƒÉng c∆∞·ªùng ƒë·ªÉ tr·ªü th√†nh m·ªôt b·ªô x·ª≠ l√Ω theo ƒë√∫ng nghƒ©a c·ªßa n√≥.",
                "B. M·ªôt b·ªô ƒëi·ªÅu khi·ªÉn ho·∫∑c m√¥-ƒëun I/O ƒë∆∞·ª£c th√™m v√†o, v√† I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh m√† kh√¥ng c√≥ ng·∫Øt ƒë∆∞·ª£c s·ª≠ d·ª•ng.",
                "C. CPU ƒëi·ªÅu khi·ªÉn tr·ª±c ti·∫øp m·ªôt thi·∫øt b·ªã ngo·∫°i vi.",
                "D. M√¥-ƒëun I/O ƒë∆∞·ª£c c·∫•p quy·ªÅn truy c·∫≠p tr·ª±c ti·∫øp v√†o b·ªô nh·ªõ th√¥ng qua DMA."
            ],
            "answer": "C. CPU ƒëi·ªÅu khi·ªÉn tr·ª±c ti·∫øp m·ªôt thi·∫øt b·ªã ngo·∫°i vi.",
            "explanation": "D·∫°ng I/O s·ªõm nh·∫•t v√† ƒë∆°n gi·∫£n nh·∫•t li√™n quan ƒë·∫øn vi·ªác CPU c√≥ quy·ªÅn ki·ªÉm so√°t tr·ª±c ti·∫øp thi·∫øt b·ªã ngo·∫°i vi, qu·∫£n l√Ω t·∫•t c·∫£ c√°c kh√≠a c·∫°nh c·ªßa vi·ªác truy·ªÅn d·ªØ li·ªáu."
        }
    },
    {
        "id": 38,
        "en": {
            "question": "Which computer in the following PDP series was known for its use of 12-bit instructions and a single general-purpose register, the accumulator?",
            "options": [
                "A. PDP-8",
                "B. PDP-10",
                "C. PDP-11",
                "D. PDP-6"
            ],
            "answer": "A. PDP-8",
            "explanation": "The PDP-8 was a highly influential 12-bit minicomputer, and its architecture was centered around the accumulator."
        },
        "vi": {
            "question": "M√°y t√≠nh n√†o trong s√™-ri PDP sau ƒë√¢y ƒë∆∞·ª£c bi·∫øt ƒë·∫øn v·ªõi vi·ªác s·ª≠ d·ª•ng c√°c l·ªánh 12-bit v√† m·ªôt thanh ghi ƒëa nƒÉng duy nh·∫•t, b·ªô t√≠ch l≈©y (accumulator)?",
            "options": [
                "A. PDP-8",
                "B. PDP-10",
                "C. PDP-11",
                "D. PDP-6"
            ],
            "answer": "A. PDP-8",
            "explanation": "PDP-8 l√† m·ªôt m√°y t√≠nh mini 12-bit c√≥ ·∫£nh h∆∞·ªüng l·ªõn, v√† ki·∫øn tr√∫c c·ªßa n√≥ t·∫≠p trung xung quanh b·ªô t√≠ch l≈©y."
        }
    },
    {
        "id": 39,
        "en": {
            "question": "During the development of computers, which of the following statements is false?",
            "options": [
                "A. The second generation used transistors.",
                "B. The first generation used vacuum tubes.",
                "C. The fourth generation used integrated circuits.",
                "D. The third generation used transistors."
            ],
            "answer": "D. The third generation used transistors.",
            "explanation": "The third generation is defined by the use of Integrated Circuits (ICs). The second generation used transistors."
        },
        "vi": {
            "question": "Trong qu√° tr√¨nh ph√°t tri·ªÉn c·ªßa m√°y t√≠nh, ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† sai?",
            "options": [
                "A. Th·∫ø h·ªá th·ª© hai s·ª≠ d·ª•ng b√≥ng b√°n d·∫´n.",
                "B. Th·∫ø h·ªá th·ª© nh·∫•t s·ª≠ d·ª•ng ƒë√®n ch√¢n kh√¥ng.",
                "C. Th·∫ø h·ªá th·ª© t∆∞ s·ª≠ d·ª•ng m·∫°ch t√≠ch h·ª£p.",
                "D. Th·∫ø h·ªá th·ª© ba s·ª≠ d·ª•ng b√≥ng b√°n d·∫´n."
            ],
            "answer": "D. Th·∫ø h·ªá th·ª© ba s·ª≠ d·ª•ng b√≥ng b√°n d·∫´n.",
            "explanation": "Th·∫ø h·ªá th·ª© ba ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi vi·ªác s·ª≠ d·ª•ng M·∫°ch t√≠ch h·ª£p (IC). Th·∫ø h·ªá th·ª© hai s·ª≠ d·ª•ng b√≥ng b√°n d·∫´n."
        }
    },
    {
        "id": 40,
        "en": {
            "question": "The design principle of ____ was used in the design of the PDP-10 instruction set.",
            "options": [
                "A. Orthogonality",
                "B. Completeness",
                "C. Direct addressing",
                "D. All of the above"
            ],
            "answer": "D. All of the above",
            "explanation": "The PDP-10 was known for its highly regular and orthogonal instruction set, where operations could be combined with various addressing modes in a consistent manner."
        },
        "vi": {
            "question": "Nguy√™n t·∫Øc thi·∫øt k·∫ø ____ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong vi·ªác thi·∫øt k·∫ø t·∫≠p l·ªánh PDP-10.",
            "options": [
                "A. Orthogonality (Tr·ª±c giao)",
                "B. Completeness (ƒê·∫ßy ƒë·ªß)",
                "C. Direct addressing (ƒê·ªãa ch·ªâ h√≥a tr·ª±c ti·∫øp)",
                "D. All of the above (T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n)"
            ],
            "answer": "D. All of the above (T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n)",
            "explanation": "PDP-10 n·ªïi ti·∫øng v·ªõi t·∫≠p l·ªánh r·∫•t ƒë·ªÅu ƒë·∫∑n v√† tr·ª±c giao, trong ƒë√≥ c√°c ho·∫°t ƒë·ªông c√≥ th·ªÉ ƒë∆∞·ª£c k·∫øt h·ª£p v·ªõi c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a kh√°c nhau m·ªôt c√°ch nh·∫•t qu√°n."
        }
    },
    {
        "id": 41,
        "en": {
            "question": "The ____ was designed to provide a powerful and flexible instruction set within the constraints of a 16-bit minicomputer.",
            "options": [
                "A. PDP-1",
                "B. PDP-8",
                "C. PDP-11",
                "D. PDP-10"
            ],
            "answer": "C. PDP-11",
            "explanation": "The PDP-11 was a highly successful 16-bit minicomputer known for its rich and orthogonal instruction set, which influenced many later architectures."
        },
        "vi": {
            "question": "____ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ cung c·∫•p m·ªôt t·∫≠p l·ªánh m·∫°nh m·∫Ω v√† linh ho·∫°t trong c√°c r√†ng bu·ªôc c·ªßa m·ªôt m√°y t√≠nh mini 16-bit.",
            "options": [
                "A. PDP-1",
                "B. PDP-8",
                "C. PDP-11",
                "D. PDP-10"
            ],
            "answer": "C. PDP-11",
            "explanation": "PDP-11 l√† m·ªôt m√°y t√≠nh mini 16-bit r·∫•t th√†nh c√¥ng, n·ªïi ti·∫øng v·ªõi t·∫≠p l·ªánh phong ph√∫ v√† tr·ª±c giao, ƒë√£ ·∫£nh h∆∞·ªüng ƒë·∫øn nhi·ªÅu ki·∫øn tr√∫c sau n√†y."
        }
    },
    {
        "id": 42,
        "en": {
            "question": "Computer technology is changing at a(n) ____ pace.",
            "options": [
                "A. slow",
                "B. slow to medium",
                "C. fast",
                "D. non-existent"
            ],
            "answer": "C. fast",
            "explanation": "The pace of change in computer technology, often described by Moore's Law, has been exceptionally rapid for several decades."
        },
        "vi": {
            "question": "C√¥ng ngh·ªá m√°y t√≠nh ƒëang thay ƒë·ªïi v·ªõi m·ªôt t·ªëc ƒë·ªô ____.",
            "options": [
                "A. ch·∫≠m",
                "B. ch·∫≠m ƒë·∫øn trung b√¨nh",
                "C. nhanh",
                "D. kh√¥ng t·ªìn t·∫°i"
            ],
            "answer": "C. nhanh",
            "explanation": "T·ªëc ƒë·ªô thay ƒë·ªïi trong c√¥ng ngh·ªá m√°y t√≠nh, th∆∞·ªùng ƒë∆∞·ª£c m√¥ t·∫£ b·ªüi ƒê·ªãnh lu·∫≠t Moore, ƒë√£ ƒë·∫∑c bi·ªát nhanh trong nhi·ªÅu th·∫≠p k·ª∑."
        }
    },
    {
        "id": 43,
        "en": {
            "question": "Which of the following is NOT an accurate trend in contemporary processor designs?",
            "options": [
                "A. The number of accepted processes is infinite.",
                "B. The number of integrated transistors is increasing and larger.",
                "C. Higher clock frequencies are being applied.",
                "D. More cores are integrated in one chip."
            ],
            "answer": "A. The number of accepted processes is infinite.",
            "explanation": "While systems handle many processes, the number is finite and limited by memory and other resources. Options B, C, and D are all key trends in processor design."
        },
        "vi": {
            "question": "Ch·ªçn m·ªôt xu h∆∞·ªõng KH√îNG CH√çNH X√ÅC trong c√°c thi·∫øt k·∫ø b·ªô x·ª≠ l√Ω ƒë∆∞∆°ng ƒë·∫°i.",
            "options": [
                "A. S·ªë l∆∞·ª£ng quy tr√¨nh ƒë∆∞·ª£c ch·∫•p nh·∫≠n l√† v√¥ h·∫°n.",
                "B. S·ªë l∆∞·ª£ng b√≥ng b√°n d·∫´n t√≠ch h·ª£p ng√†y c√†ng tƒÉng v√† l·ªõn h∆°n.",
                "C. T·∫ßn s·ªë xung nh·ªãp cao h∆°n ƒë∆∞·ª£c √°p d·ª•ng.",
                "D. Nhi·ªÅu l√µi h∆°n ƒë∆∞·ª£c t√≠ch h·ª£p trong m·ªôt chip."
            ],
            "answer": "A. S·ªë l∆∞·ª£ng quy tr√¨nh ƒë∆∞·ª£c ch·∫•p nh·∫≠n l√† v√¥ h·∫°n.",
            "explanation": "M·∫∑c d√π h·ªá th·ªëng x·ª≠ l√Ω nhi·ªÅu ti·∫øn tr√¨nh, con s·ªë n√†y l√† h·ªØu h·∫°n v√† b·ªã gi·ªõi h·∫°n b·ªüi b·ªô nh·ªõ v√† c√°c t√†i nguy√™n kh√°c. C√°c l·ª±a ch·ªçn B, C, v√† D ƒë·ªÅu l√† nh·ªØng xu h∆∞·ªõng ch√≠nh trong thi·∫øt k·∫ø b·ªô x·ª≠ l√Ω."
        }
    },
    {
        "id": 44,
        "en": {
            "question": "A 17th-century computer that could perform addition and subtraction was the ____.",
            "options": [
                "A. Analytical Engine",
                "B. Pascaline",
                "C. Babbage machine",
                "D. Jacquard loom"
            ],
            "answer": "B. Pascaline",
            "explanation": "Invented by Blaise Pascal in the 1640s, the Pascaline was a mechanical calculator capable of addition and subtraction."
        },
        "vi": {
            "question": "M·ªôt m√°y t√≠nh th·∫ø k·ª∑ 17 c√≥ th·ªÉ th·ª±c hi·ªán ph√©p c·ªông v√† tr·ª´ l√† ____.",
            "options": [
                "A. M√°y ph√¢n t√≠ch (Analytical Engine)",
                "B. Pascaline",
                "C. M√°y Babbage (Babbage machine)",
                "D. M√°y d·ªát Jacquard (Jacquard loom)"
            ],
            "answer": "B. Pascaline",
            "explanation": "ƒê∆∞·ª£c ph√°t minh b·ªüi Blaise Pascal v√†o nh·ªØng nƒÉm 1640, Pascaline l√† m·ªôt m√°y t√≠nh c∆° h·ªçc c√≥ kh·∫£ nƒÉng th·ª±c hi·ªán ph√©p c·ªông v√† tr·ª´."
        }
    },
    {
        "id": 45,
        "en": {
            "question": "A 32-bit code called ____ represents symbols in all languages.",
            "options": [
                "A. Extended ASCII",
                "B. ANSI",
                "C. Unicode",
                "D. EBCDIC"
            ],
            "answer": "C. Unicode",
            "explanation": "Unicode is the modern standard for encoding characters from virtually all writing systems. UTF-32 is a 32-bit encoding of Unicode."
        },
        "vi": {
            "question": "M·ªôt m√£ 32-bit ƒë∆∞·ª£c g·ªçi l√† ____ ƒë·∫°i di·ªán cho c√°c k√Ω hi·ªáu trong t·∫•t c·∫£ c√°c ng√¥n ng·ªØ.",
            "options": [
                "A. Extended ASCII",
                "B. ANSI",
                "C. Unicode",
                "D. EBCDIC"
            ],
            "answer": "C. Unicode",
            "explanation": "Unicode l√† ti√™u chu·∫©n hi·ªán ƒë·∫°i ƒë·ªÉ m√£ h√≥a c√°c k√Ω t·ª± t·ª´ h·∫ßu h·∫øt t·∫•t c·∫£ c√°c h·ªá th·ªëng ch·ªØ vi·∫øt. UTF-32 l√† m·ªôt d·∫°ng m√£ h√≥a 32-bit c·ªßa Unicode."
        }
    },
    {
        "id": 46,
        "en": {
            "question": "Almost all contemporary computer designs are based on concepts developed by ____ at the Institute for Advanced Study, Princeton.",
            "options": [
                "A. John Mauchly",
                "B. John von Neumann",
                "C. Herman Hollerith",
                "D. John Eckert"
            ],
            "answer": "B. John von Neumann",
            "explanation": "John von Neumann's work on the stored-program concept and the architecture of the IAS computer laid the foundation for virtually all modern computers."
        },
        "vi": {
            "question": "H·∫ßu nh∆∞ t·∫•t c·∫£ c√°c thi·∫øt k·∫ø m√°y t√≠nh ƒë∆∞∆°ng ƒë·∫°i ƒë·ªÅu d·ª±a tr√™n c√°c kh√°i ni·ªám ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi ____ t·∫°i Vi·ªán Nghi√™n c·ª©u Cao c·∫•p, Princeton.",
            "options": [
                "A. John Mauchly",
                "B. John von Neumann",
                "C. Herman Hollerith",
                "D. John Eckert"
            ],
            "answer": "B. John von Neumann",
            "explanation": "C√¥ng tr√¨nh c·ªßa John von Neumann v·ªÅ kh√°i ni·ªám ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ v√† ki·∫øn tr√∫c c·ªßa m√°y t√≠nh IAS ƒë√£ ƒë·∫∑t n·ªÅn m√≥ng cho h·∫ßu h·∫øt t·∫•t c·∫£ c√°c m√°y t√≠nh hi·ªán ƒë·∫°i."
        }
    },
    {
        "id": 47,
        "en": {
            "question": "Which type of processors often provides better performance for parallel processing?",
            "options": [
                "A. Single-core processors",
                "B. Multi-core processors",
                "C. Microelectronics",
                "D. Digital signal processors (DSPs)"
            ],
            "answer": "B. Multi-core processors",
            "explanation": "Multi-core processors can execute multiple tasks or threads simultaneously, making them inherently better for parallel processing."
        },
        "vi": {
            "question": "Lo·∫°i b·ªô x·ª≠ l√Ω n√†o sau ƒë√¢y th∆∞·ªùng cung c·∫•p hi·ªáu su·∫•t t·ªët h∆°n cho x·ª≠ l√Ω song song?",
            "options": [
                "A. B·ªô x·ª≠ l√Ω l√µi ƒë∆°n (Single-core processors)",
                "B. B·ªô x·ª≠ l√Ω ƒëa l√µi (Multi-core processors)",
                "C. Vi ƒëi·ªán t·ª≠ (Microelectronics)",
                "D. B·ªô x·ª≠ l√Ω t√≠n hi·ªáu s·ªë (DSPs)"
            ],
            "answer": "B. B·ªô x·ª≠ l√Ω ƒëa l√µi (Multi-core processors)",
            "explanation": "B·ªô x·ª≠ l√Ω ƒëa l√µi c√≥ th·ªÉ th·ª±c thi nhi·ªÅu t√°c v·ª• ho·∫∑c lu·ªìng ƒë·ªìng th·ªùi, l√†m cho ch√∫ng v·ªën ƒë√£ t·ªët h∆°n cho vi·ªác x·ª≠ l√Ω song song."
        }
    },
    {
        "id": 48,
        "en": {
            "question": "The potential performance benefit of a multicore organization depends on the ability to effectively exploit the available parallel resources for the application.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Simply having multiple cores is not enough; the software (application and operating system) must be designed to split its work into parallel tasks to see a performance benefit."
        },
        "vi": {
            "question": "L·ª£i √≠ch hi·ªáu su·∫•t ti·ªÅm nƒÉng c·ªßa m·ªôt t·ªï ch·ª©c ƒëa l√µi ph·ª• thu·ªôc v√†o kh·∫£ nƒÉng khai th√°c hi·ªáu qu·∫£ c√°c t√†i nguy√™n song song c√≥ s·∫µn cho ·ª©ng d·ª•ng.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Ch·ªâ c√≥ nhi·ªÅu l√µi th√¥i l√† ch∆∞a ƒë·ªß; ph·∫ßn m·ªÅm (·ª©ng d·ª•ng v√† h·ªá ƒëi·ªÅu h√†nh) ph·∫£i ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ chia c√¥ng vi·ªác c·ªßa n√≥ th√†nh c√°c t√°c v·ª• song song m·ªõi c√≥ th·ªÉ th·∫•y ƒë∆∞·ª£c l·ª£i √≠ch v·ªÅ hi·ªáu su·∫•t."
        }
    },
    {
        "id": 49,
        "en": {
            "question": "The processors are called ____.",
            "options": [
                "A. cores",
                "B. interconnects",
                "C. dies",
                "D. QPI"
            ],
            "answer": "A. cores",
            "explanation": "In the context of a multicore chip, the individual processing units are referred to as cores."
        },
        "vi": {
            "question": "C√°c b·ªô x·ª≠ l√Ω ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. l√µi (cores)",
                "B. k·∫øt n·ªëi (interconnects)",
                "C. ƒë·∫ø (dies)",
                "D. QPI"
            ],
            "answer": "A. l√µi (cores)",
            "explanation": "Trong b·ªëi c·∫£nh c·ªßa m·ªôt chip ƒëa l√µi, c√°c ƒë∆°n v·ªã x·ª≠ l√Ω ri√™ng l·∫ª ƒë∆∞·ª£c g·ªçi l√† c√°c l√µi."
        }
    },
    {
        "id": 50,
        "en": {
            "question": "Which of these are single-user systems that are highly sophisticated and provide high processing speeds?",
            "options": [
                "A. Supercomputers",
                "B. Mainframes",
                "C. Workstations",
                "D. Minicomputers"
            ],
            "answer": "C. Workstations",
            "explanation": "Workstations are powerful single-user computers designed for technical or scientific applications. Supercomputers and mainframes are multi-user systems."
        },
        "vi": {
            "question": "C√°i n√†o trong s·ªë n√†y l√† h·ªá th·ªëng m·ªôt ng∆∞·ªùi d√πng r·∫•t tinh vi v√† cung c·∫•p t·ªëc ƒë·ªô x·ª≠ l√Ω cao?",
            "options": [
                "A. Si√™u m√°y t√≠nh",
                "B. M√°y t√≠nh l·ªõn (Mainframes)",
                "C. M√°y tr·∫°m (Workstations)",
                "D. M√°y t√≠nh mini (Minicomputers)"
            ],
            "answer": "C. M√°y tr·∫°m (Workstations)",
            "explanation": "M√°y tr·∫°m l√† nh·ªØng m√°y t√≠nh m·ªôt ng∆∞·ªùi d√πng m·∫°nh m·∫Ω ƒë∆∞·ª£c thi·∫øt k·∫ø cho c√°c ·ª©ng d·ª•ng k·ªπ thu·∫≠t ho·∫∑c khoa h·ªçc. Si√™u m√°y t√≠nh v√† m√°y t√≠nh l·ªõn l√† h·ªá th·ªëng ƒëa ng∆∞·ªùi d√πng."
        }
    },
    {
        "id": 51,
        "en": {
            "question": "The time for which a piece of data is valid or useful is called ____.",
            "options": [
                "A. Precision",
                "B. Data integrity",
                "C. Timeliness",
                "D. Relevance"
            ],
            "answer": "C. Timeliness",
            "explanation": "Timeliness refers to data being available in time to be useful."
        },
        "vi": {
            "question": "Th·ªùi gian m√† m·ªôt m·∫©u d·ªØ li·ªáu c√≥ gi√° tr·ªã ho·∫∑c h·ªØu √≠ch ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. ƒê·ªô ch√≠nh x√°c (Precision)",
                "B. T√≠nh to√†n v·∫πn d·ªØ li·ªáu (Data integrity)",
                "C. T√≠nh k·ªãp th·ªùi (Timeliness)",
                "D. T√≠nh li√™n quan (Relevance)"
            ],
            "answer": "C. T√≠nh k·ªãp th·ªùi (Timeliness)",
            "explanation": "T√≠nh k·ªãp th·ªùi ƒë·ªÅ c·∫≠p ƒë·∫øn vi·ªác d·ªØ li·ªáu c√≥ s·∫µn k·ªãp th·ªùi ƒë·ªÉ tr·ªü n√™n h·ªØu √≠ch."
        }
    },
    {
        "id": 52,
        "en": {
            "question": "The third generation of computers used ____.",
            "options": [
                "A. ICs",
                "B. Vacuum tubes",
                "C. Transistors",
                "D. VLSI"
            ],
            "answer": "A. ICs",
            "explanation": "The third generation (mid-1960s to early 1970s) was defined by the use of Integrated Circuits (ICs)."
        },
        "vi": {
            "question": "Th·∫ø h·ªá m√°y t√≠nh th·ª© ba ƒë√£ s·ª≠ d·ª•ng ____.",
            "options": [
                "A. IC (M·∫°ch t√≠ch h·ª£p)",
                "B. ƒê√®n ch√¢n kh√¥ng (Vacuum tubes)",
                "C. B√≥ng b√°n d·∫´n (Transistors)",
                "D. VLSI"
            ],
            "answer": "A. IC (M·∫°ch t√≠ch h·ª£p)",
            "explanation": "Th·∫ø h·ªá th·ª© ba (gi·ªØa nh·ªØng nƒÉm 1960 ƒë·∫øn ƒë·∫ßu nh·ªØng nƒÉm 1970) ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a b·ªüi vi·ªác s·ª≠ d·ª•ng M·∫°ch t√≠ch h·ª£p (ICs)."
        }
    },
    {
        "id": 53,
        "en": {
            "question": "The third generation of computers were introduced in the year ____.",
            "options": [
                "A. 1945",
                "B. 1956",
                "C. 1965",
                "D. 1972"
            ],
            "answer": "C. 1965",
            "explanation": "The third generation is generally considered to have started around the mid-1960s, with the introduction of systems like the IBM System/360."
        },
        "vi": {
            "question": "Th·∫ø h·ªá m√°y t√≠nh th·ª© ba ƒë∆∞·ª£c gi·ªõi thi·ªáu v√†o nƒÉm ____.",
            "options": [
                "A. 1945",
                "B. 1956",
                "C. 1965",
                "D. 1972"
            ],
            "answer": "C. 1965",
            "explanation": "Th·∫ø h·ªá th·ª© ba th∆∞·ªùng ƒë∆∞·ª£c coi l√† b·∫Øt ƒë·∫ßu v√†o kho·∫£ng gi·ªØa nh·ªØng nƒÉm 1960, v·ªõi s·ª± ra ƒë·ªùi c·ªßa c√°c h·ªá th·ªëng nh∆∞ IBM System/360."
        }
    },
    {
        "id": 54,
        "en": {
            "question": "The first computer to use a stored program was ____.",
            "options": [
                "A. ENIAC",
                "B. EDVAC",
                "C. EDSAC",
                "D. IAS"
            ],
            "answer": "C. EDSAC",
            "explanation": "While EDVAC was designed with the stored program concept, the EDSAC (Electronic Delay Storage Automatic Calculator), which ran its first program in 1949, was the first operational stored-program computer."
        },
        "vi": {
            "question": "M√°y t√≠nh ƒë·∫ßu ti√™n s·ª≠ d·ª•ng ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ l√† ____.",
            "options": [
                "A. ENIAC",
                "B. EDVAC",
                "C. EDSAC",
                "D. IAS"
            ],
            "answer": "C. EDSAC",
            "explanation": "M·∫∑c d√π EDVAC ƒë∆∞·ª£c thi·∫øt k·∫ø v·ªõi kh√°i ni·ªám ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ, EDSAC (Electronic Delay Storage Automatic Calculator), ch·∫°y ch∆∞∆°ng tr√¨nh ƒë·∫ßu ti√™n v√†o nƒÉm 1949, l√† m√°y t√≠nh ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ ƒë·∫ßu ti√™n ƒëi v√†o ho·∫°t ƒë·ªông."
        }
    },
    {
        "id": 55,
        "en": {
            "question": "The IAS computer was developed at ____.",
            "options": [
                "A. The University of Pennsylvania",
                "B. The Institute for Advanced Study, Princeton",
                "C. MIT",
                "D. Bell Labs"
            ],
            "answer": "B. The Institute for Advanced Study, Princeton",
            "explanation": "The IAS computer, based on the von Neumann architecture, was developed at the Institute for Advanced Study in Princeton, New Jersey."
        },
        "vi": {
            "question": "M√°y t√≠nh IAS ƒë∆∞·ª£c ph√°t tri·ªÉn t·∫°i ____.",
            "options": [
                "A. ƒê·∫°i h·ªçc Pennsylvania",
                "B. Vi·ªán Nghi√™n c·ª©u Cao c·∫•p, Princeton",
                "C. MIT",
                "D. Bell Labs"
            ],
            "answer": "B. Vi·ªán Nghi√™n c·ª©u Cao c·∫•p, Princeton",
            "explanation": "M√°y t√≠nh IAS, d·ª±a tr√™n ki·∫øn tr√∫c von Neumann, ƒë∆∞·ª£c ph√°t tri·ªÉn t·∫°i Vi·ªán Nghi√™n c·ª©u Cao c·∫•p ·ªü Princeton, New Jersey."
        }
    },
    {
        "id": 56,
        "en": {
            "question": "A silicon wafer is created and divided into chips consisting of many gates and/or memory cells plus a number of input and output attachment points.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "This describes the basic process of semiconductor fabrication, where a large silicon wafer is patterned with many identical circuits (chips), which are then diced and packaged."
        },
        "vi": {
            "question": "M·ªôt t·∫•m wafer silicon ƒë∆∞·ª£c t·∫°o ra v√† ƒë∆∞·ª£c chia th√†nh c√°c chip bao g·ªìm nhi·ªÅu c·ªïng v√†/ho·∫∑c c√°c √¥ nh·ªõ c·ªông v·ªõi m·ªôt s·ªë ƒëi·ªÉm ƒë√≠nh k√®m ƒë·∫ßu v√†o v√† ƒë·∫ßu ra.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "ƒêi·ªÅu n√†y m√¥ t·∫£ qu√° tr√¨nh c∆° b·∫£n c·ªßa s·∫£n xu·∫•t b√°n d·∫´n, trong ƒë√≥ m·ªôt t·∫•m wafer silicon l·ªõn ƒë∆∞·ª£c t·∫°o m·∫´u v·ªõi nhi·ªÅu m·∫°ch gi·ªëng h·ªát nhau (chip), sau ƒë√≥ ƒë∆∞·ª£c c·∫Øt v√† ƒë√≥ng g√≥i."
        }
    },
    {
        "id": 57,
        "en": {
            "question": "Which of the following is not a characteristic of a stored-program computer?",
            "options": [
                "A. The program is stored in memory.",
                "B. Instructions are executed sequentially.",
                "C. The control unit must be programmed manually.",
                "D. Instructions and data are stored in the same memory."
            ],
            "answer": "C. The control unit must be programmed manually.",
            "explanation": "The entire point of a stored-program computer is to avoid manual programming (like on the ENIAC). The control unit reads and interprets the program from memory."
        },
        "vi": {
            "question": "ƒêi·ªÅu n√†o sau ƒë√¢y kh√¥ng ph·∫£i l√† ƒë·∫∑c ƒëi·ªÉm c·ªßa m√°y t√≠nh ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ?",
            "options": [
                "A. Ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ trong b·ªô nh·ªõ.",
                "B. C√°c l·ªánh ƒë∆∞·ª£c th·ª±c thi tu·∫ßn t·ª±.",
                "C. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn ph·∫£i ƒë∆∞·ª£c l·∫≠p tr√¨nh th·ªß c√¥ng.",
                "D. L·ªánh v√† d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ trong c√πng m·ªôt b·ªô nh·ªõ."
            ],
            "answer": "C. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn ph·∫£i ƒë∆∞·ª£c l·∫≠p tr√¨nh th·ªß c√¥ng.",
            "explanation": "To√†n b·ªô √Ω nghƒ©a c·ªßa m·ªôt m√°y t√≠nh ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ l√† ƒë·ªÉ tr√°nh l·∫≠p tr√¨nh th·ªß c√¥ng (nh∆∞ tr√™n ENIAC). ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn ƒë·ªçc v√† gi·∫£i th√≠ch ch∆∞∆°ng tr√¨nh t·ª´ b·ªô nh·ªõ."
        }
    },
    // Chuy√™n m·ª•c 3: A Top-Level View of a Computer (T·ªïng quan v·ªÅ M√°y t√≠nh) - 18 c√¢u
    {
        "id": 58,
        "en": {
            "question": "The ____ contains the 8-bit instruction register that is currently being executed.",
            "options": [
                "A. memory buffer register",
                "B. instruction buffer register",
                "C. instruction register",
                "D. memory address register"
            ],
            "answer": "C. instruction register",
            "explanation": "The Instruction Register (IR) holds the opcode of the instruction that has been fetched from memory and is currently being decoded and executed."
        },
        "vi": {
            "question": "____ ch·ª©a thanh ghi l·ªánh 8-bit ƒëang ƒë∆∞·ª£c th·ª±c thi.",
            "options": [
                "A. b·ªô ƒë·ªám b·ªô nh·ªõ (memory buffer register)",
                "B. b·ªô ƒë·ªám l·ªánh (instruction buffer register)",
                "C. thanh ghi l·ªánh (instruction register)",
                "D. thanh ghi ƒë·ªãa ch·ªâ b·ªô nh·ªõ (memory address register)"
            ],
            "answer": "C. thanh ghi l·ªánh (instruction register)",
            "explanation": "Thanh ghi l·ªánh (IR) gi·ªØ m√£ l·ªánh (opcode) c·ªßa l·ªánh ƒë√£ ƒë∆∞·ª£c t√¨m n·∫°p t·ª´ b·ªô nh·ªõ v√† ƒëang ƒë∆∞·ª£c gi·∫£i m√£ v√† th·ª±c thi."
        }
    },
    {
        "id": 59,
        "en": {
            "question": "What is the primary purpose of the 'Fetch instruction' stage in the operation of a processor?",
            "options": [
                "A. To read an instruction from memory.",
                "B. To interpret the instruction.",
                "C. To perform arithmetic operations on data.",
                "D. To write data to memory."
            ],
            "answer": "A. To read an instruction from memory.",
            "explanation": "The fetch stage is the first step in the instruction cycle, where the processor retrieves the next instruction from the memory location pointed to by the program counter."
        },
        "vi": {
            "question": "M·ª•c ƒë√≠ch ch√≠nh c·ªßa giai ƒëo·∫°n \"N·∫°p l·ªánh\" (Fetch instruction) trong ho·∫°t ƒë·ªông c·ªßa m·ªôt b·ªô x·ª≠ l√Ω l√† g√¨?",
            "options": [
                "A. ƒê·ªçc m·ªôt l·ªánh t·ª´ b·ªô nh·ªõ.",
                "B. Di·ªÖn d·ªãch l·ªánh.",
                "C. Th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông s·ªë h·ªçc tr√™n d·ªØ li·ªáu.",
                "D. Ghi d·ªØ li·ªáu v√†o b·ªô nh·ªõ."
            ],
            "answer": "A. ƒê·ªçc m·ªôt l·ªánh t·ª´ b·ªô nh·ªõ.",
            "explanation": "Giai ƒëo·∫°n t√¨m n·∫°p l√† b∆∞·ªõc ƒë·∫ßu ti√™n trong chu k·ª≥ l·ªánh, n∆°i b·ªô x·ª≠ l√Ω l·∫•y l·ªánh ti·∫øp theo t·ª´ v·ªã tr√≠ b·ªô nh·ªõ ƒë∆∞·ª£c tr·ªè t·ªõi b·ªüi b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh."
        }
    },
    {
        "id": 60,
        "en": {
            "question": "What is the primary function of the Arithmetic and Logic Unit (ALU) in a processor?",
            "options": [
                "A. To perform the actual computation and data processing.",
                "B. To control the movement of data and instructions.",
                "C. To act as an interface to the system bus.",
                "D. To manage the processor's internal memory."
            ],
            "answer": "A. To perform the actual computation and data processing.",
            "explanation": "The ALU is the core computational engine of the CPU, responsible for all arithmetic (e.g., add, subtract) and logical (e.g., AND, OR, NOT) operations."
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng ch√≠nh c·ªßa ƒê∆°n v·ªã S·ªë h·ªçc v√† Logic (ALU) trong m·ªôt b·ªô x·ª≠ l√Ω l√† g√¨?",
            "options": [
                "A. Th·ª±c hi·ªán c√°c ph√©p t√≠nh v√† x·ª≠ l√Ω d·ªØ li·ªáu th·ª±c t·∫ø.",
                "B. Ki·ªÉm so√°t s·ª± di chuy·ªÉn c·ªßa d·ªØ li·ªáu v√† l·ªánh.",
                "C. Ho·∫°t ƒë·ªông nh∆∞ m·ªôt giao di·ªán v·ªõi bus h·ªá th·ªëng.",
                "D. Qu·∫£n l√Ω b·ªô nh·ªõ trong c·ªßa b·ªô x·ª≠ l√Ω."
            ],
            "answer": "A. Th·ª±c hi·ªán c√°c ph√©p t√≠nh v√† x·ª≠ l√Ω d·ªØ li·ªáu th·ª±c t·∫ø.",
            "explanation": "ALU l√† c√¥ng c·ª• t√≠nh to√°n c·ªët l√µi c·ªßa CPU, ch·ªãu tr√°ch nhi·ªám cho t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông s·ªë h·ªçc (v√≠ d·ª•: c·ªông, tr·ª´) v√† logic (v√≠ d·ª•: AND, OR, NOT)."
        }
    },
    {
        "id": 61,
        "en": {
            "question": "The basic functions of an I/O module are:",
            "options": [
                "A. Control & Timing, Processor Communication, Device Communication, Data Buffering, Error Detection.",
                "B. Control & Timing, Processor Communication, Device Communication, Data Buffering, Error Detection, Writing data to memory.",
                "C. Control & Timing, Processor Communication, Device Communication, Data Buffering, Device blocking.",
                "D. Control & Timing, Processor Communication, Device Communication, Error Detection, Data processing."
            ],
            "answer": "A. Control & Timing, Processor Communication, Device Communication, Data Buffering, Error Detection.",
            "explanation": "These five functions are the core responsibilities of an I/O module to manage communication between the CPU/memory and an external peripheral device."
        },
        "vi": {
            "question": "C√°c ch·ª©c nƒÉng c∆° b·∫£n nh·∫•t c·ªßa m·ªôt m√¥-ƒëun I/O l√† g√¨?",
            "options": [
                "A. ƒêi·ªÅu khi·ªÉn v√† ƒë·ªãnh th·ªùi, giao ti·∫øp b·ªô x·ª≠ l√Ω, giao ti·∫øp thi·∫øt b·ªã, ƒë·ªám d·ªØ li·ªáu, ph√°t hi·ªán l·ªói.",
                "B. ƒêi·ªÅu khi·ªÉn v√† ƒë·ªãnh th·ªùi, giao ti·∫øp b·ªô x·ª≠ l√Ω, giao ti·∫øp thi·∫øt b·ªã, ƒë·ªám d·ªØ li·ªáu, ph√°t hi·ªán l·ªói, ghi d·ªØ li·ªáu v√†o b·ªô nh·ªõ.",
                "C. ƒêi·ªÅu khi·ªÉn v√† ƒë·ªãnh th·ªùi, giao ti·∫øp b·ªô x·ª≠ l√Ω, giao ti·∫øp thi·∫øt b·ªã, ƒë·ªám d·ªØ li·ªáu, thi·∫øt b·ªã ch·∫∑n.",
                "D. ƒêi·ªÅu khi·ªÉn v√† ƒë·ªãnh th·ªùi, giao ti·∫øp b·ªô x·ª≠ l√Ω, giao ti·∫øp thi·∫øt b·ªã, ph√°t hi·ªán l·ªói, x·ª≠ l√Ω d·ªØ li·ªáu."
            ],
            "answer": "A. ƒêi·ªÅu khi·ªÉn v√† ƒë·ªãnh th·ªùi, giao ti·∫øp b·ªô x·ª≠ l√Ω, giao ti·∫øp thi·∫øt b·ªã, ƒë·ªám d·ªØ li·ªáu, ph√°t hi·ªán l·ªói.",
            "explanation": "NƒÉm ch·ª©c nƒÉng n√†y l√† tr√°ch nhi·ªám c·ªët l√µi c·ªßa m·ªôt m√¥-ƒëun I/O ƒë·ªÉ qu·∫£n l√Ω giao ti·∫øp gi·ªØa CPU/b·ªô nh·ªõ v√† m·ªôt thi·∫øt b·ªã ngo·∫°i vi b√™n ngo√†i."
        }
    },
    {
        "id": 62,
        "en": {
            "question": "What is a Memory Address Register (MAR)?",
            "options": [
                "A. Contains a word to be stored in memory or sent to the I/O unit, or is used to receive a word from memory or from the I/O unit.",
                "B. Is used for temporarily holding the right-hand instruction from a word in memory.",
                "C. Contains the address in memory of the word to be written from or read into the MBR.",
                "D. Contains the address of the next instruction pair to be fetched from memory."
            ],
            "answer": "C. Contains the address in memory of the word to be written from or read into the MBR.",
            "explanation": "The MAR's sole purpose is to hold the memory address for the next read or write operation. The data itself is transferred via the MBR (Memory Buffer Register)."
        },
        "vi": {
            "question": "Thanh ghi ƒë·ªãa ch·ªâ b·ªô nh·ªõ (Memory Address Register - MAR) l√† g√¨?",
            "options": [
                "A. Ch·ª©a m·ªôt t·ª´ s·∫Ω ƒë∆∞·ª£c l∆∞u tr·ªØ trong b·ªô nh·ªõ ho·∫∑c g·ª≠i ƒë·∫øn ƒë∆°n v·ªã I/O, ho·∫∑c ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ nh·∫≠n m·ªôt t·ª´ t·ª´ b·ªô nh·ªõ ho·∫∑c t·ª´ ƒë∆°n v·ªã I/O.",
                "B. ƒê∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ gi·ªØ t·∫°m th·ªùi l·ªánh b√™n ph·∫£i trong m·ªôt t·ª´ trong b·ªô nh·ªõ.",
                "C. Ch·ª©a ƒë·ªãa ch·ªâ trong b·ªô nh·ªõ c·ªßa t·ª´ s·∫Ω ƒë∆∞·ª£c ghi v√†o ho·∫∑c ƒë·ªçc ra MBR.",
                "D. Ch·ª©a ƒë·ªãa ch·ªâ c·ªßa c·∫∑p l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c t√¨m n·∫°p t·ª´ b·ªô nh·ªõ."
            ],
            "answer": "C. Ch·ª©a ƒë·ªãa ch·ªâ trong b·ªô nh·ªõ c·ªßa t·ª´ s·∫Ω ƒë∆∞·ª£c ghi v√†o ho·∫∑c ƒë·ªçc ra MBR.",
            "explanation": "M·ª•c ƒë√≠ch duy nh·∫•t c·ªßa MAR l√† gi·ªØ ƒë·ªãa ch·ªâ b·ªô nh·ªõ cho ho·∫°t ƒë·ªông ƒë·ªçc ho·∫∑c ghi ti·∫øp theo. D·ªØ li·ªáu th·ª±c t·∫ø ƒë∆∞·ª£c chuy·ªÉn qua MBR (Thanh ghi b·ªô ƒë·ªám b·ªô nh·ªõ)."
        }
    },
    {
        "id": 63,
        "en": {
            "question": "What is the role of the Memory Address Register (MAR) in a computer system?",
            "options": [
                "A. It contains the data being transferred between memory and the processor.",
                "B. It specifies the address in memory for the next read or write operation.",
                "C. It performs arithmetic operations on data stored in memory.",
                "D. It stores program instructions after they have been executed."
            ],
            "answer": "B. It specifies the address in memory for the next read or write operation.",
            "explanation": "The MAR holds the specific memory address that the CPU wants to access, whether for reading data from that address or writing data to it."
        },
        "vi": {
            "question": "Vai tr√≤ c·ªßa thanh ghi ƒë·ªãa ch·ªâ b·ªô nh·ªõ (MAR) trong h·ªá th·ªëng m√°y t√≠nh l√† g√¨?",
            "options": [
                "A. N√≥ ch·ª©a d·ªØ li·ªáu ƒëang ƒë∆∞·ª£c truy·ªÅn gi·ªØa b·ªô nh·ªõ v√† b·ªô x·ª≠ l√Ω.",
                "B. N√≥ ch·ªâ ƒë·ªãnh ƒë·ªãa ch·ªâ trong b·ªô nh·ªõ cho ho·∫°t ƒë·ªông ƒë·ªçc ho·∫∑c ghi ti·∫øp theo.",
                "C. N√≥ th·ª±c hi·ªán c√°c ph√©p to√°n s·ªë h·ªçc tr√™n d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ trong b·ªô nh·ªõ.",
                "D. N√≥ l∆∞u tr·ªØ c√°c l·ªánh ch∆∞∆°ng tr√¨nh sau khi ch√∫ng ƒë∆∞·ª£c th·ª±c thi."
            ],
            "answer": "B. N√≥ ch·ªâ ƒë·ªãnh ƒë·ªãa ch·ªâ trong b·ªô nh·ªõ cho ho·∫°t ƒë·ªông ƒë·ªçc ho·∫∑c ghi ti·∫øp theo.",
            "explanation": "MAR gi·ªØ ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ª• th·ªÉ m√† CPU mu·ªën truy c·∫≠p, cho d√π ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu t·ª´ ƒë·ªãa ch·ªâ ƒë√≥ hay ghi d·ªØ li·ªáu v√†o ƒë√≥."
        }
    },
    {
        "id": 64,
        "en": {
            "question": "The system interconnection must support which transfers?",
            "options": [
                "A. I/O to or from memory",
                "B. memory to processor",
                "C. all of the above",
                "D. processor to memory"
            ],
            "answer": "C. all of the above",
            "explanation": "The system interconnection (bus) is the pathway for all data movement between the processor, memory, and I/O modules."
        },
        "vi": {
            "question": "C·∫•u tr√∫c k·∫øt n·ªëi ph·∫£i h·ªó tr·ª£ vi·ªác truy·ªÅn n√†o?",
            "options": [
                "A. I/O ƒë·∫øn ho·∫∑c t·ª´ b·ªô nh·ªõ",
                "B. b·ªô nh·ªõ ƒë·∫øn b·ªô x·ª≠ l√Ω",
                "C. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n",
                "D. b·ªô x·ª≠ l√Ω ƒë·∫øn b·ªô nh·ªõ"
            ],
            "answer": "C. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n",
            "explanation": "K·∫øt n·ªëi h·ªá th·ªëng (bus) l√† ƒë∆∞·ªùng d·∫´n cho t·∫•t c·∫£ vi·ªác di chuy·ªÉn d·ªØ li·ªáu gi·ªØa b·ªô x·ª≠ l√Ω, b·ªô nh·ªõ v√† c√°c m√¥-ƒëun I/O."
        }
    },
    {
        "id": 65,
        "en": {
            "question": "What is the function of the Program Counter (PC) during the fetch stage of the instruction cycle?",
            "options": [
                "A. The program counter (PC) is not used during the fetch stage and its role is limited to tracking the number of instructions executed by the CPU.",
                "B. The program counter (PC) in the fetch stage holds the memory address of the next instruction to be fetched and executed.",
                "C. The program counter (PC) is responsible for executing instructions and has no specific role in the fetch stage.",
                "D. The program counter (PC) is only relevant in multi-core processors and does not contribute to the fetch stage of the instruction cycle in single-core systems."
            ],
            "answer": "B. The program counter (PC) in the fetch stage holds the memory address of the next instruction to be fetched and executed.",
            "explanation": "The PC's primary job is to always point to the memory location of the next instruction, which is essential for the fetch stage."
        },
        "vi": {
            "question": "T·∫ßm quan tr·ªçng c·ªßa b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) trong giai ƒëo·∫°n t√¨m n·∫°p c·ªßa chu k·ª≥ l·ªánh l√† g√¨?",
            "options": [
                "A. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong giai ƒëo·∫°n t√¨m n·∫°p v√† vai tr√≤ c·ªßa n√≥ ch·ªâ gi·ªõi h·∫°n ·ªü vi·ªác theo d√µi s·ªë l∆∞·ª£ng l·ªánh ƒë∆∞·ª£c th·ª±c thi b·ªüi CPU.",
                "B. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) trong giai ƒëo·∫°n t√¨m n·∫°p gi·ªØ ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c t√¨m n·∫°p v√† th·ª±c thi.",
                "C. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) ch·ªãu tr√°ch nhi·ªám th·ª±c thi c√°c l·ªánh v√† kh√¥ng c√≥ vai tr√≤ c·ª• th·ªÉ trong giai ƒëo·∫°n t√¨m n·∫°p.",
                "D. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) ch·ªâ li√™n quan ƒë·∫øn c√°c b·ªô x·ª≠ l√Ω ƒëa l√µi v√† kh√¥ng ƒë√≥ng g√≥p v√†o giai ƒëo·∫°n t√¨m n·∫°p c·ªßa chu k·ª≥ l·ªánh trong c√°c h·ªá th·ªëng l√µi ƒë∆°n."
            ],
            "answer": "B. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) trong giai ƒëo·∫°n t√¨m n·∫°p gi·ªØ ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c t√¨m n·∫°p v√† th·ª±c thi.",
            "explanation": "C√¥ng vi·ªác ch√≠nh c·ªßa PC l√† lu√¥n tr·ªè ƒë·∫øn v·ªã tr√≠ b·ªô nh·ªõ c·ªßa l·ªánh ti·∫øp theo, ƒëi·ªÅu n√†y r·∫•t c·∫ßn thi·∫øt cho giai ƒëo·∫°n t√¨m n·∫°p."
        }
    },
    {
        "id": 66,
        "en": {
            "question": "What role does an Application Programming Interface (API) play in software development?",
            "options": [
                "A. Allows programs to access hardware resources using high-level language libraries.",
                "B. Defines low-level machine instructions.",
                "C. Provides a standard for binary portability.",
                "D. Manages system resources for the OS and machine language instructions."
            ],
            "answer": "A. Allows programs to access hardware resources using high-level language libraries.",
            "explanation": "An API provides a set of defined functions and protocols that allow an application to interact with system services (like I/O, file system, etc.) without needing to know the low-level implementation details."
        },
        "vi": {
            "question": "Giao di·ªán l·∫≠p tr√¨nh ·ª©ng d·ª•ng (API) ƒë√≥ng vai tr√≤ g√¨ trong ph√°t tri·ªÉn ph·∫ßn m·ªÅm?",
            "options": [
                "A. Cho ph√©p ch∆∞∆°ng tr√¨nh truy c·∫≠p t√†i nguy√™n ph·∫ßn c·ª©ng b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c th∆∞ vi·ªán ng√¥n ng·ªØ c·∫•p cao.",
                "B. X√°c ƒë·ªãnh c√°c l·ªánh m√°y c·∫•p th·∫•p.",
                "C. Cung c·∫•p m·ªôt ti√™u chu·∫©n cho t√≠nh di ƒë·ªông nh·ªã ph√¢n.",
                "D. Qu·∫£n l√Ω t√†i nguy√™n h·ªá th·ªëng cho h·ªá ƒëi·ªÅu h√†nh v√† c√°c l·ªánh ng√¥n ng·ªØ m√°y."
            ],
            "answer": "A. Cho ph√©p ch∆∞∆°ng tr√¨nh truy c·∫≠p t√†i nguy√™n ph·∫ßn c·ª©ng b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c th∆∞ vi·ªán ng√¥n ng·ªØ c·∫•p cao.",
            "explanation": "API cung c·∫•p m·ªôt t·∫≠p h·ª£p c√°c h√†m v√† giao th·ª©c ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a cho ph√©p ·ª©ng d·ª•ng t∆∞∆°ng t√°c v·ªõi c√°c d·ªãch v·ª• h·ªá th·ªëng (nh∆∞ I/O, h·ªá th·ªëng t·ªáp, v.v.) m√† kh√¥ng c·∫ßn bi·∫øt chi ti·∫øt tri·ªÉn khai c·∫•p th·∫•p."
        }
    },
    {
        "id": 67,
        "en": {
            "question": "What is the purpose of using an API?",
            "options": [
                "A. To allow application software to be easily moved to other systems that support the same API.",
                "B. To define the machine instruction repertoire.",
                "C. To standardize binary portability across programs.",
                "D. To manage system resources."
            ],
            "answer": "A. To allow application software to be easily moved to other systems that support the same API.",
            "explanation": "One of the key benefits of a standardized API (like POSIX) is that it enhances software portability. A program written for one OS can be recompiled and run on another OS that supports the same API with minimal changes."
        },
        "vi": {
            "question": "M·ª•c ƒë√≠ch c·ªßa vi·ªác s·ª≠ d·ª•ng API l√† g√¨?",
            "options": [
                "A. ƒê·ªÉ cho ph√©p ph·∫ßn m·ªÅm ·ª©ng d·ª•ng c√≥ th·ªÉ d·ªÖ d√†ng chuy·ªÉn sang c√°c h·ªá th·ªëng kh√°c h·ªó tr·ª£ c√πng m·ªôt API.",
                "B. ƒê·ªÉ x√°c ƒë·ªãnh kho l·ªánh m√°y.",
                "C. ƒê·ªÉ chu·∫©n h√≥a t√≠nh di ƒë·ªông nh·ªã ph√¢n tr√™n c√°c ch∆∞∆°ng tr√¨nh.",
                "D. ƒê·ªÉ qu·∫£n l√Ω t√†i nguy√™n h·ªá th·ªëng."
            ],
            "answer": "A. ƒê·ªÉ cho ph√©p ph·∫ßn m·ªÅm ·ª©ng d·ª•ng c√≥ th·ªÉ d·ªÖ d√†ng chuy·ªÉn sang c√°c h·ªá th·ªëng kh√°c h·ªó tr·ª£ c√πng m·ªôt API.",
            "explanation": "M·ªôt trong nh·ªØng l·ª£i √≠ch ch√≠nh c·ªßa m·ªôt API ƒë∆∞·ª£c ti√™u chu·∫©n h√≥a (nh∆∞ POSIX) l√† n√≥ tƒÉng c∆∞·ªùng t√≠nh di ƒë·ªông c·ªßa ph·∫ßn m·ªÅm. M·ªôt ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c vi·∫øt cho m·ªôt HƒêH c√≥ th·ªÉ ƒë∆∞·ª£c bi√™n d·ªãch l·∫°i v√† ch·∫°y tr√™n m·ªôt HƒêH kh√°c h·ªó tr·ª£ c√πng m·ªôt API v·ªõi nh·ªØng thay ƒë·ªïi t·ªëi thi·ªÉu."
        }
    },
    {
        "id": 68,
        "en": {
            "question": "Which electronic component is used to control operations such as fetching, decoding, and executing arithmetic operations performed by the processor?",
            "options": [
                "A. Using a system clock.",
                "B. Using a quartz crystal.",
                "C. Using an analog-to-digital converter.",
                "D. Using a counter."
            ],
            "answer": "A. Using a system clock.",
            "explanation": "The system clock generates regular electrical pulses that synchronize all the components of a computer, controlling the timing of all operations."
        },
        "vi": {
            "question": "Th√†nh ph·∫ßn ƒëi·ªán t·ª≠ n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒëi·ªÅu khi·ªÉn c√°c ho·∫°t ƒë·ªông nh∆∞ t√¨m n·∫°p, gi·∫£i m√£ v√† th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông s·ªë h·ªçc do b·ªô x·ª≠ l√Ω th·ª±c hi·ªán?",
            "options": [
                "A. S·ª≠ d·ª•ng m·ªôt ƒë·ªìng h·ªì h·ªá th·ªëng (system clock).",
                "B. S·ª≠ d·ª•ng m·ªôt tinh th·ªÉ th·∫°ch anh (quartz crystal).",
                "C. S·ª≠ d·ª•ng m·ªôt b·ªô chuy·ªÉn ƒë·ªïi t∆∞∆°ng t·ª± sang s·ªë.",
                "D. S·ª≠ d·ª•ng m·ªôt b·ªô ƒë·∫øm (counter)."
            ],
            "answer": "A. S·ª≠ d·ª•ng m·ªôt ƒë·ªìng h·ªì h·ªá th·ªëng (system clock).",
            "explanation": "ƒê·ªìng h·ªì h·ªá th·ªëng t·∫°o ra c√°c xung ƒëi·ªán ƒë·ªÅu ƒë·∫∑n ƒë·ªÉ ƒë·ªìng b·ªô h√≥a t·∫•t c·∫£ c√°c th√†nh ph·∫ßn c·ªßa m√°y t√≠nh, ƒëi·ªÅu khi·ªÉn th·ªùi gian c·ªßa t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông."
        }
    },
    {
        "id": 69,
        "en": {
            "question": "Which component defines the system call interface to the operating system and facilitates binary portability?",
            "options": [
                "A. Application Binary Interface (ABI)",
                "B. Application Programming Interface (API)",
                "C. Instruction Set Architecture (ISA)",
                "D. Central Processing Unit (CPU)"
            ],
            "answer": "A. Application Binary Interface (ABI)",
            "explanation": "The ABI defines the low-level interface between an application and the OS, including system call conventions, data types, and register usage, which is essential for binary portability (running a compiled program without changes)."
        },
        "vi": {
            "question": "Th√†nh ph·∫ßn n√†o x√°c ƒë·ªãnh giao di·ªán g·ªçi h·ªá th·ªëng t·ªõi h·ªá ƒëi·ªÅu h√†nh v√† t·∫°o ƒëi·ªÅu ki·ªán cho t√≠nh di ƒë·ªông nh·ªã ph√¢n?",
            "options": [
                "A. Giao di·ªán nh·ªã ph√¢n ·ª©ng d·ª•ng (Application Binary Interface)",
                "B. Giao di·ªán l·∫≠p tr√¨nh ·ª©ng d·ª•ng (Application Programming Interface)",
                "C. Ki·∫øn tr√∫c t·∫≠p l·ªánh (Instruction Set Architecture)",
                "D. ƒê∆°n v·ªã x·ª≠ l√Ω trung t√¢m (Central Processing Unit)"
            ],
            "answer": "A. Giao di·ªán nh·ªã ph√¢n ·ª©ng d·ª•ng (Application Binary Interface)",
            "explanation": "ABI ƒë·ªãnh nghƒ©a giao di·ªán c·∫•p th·∫•p gi·ªØa m·ªôt ·ª©ng d·ª•ng v√† HƒêH, bao g·ªìm c√°c quy ∆∞·ªõc g·ªçi h·ªá th·ªëng, ki·ªÉu d·ªØ li·ªáu v√† c√°ch s·ª≠ d·ª•ng thanh ghi, ƒëi·ªÅu n√†y c·∫ßn thi·∫øt cho t√≠nh di ƒë·ªông nh·ªã ph√¢n (ch·∫°y m·ªôt ch∆∞∆°ng tr√¨nh ƒë√£ bi√™n d·ªãch m√† kh√¥ng c·∫ßn thay ƒë·ªïi)."
        }
    },
    {
        "id": 70,
        "en": {
            "question": "Which function of the four basic functions of a computer describes the following statement? 'The paths between components are used to move data from memory to memory and from memory through the gates to memory'.",
            "options": [
                "A. Data storage",
                "B. Data processing",
                "C. Data movement",
                "D. Control"
            ],
            "answer": "C. Data movement",
            "explanation": "This statement explicitly describes the movement of data between different components (memory, I/O, processor), which is the data movement function."
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng n√†o trong b·ªën ch·ª©c nƒÉng c∆° b·∫£n c·ªßa m√°y t√≠nh m√¥ t·∫£ c√¢u l·ªánh sau? \"C√°c ƒë∆∞·ªùng d·∫´n gi·ªØa c√°c th√†nh ph·∫ßn ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ di chuy·ªÉn d·ªØ li·ªáu t·ª´ b·ªô nh·ªõ ƒë·∫øn b·ªô nh·ªõ v√† t·ª´ b·ªô nh·ªõ qua c√°c c·ªïng ƒë·∫øn b·ªô nh·ªõ\".",
            "options": [
                "A. L∆∞u tr·ªØ d·ªØ li·ªáu (Data storage)",
                "B. X·ª≠ l√Ω d·ªØ li·ªáu (Data processing)",
                "C. Di chuy·ªÉn d·ªØ li·ªáu (Data movement)",
                "D. ƒêi·ªÅu khi·ªÉn (Control)"
            ],
            "answer": "C. Di chuy·ªÉn d·ªØ li·ªáu (Data movement)",
            "explanation": "C√¢u l·ªánh n√†y m√¥ t·∫£ r√µ r√†ng vi·ªác di chuy·ªÉn d·ªØ li·ªáu gi·ªØa c√°c th√†nh ph·∫ßn kh√°c nhau (b·ªô nh·ªõ, I/O, b·ªô x·ª≠ l√Ω), ƒë√≥ l√† ch·ª©c nƒÉng di chuy·ªÉn d·ªØ li·ªáu."
        }
    },
    {
        "id": 71,
        "en": {
            "question": "The ____ defines the address of the next instruction to be executed. Typically, this involves adding a fixed number to the address of the previous instruction.",
            "options": [
                "A. Instruction fetch",
                "B. Instruction operation decoding",
                "C. Instruction address calculation",
                "D. Operand fetch"
            ],
            "answer": "C. Instruction address calculation",
            "explanation": "This step of the instruction cycle determines the address of the next instruction. In sequential execution, this is simply incrementing the Program Counter."
        },
        "vi": {
            "question": "___ x√°c ƒë·ªãnh ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c th·ª±c thi. Th√¥ng th∆∞·ªùng, ƒëi·ªÅu n√†y bao g·ªìm vi·ªác th√™m m·ªôt s·ªë c·ªë ƒë·ªãnh v√†o ƒë·ªãa ch·ªâ c·ªßa l·ªánh tr∆∞·ªõc ƒë√≥.",
            "options": [
                "A. T√¨m n·∫°p l·ªánh",
                "B. Gi·∫£i m√£ ho·∫°t ƒë·ªông l·ªánh",
                "C. T√≠nh to√°n ƒë·ªãa ch·ªâ l·ªánh",
                "D. T√¨m n·∫°p to√°n h·∫°ng"
            ],
            "answer": "C. T√≠nh to√°n ƒë·ªãa ch·ªâ l·ªánh",
            "explanation": "B∆∞·ªõc n√†y c·ªßa chu k·ª≥ l·ªánh x√°c ƒë·ªãnh ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo. Trong th·ª±c thi tu·∫ßn t·ª±, ƒë√¢y ch·ªâ ƒë∆°n gi·∫£n l√† vi·ªác tƒÉng B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh."
        }
    },
    {
        "id": 72,
        "en": {
            "question": "____ Read instruction from its memory location into the processor.",
            "options": [
                "A. Instruction fetch",
                "B. Instruction operation decoding",
                "C. Instruction address calculation",
                "D. Operand address calculation"
            ],
            "answer": "A. Instruction fetch",
            "explanation": "This is the definition of the instruction fetch stage, where the instruction is moved from memory into the processor's instruction register."
        },
        "vi": {
            "question": "___ ƒê·ªçc l·ªánh t·ª´ v·ªã tr√≠ b·ªô nh·ªõ c·ªßa n√≥ v√†o b·ªô x·ª≠ l√Ω.",
            "options": [
                "A. Instruction fetch (T√¨m n·∫°p l·ªánh)",
                "B. Gi·∫£i m√£ ho·∫°t ƒë·ªông l·ªánh",
                "C. T√≠nh to√°n ƒë·ªãa ch·ªâ l·ªánh",
                "D. T√≠nh to√°n ƒë·ªãa ch·ªâ to√°n h·∫°ng"
            ],
            "answer": "A. Instruction fetch (T√¨m n·∫°p l·ªánh)",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa giai ƒëo·∫°n t√¨m n·∫°p l·ªánh, n∆°i l·ªánh ƒë∆∞·ª£c chuy·ªÉn t·ª´ b·ªô nh·ªõ v√†o thanh ghi l·ªánh c·ªßa b·ªô x·ª≠ l√Ω."
        }
    },
    {
        "id": 73,
        "en": {
            "question": "____ If the operation involves reference to an operand in memory or available via I/O, then determine the address of the operand.",
            "options": [
                "A. Operand address calculation",
                "B. Instruction fetch",
                "C. Instruction address calculation",
                "D. Instruction operation decoding"
            ],
            "answer": "A. Operand address calculation",
            "explanation": "This stage calculates the effective address of the data that the instruction needs to operate on."
        },
        "vi": {
            "question": "___ N·∫øu ho·∫°t ƒë·ªông li√™n quan ƒë·∫øn tham chi·∫øu ƒë·∫øn m·ªôt to√°n h·∫°ng trong b·ªô nh·ªõ ho·∫∑c c√≥ s·∫µn qua I/O, th√¨ h√£y x√°c ƒë·ªãnh ƒë·ªãa ch·ªâ c·ªßa to√°n h·∫°ng.",
            "options": [
                "A. Operand address calculation (T√≠nh to√°n ƒë·ªãa ch·ªâ to√°n h·∫°ng)",
                "B. T√¨m n·∫°p l·ªánh",
                "C. T√≠nh to√°n ƒë·ªãa ch·ªâ l·ªánh",
                "D. Gi·∫£i m√£ ho·∫°t ƒë·ªông l·ªánh"
            ],
            "answer": "A. Operand address calculation (T√≠nh to√°n ƒë·ªãa ch·ªâ to√°n h·∫°ng)",
            "explanation": "Giai ƒëo·∫°n n√†y t√≠nh to√°n ƒë·ªãa ch·ªâ hi·ªáu d·ª•ng c·ªßa d·ªØ li·ªáu m√† l·ªánh c·∫ßn ƒë·ªÉ ho·∫°t ƒë·ªông."
        }
    },
    {
        "id": 74,
        "en": {
            "question": "Which of these is not a common computer bus?",
            "options": [
                "A. Data bus",
                "B. Address bus",
                "C. Control bus",
                "D. Signal bus"
            ],
            "answer": "D. Signal bus",
            "explanation": "The three primary types of buses in a computer system are the Address Bus, Data Bus, and Control Bus. 'Signal bus' is not a standard term for a top-level bus type."
        },
        "vi": {
            "question": "Lo·∫°i n√†o sau ƒë√¢y kh√¥ng ph·∫£i l√† m·ªôt bus k·∫øt n·ªëi?",
            "options": [
                "A. D√¢y d·ªØ li·ªáu (Data lines)",
                "B. D√¢y ƒëi·ªÅu khi·ªÉn (Control lines)",
                "C. D√¢y t√≠n hi·ªáu (Signal lines)",
                "D. D√¢y ƒë·ªãa ch·ªâ (Address lines)"
            ],
            "answer": "C. D√¢y t√≠n hi·ªáu (Signal lines)",
            "explanation": "M·ªôt bus h·ªá th·ªëng ƒë∆∞·ª£c c·∫•u th√†nh t·ª´ c√°c ƒë∆∞·ªùng d·ªØ li·ªáu (data lines), ƒë∆∞·ªùng ƒë·ªãa ch·ªâ (address lines), v√† ƒë∆∞·ªùng ƒëi·ªÅu khi·ªÉn (control lines). 'D√¢y t√≠n hi·ªáu' l√† m·ªôt thu·∫≠t ng·ªØ qu√° chung chung."
        }
    },
    {
        "id": 75,
        "en": {
            "question": "A ____ is a path or line on which data is transferred from one part of a computer to another.",
            "options": [
                "A. Wire",
                "B. Bus",
                "C. Track",
                "D. Port"
            ],
            "answer": "B. Bus",
            "explanation": "A bus is a communication system that transfers data between components inside a computer, or between computers."
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt ƒë∆∞·ªùng d·∫´n ho·∫∑c ƒë∆∞·ªùng tr√™n ƒë√≥ d·ªØ li·ªáu ƒë∆∞·ª£c truy·ªÅn t·ª´ m·ªôt ph·∫ßn c·ªßa m√°y t√≠nh sang ph·∫ßn kh√°c.",
            "options": [
                "A. D√¢y (Wire)",
                "B. Bus",
                "C. R√£nh (Track)",
                "D. C·ªïng (Port)"
            ],
            "answer": "B. Bus",
            "explanation": "Bus l√† m·ªôt h·ªá th·ªëng truy·ªÅn th√¥ng chuy·ªÉn d·ªØ li·ªáu gi·ªØa c√°c th√†nh ph·∫ßn b√™n trong m√°y t√≠nh, ho·∫∑c gi·ªØa c√°c m√°y t√≠nh."
        }
    },
    // Chuy√™n m·ª•c 4: Cache Memory (B·ªô nh·ªõ ƒë·ªám) - 26 c√¢u
    {
        "id": 76,
        "en": {
            "question": "Which memory level is integrated into the processor chip and has the lowest latency?",
            "options": [
                "A. L1 cache",
                "B. L2 cache",
                "C. L3 cache",
                "D. L4 cache"
            ],
            "answer": "A. L1 cache",
            "explanation": "L1 (Level 1) cache is the fastest and smallest level of cache, located directly on the processor core itself, providing the lowest latency access."
        },
        "vi": {
            "question": "M·ª©c b·ªô nh·ªõ ƒë·ªám (cache) n√†o ƒë∆∞·ª£c t√≠ch h·ª£p v√†o chip x·ª≠ l√Ω v√† c√≥ ƒë·ªô tr·ªÖ th·∫•p nh·∫•t?",
            "options": [
                "A. L1 cache",
                "B. L2 cache",
                "C. L3 cache",
                "D. L4 cache"
            ],
            "answer": "A. L1 cache",
            "explanation": "Cache L1 (C·∫•p 1) l√† c·∫•p cache nhanh nh·∫•t v√† nh·ªè nh·∫•t, n·∫±m tr·ª±c ti·∫øp tr√™n ch√≠nh l√µi x·ª≠ l√Ω, cung c·∫•p kh·∫£ nƒÉng truy c·∫≠p c√≥ ƒë·ªô tr·ªÖ th·∫•p nh·∫•t."
        }
    },
    {
        "id": 77,
        "en": {
            "question": "What is the benefit of cache memory for computer performance?",
            "options": [
                "A. It reduces the computer's power consumption.",
                "B. It speeds up data access and improves system performance.",
                "C. It increases the computer's storage capacity.",
                "D. It serves as a backup storage for important files."
            ],
            "answer": "B. It speeds up data access and improves system performance.",
            "explanation": "Cache memory is a small, fast memory that stores frequently accessed data, reducing the need for the CPU to access the much slower main memory (RAM)."
        },
        "vi": {
            "question": "L·ª£i √≠ch c·ªßa b·ªô nh·ªõ ƒë·ªám (cache memory) ƒë·ªëi v·ªõi hi·ªáu su·∫•t m√°y t√≠nh l√† g√¨?",
            "options": [
                "A. N√≥ l√†m gi·∫£m m·ª©c ti√™u th·ª• ƒëi·ªán nƒÉng c·ªßa m√°y t√≠nh.",
                "B. N√≥ tƒÉng t·ªëc ƒë·ªô truy c·∫≠p d·ªØ li·ªáu v√† c·∫£i thi·ªán hi·ªáu su·∫•t h·ªá th·ªëng.",
                "C. N√≥ l√†m tƒÉng dung l∆∞·ª£ng l∆∞u tr·ªØ c·ªßa m√°y t√≠nh.",
                "D. N√≥ ph·ª•c v·ª• nh∆∞ m·ªôt b·ªô l∆∞u tr·ªØ d·ª± ph√≤ng cho c√°c t·ªáp quan tr·ªçng."
            ],
            "answer": "B. N√≥ tƒÉng t·ªëc ƒë·ªô truy c·∫≠p d·ªØ li·ªáu v√† c·∫£i thi·ªán hi·ªáu su·∫•t h·ªá th·ªëng.",
            "explanation": "B·ªô nh·ªõ cache l√† m·ªôt b·ªô nh·ªõ nh·ªè, nhanh, l∆∞u tr·ªØ d·ªØ li·ªáu ƒë∆∞·ª£c truy c·∫≠p th∆∞·ªùng xuy√™n, gi·∫£m thi·ªÉu nhu c·∫ßu CPU ph·∫£i truy c·∫≠p v√†o b·ªô nh·ªõ ch√≠nh (RAM) ch·∫≠m h∆°n nhi·ªÅu."
        }
    },
    {
        "id": 78,
        "en": {
            "question": "What is the most common mapping technique used in modern computer caches?",
            "options": [
                "A. Direct Mapping",
                "B. Fully Associative",
                "C. Set Associative",
                "D. None of the above."
            ],
            "answer": "C. Set Associative",
            "explanation": "Set-associative mapping is a compromise between the simplicity of direct mapping and the flexibility of fully associative mapping, offering a good balance of performance and hardware complexity."
        },
        "vi": {
            "question": "K·ªπ thu·∫≠t √°nh x·∫° ph·ªï bi·∫øn nh·∫•t ƒë∆∞·ª£c s·ª≠ d·ª•ng trong b·ªô nh·ªõ cache trong c√°c m√°y t√≠nh hi·ªán ƒë·∫°i l√† g√¨?",
            "options": [
                "A. √Ånh x·∫° tr·ª±c ti·∫øp (Direct Mapping)",
                "B. √Ånh x·∫° k·∫øt h·ª£p ho√†n to√†n (Fully Associative)",
                "C. √Ånh x·∫° k·∫øt h·ª£p t·∫≠p h·ª£p (Set Associative)",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o ƒë√∫ng."
            ],
            "answer": "C. √Ånh x·∫° k·∫øt h·ª£p t·∫≠p h·ª£p (Set Associative)",
            "explanation": "√Ånh x·∫° k·∫øt h·ª£p t·∫≠p h·ª£p l√† m·ªôt s·ª± th·ªèa hi·ªáp gi·ªØa s·ª± ƒë∆°n gi·∫£n c·ªßa √°nh x·∫° tr·ª±c ti·∫øp v√† s·ª± linh ho·∫°t c·ªßa √°nh x·∫° k·∫øt h·ª£p ho√†n to√†n, cung c·∫•p m·ªôt s·ª± c√¢n b·∫±ng t·ªët gi·ªØa hi·ªáu su·∫•t v√† ƒë·ªô ph·ª©c t·∫°p c·ªßa ph·∫ßn c·ª©ng."
        }
    },
    {
        "id": 79,
        "en": {
            "question": "Which cache is not a shared cache?",
            "options": [
                "A. L4 cache",
                "B. L3 cache",
                "C. L2 cache",
                "D. L1 cache"
            ],
            "answer": "D. L1 cache",
            "explanation": "L1 cache is typically private to each individual processor core. L2 can be private or shared, while L3 and L4 (if present) are almost always shared among all cores."
        },
        "vi": {
            "question": "Cache n√†o kh√¥ng ph·∫£i l√† cache chia s·∫ª (shared cache)?",
            "options": [
                "A. L4 cache",
                "B. L3 cache",
                "C. L2 cache",
                "D. L1 cache"
            ],
            "answer": "D. L1 cache",
            "explanation": "Cache L1 th∆∞·ªùng l√† ri√™ng t∆∞ cho m·ªói l√µi x·ª≠ l√Ω. L2 c√≥ th·ªÉ l√† ri√™ng t∆∞ ho·∫∑c chia s·∫ª, trong khi L3 v√† L4 (n·∫øu c√≥) g·∫ßn nh∆∞ lu√¥n ƒë∆∞·ª£c chia s·∫ª gi·ªØa t·∫•t c·∫£ c√°c l√µi."
        }
    },
    {
        "id": 80,
        "en": {
            "question": "In which writing technique are all write operations performed to main memory as well as to the cache, ensuring that main memory is always valid?",
            "options": [
                "A. Write through",
                "B. Write back",
                "C. Write around",
                "D. No write allocate"
            ],
            "answer": "A. Write through",
            "explanation": "In a write-through policy, every write to the cache is immediately written to the main memory as well. This keeps memory consistent but can be slower than write-back."
        },
        "vi": {
            "question": "K·ªπ thu·∫≠t ghi n√†o m√† trong ƒë√≥ t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông ghi ƒë∆∞·ª£c th·ª±c hi·ªán v√†o b·ªô nh·ªõ ch√≠nh c≈©ng nh∆∞ v√†o b·ªô ƒë·ªám, ƒë·∫£m b·∫£o r·∫±ng b·ªô nh·ªõ ch√≠nh lu√¥n h·ª£p l·ªá?",
            "options": [
                "A. Ghi xuy√™n (Write through)",
                "B. Ghi l·∫°i (Write back)",
                "C. Ghi xung quanh (Write around)",
                "D. Kh√¥ng c·∫•p ph√°t ghi (No write allocate)"
            ],
            "answer": "A. Ghi xuy√™n (Write through)",
            "explanation": "Trong ch√≠nh s√°ch ghi xuy√™n, m·ªçi thao t√°c ghi v√†o cache ƒë·ªÅu ƒë∆∞·ª£c ghi ngay l·∫≠p t·ª©c v√†o b·ªô nh·ªõ ch√≠nh. ƒêi·ªÅu n√†y gi·ªØ cho b·ªô nh·ªõ lu√¥n nh·∫•t qu√°n nh∆∞ng c√≥ th·ªÉ ch·∫≠m h∆°n so v·ªõi ghi l·∫°i."
        }
    },
    {
        "id": 81,
        "en": {
            "question": "Which cache mapping type maps each block of main memory into only one possible cache line?",
            "options": [
                "A. Direct mapping",
                "B. Set associative mapping",
                "C. Fully associative mapping",
                "D. Direct access"
            ],
            "answer": "A. Direct mapping",
            "explanation": "In direct mapping, the location of a block in the cache is determined by its memory address using a simple modulo function (i = j mod m)."
        },
        "vi": {
            "question": "Lo·∫°i √°nh x·∫° b·ªô ƒë·ªám n√†o √°nh x·∫° m·ªói kh·ªëi c·ªßa b·ªô nh·ªõ ch√≠nh v√†o m·ªôt d√≤ng duy nh·∫•t c·ªßa b·ªô ƒë·ªám?",
            "options": [
                "A. √Ånh x·∫° tr·ª±c ti·∫øp (Direct mapping)",
                "B. √Ånh x·∫° k·∫øt h·ª£p t·∫≠p h·ª£p (Set associative mapping)",
                "C. √Ånh x·∫° k·∫øt h·ª£p ho√†n to√†n (Fully associative mapping)",
                "D. Truy c·∫≠p tr·ª±c ti·∫øp (Direct access)"
            ],
            "answer": "A. √Ånh x·∫° tr·ª±c ti·∫øp (Direct mapping)",
            "explanation": "Trong √°nh x·∫° tr·ª±c ti·∫øp, v·ªã tr√≠ c·ªßa m·ªôt kh·ªëi trong cache ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa n√≥ b·∫±ng c√°ch s·ª≠ d·ª•ng m·ªôt h√†m modulo ƒë∆°n gi·∫£n (i = j mod m)."
        }
    },
    {
        "id": 82,
        "en": {
            "question": "Which of the following algorithms is generally not used in cache replacement?",
            "options": [
                "A. Least Recently Used (LRU)",
                "B. First-In, First-Out (FIFO)",
                "C. Least Frequently Used (LFU)",
                "D. Round Robin (RR)"
            ],
            "answer": "D. Round Robin (RR)",
            "explanation": "LRU, FIFO, and LFU are all common cache replacement policies. Round Robin is a CPU scheduling algorithm, not typically used for cache replacement."
        },
        "vi": {
            "question": "Thu·∫≠t to√°n n√†o sau ƒë√¢y th∆∞·ªùng kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong vi·ªác thay th·∫ø b·ªô nh·ªõ cache?",
            "options": [
                "A. √çt ƒë∆∞·ª£c s·ª≠ d·ª•ng g·∫ßn ƒë√¢y nh·∫•t (LRU)",
                "B. V√†o tr∆∞·ªõc-Ra tr∆∞·ªõc (FIFO)",
                "C. √çt ƒë∆∞·ª£c s·ª≠ d·ª•ng th∆∞·ªùng xuy√™n nh·∫•t (LFU)",
                "D. V√≤ng tr√≤n (Round Robin - RR)"
            ],
            "answer": "D. V√≤ng tr√≤n (Round Robin - RR)",
            "explanation": "LRU, FIFO, v√† LFU ƒë·ªÅu l√† c√°c ch√≠nh s√°ch thay th·∫ø cache ph·ªï bi·∫øn. Round Robin l√† m·ªôt thu·∫≠t to√°n l·∫≠p l·ªãch CPU, th∆∞·ªùng kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ thay th·∫ø cache."
        }
    },
    {
        "id": 83,
        "en": {
            "question": "In a cache system using direct mapping, with a cache containing 10 lines, which memory block's data can be transferred to cache line 7?",
            "options": [
                "A. 7, 17, 27, 37, ...",
                "B. 0, 1, 2, 3, 4, 5, 6, 7, ...",
                "C. 0, 7, 17, 27, 37, ...",
                "D. 0, 7, 77, 777, ..."
            ],
            "answer": "A. 7, 17, 27, 37, ...",
            "explanation": "In direct mapping, the cache line is determined by `line = block_address % number_of_lines`. So, for line 7 with 10 total lines, any block address `j` where `j % 10 = 7` can be mapped. This includes 7, 17, 27, etc."
        },
        "vi": {
            "question": "Trong m·ªôt h·ªá th·ªëng b·ªô ƒë·ªám s·ª≠ d·ª•ng k·ªπ thu·∫≠t √°nh x·∫° tr·ª±c ti·∫øp, v·ªõi b·ªô ƒë·ªám ch·ª©a 10 d√≤ng, d·ªØ li·ªáu c·ªßa kh·ªëi b·ªô nh·ªõ n√†o c√≥ th·ªÉ ƒë∆∞·ª£c chuy·ªÉn ƒë·∫øn d√≤ng b·ªô ƒë·ªám 7?",
            "options": [
                "A. 7, 17, 27, 37, ...",
                "B. 0, 1, 2, 3, 4, 5, 6, 7, ...",
                "C. 0, 7, 17, 27, 37, ...",
                "D. 0, 7, 77, 777, ..."
            ],
            "answer": "A. 7, 17, 27, 37, ...",
            "explanation": "Trong √°nh x·∫° tr·ª±c ti·∫øp, d√≤ng cache ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi `d√≤ng = ƒë·ªãa_ch·ªâ_kh·ªëi % s·ªë_l∆∞·ª£ng_d√≤ng`. V√¨ v·∫≠y, ƒë·ªëi v·ªõi d√≤ng 7 v·ªõi t·ªïng s·ªë 10 d√≤ng, b·∫•t k·ª≥ ƒë·ªãa ch·ªâ kh·ªëi `j` n√†o m√† `j % 10 = 7` ƒë·ªÅu c√≥ th·ªÉ ƒë∆∞·ª£c √°nh x·∫°. ƒêi·ªÅu n√†y bao g·ªìm 7, 17, 27, v.v."
        }
    },
    {
        "id": 84,
        "en": {
            "question": "In modern processors, why is cache memory often organized into multiple levels, such as L1, L2, and L3?",
            "options": [
                "A. To balance the trade-off between speed and size by having different cache levels.",
                "B. To save chip area by reducing cache size and increasing memory size.",
                "C. To provide redundancy in case of cache failure.",
                "D. To improve cache coherence in multiprocessor systems."
            ],
            "answer": "A. To balance the trade-off between speed and size by having different cache levels.",
            "explanation": "A multi-level cache hierarchy allows for a very fast but small L1 cache for immediate needs, a larger and slightly slower L2 cache, and an even larger and slower L3 cache, providing a good balance between access speed, size, and cost."
        },
        "vi": {
            "question": "Trong c√°c b·ªô x·ª≠ l√Ω hi·ªán ƒë·∫°i, t·∫°i sao b·ªô nh·ªõ ƒë·ªám th∆∞·ªùng ƒë∆∞·ª£c t·ªï ch·ª©c th√†nh nhi·ªÅu c·∫•p, ch·∫≥ng h·∫°n nh∆∞ L1, L2 v√† L3?",
            "options": [
                "A. ƒê·ªÉ c√¢n b·∫±ng s·ª± ƒë√°nh ƒë·ªïi gi·ªØa t·ªëc ƒë·ªô v√† k√≠ch th∆∞·ªõc b·∫±ng c√°ch c√≥ c√°c c·∫•p b·ªô ƒë·ªám kh√°c nhau.",
                "B. ƒê·ªÉ ti·∫øt ki·ªám di·ªán t√≠ch chip b·∫±ng c√°ch gi·∫£m k√≠ch th∆∞·ªõc b·ªô ƒë·ªám v√† tƒÉng k√≠ch th∆∞·ªõc b·ªô nh·ªõ.",
                "C. ƒê·ªÉ cung c·∫•p d·ª± ph√≤ng trong tr∆∞·ªùng h·ª£p b·ªô ƒë·ªám b·ªã l·ªói.",
                "D. ƒê·ªÉ c·∫£i thi·ªán s·ª± g·∫Øn k·∫øt b·ªô ƒë·ªám trong c√°c h·ªá th·ªëng ƒëa x·ª≠ l√Ω."
            ],
            "answer": "A. ƒê·ªÉ c√¢n b·∫±ng s·ª± ƒë√°nh ƒë·ªïi gi·ªØa t·ªëc ƒë·ªô v√† k√≠ch th∆∞·ªõc b·∫±ng c√°ch c√≥ c√°c c·∫•p b·ªô ƒë·ªám kh√°c nhau.",
            "explanation": "M·ªôt h·ªá th·ªëng cache ƒëa c·∫•p cho ph√©p c√≥ m·ªôt cache L1 r·∫•t nhanh nh∆∞ng nh·ªè cho c√°c nhu c·∫ßu t·ª©c th·ªùi, m·ªôt cache L2 l·ªõn h∆°n v√† ch·∫≠m h∆°n m·ªôt ch√∫t, v√† m·ªôt cache L3 th·∫≠m ch√≠ c√≤n l·ªõn h∆°n v√† ch·∫≠m h∆°n, t·∫°o ra s·ª± c√¢n b·∫±ng t·ªët gi·ªØa t·ªëc ƒë·ªô truy c·∫≠p, k√≠ch th∆∞·ªõc v√† chi ph√≠."
        }
    },
    {
        "id": 85,
        "en": {
            "question": "If the address received when accessing the cache consists of Tag, Line, and Word. At that moment, what is the mapping technique the system is using?",
            "options": [
                "A. Direct mapping",
                "B. Set-direct mapping",
                "C. Associative mapping",
                "D. Set-associative mapping"
            ],
            "answer": "A. Direct mapping",
            "explanation": "The address format of (Tag, Line, Word) is characteristic of a direct-mapped cache. In set-associative mapping, the 'Line' field would be called the 'Set' field."
        },
        "vi": {
            "question": "N·∫øu ƒë·ªãa ch·ªâ nh·∫≠n ƒë∆∞·ª£c khi truy c·∫≠p b·ªô nh·ªõ ƒë·ªám bao g·ªìm Tag, Line, Word. V√†o th·ªùi ƒëi·ªÉm ƒë√≥, k·ªπ thu·∫≠t √°nh x·∫° m√† h·ªá th·ªëng ƒëang s·ª≠ d·ª•ng l√† g√¨?",
            "options": [
                "A. √Ånh x·∫° tr·ª±c ti·∫øp (Direct mapping)",
                "B. √Ånh x·∫° tr·ª±c ti·∫øp t·∫≠p h·ª£p (Set-direct mapping)",
                "C. √Ånh x·∫° k·∫øt h·ª£p (Associative mapping)",
                "D. √Ånh x·∫° k·∫øt h·ª£p t·∫≠p h·ª£p (Set-associative mapping)"
            ],
            "answer": "A. √Ånh x·∫° tr·ª±c ti·∫øp (Direct mapping)",
            "explanation": "ƒê·ªãnh d·∫°ng ƒë·ªãa ch·ªâ (Tag, Line, Word) l√† ƒë·∫∑c tr∆∞ng c·ªßa b·ªô ƒë·ªám √°nh x·∫° tr·ª±c ti·∫øp. Trong √°nh x·∫° k·∫øt h·ª£p t·∫≠p h·ª£p, tr∆∞·ªùng 'Line' s·∫Ω ƒë∆∞·ª£c g·ªçi l√† tr∆∞·ªùng 'Set'."
        }
    },
    {
        "id": 86,
        "en": {
            "question": "Consider a machine with a 2^16 byte byte-addressable main memory and a block size of 8 bytes. Assume a direct mapped cache consisting of 32 lines is used with this machine. How many bits are in the line field of the cache?",
            "options": [
                "A. 3",
                "B. 4",
                "C. 5",
                "D. 6"
            ],
            "answer": "C. 5",
            "explanation": "The number of lines in the cache is 32. The number of bits needed to uniquely identify one of these lines is log2(32), which is 5. Therefore, the line field has 5 bits."
        },
        "vi": {
            "question": "Xem x√©t m·ªôt m√°y c√≥ b·ªô nh·ªõ ch√≠nh 2^16 byte c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ theo byte v√† k√≠ch th∆∞·ªõc kh·ªëi 8 byte. Gi·∫£ s·ª≠ m·ªôt b·ªô ƒë·ªám √°nh x·∫° tr·ª±c ti·∫øp bao g·ªìm 32 d√≤ng ƒë∆∞·ª£c s·ª≠ d·ª•ng v·ªõi m√°y n√†y. C√≥ bao nhi√™u bit trong tr∆∞·ªùng d√≤ng (line field) c·ªßa b·ªô ƒë·ªám?",
            "options": [
                "A. 3",
                "B. 4",
                "C. 5",
                "D. 6"
            ],
            "answer": "C. 5",
            "explanation": "S·ªë l∆∞·ª£ng d√≤ng trong cache l√† 32. S·ªë bit c·∫ßn thi·∫øt ƒë·ªÉ x√°c ƒë·ªãnh duy nh·∫•t m·ªôt trong c√°c d√≤ng n√†y l√† log2(32), t·ª©c l√† 5. Do ƒë√≥, tr∆∞·ªùng d√≤ng c√≥ 5 bit."
        }
    },
    {
        "id": 87,
        "en": {
            "question": "In a direct mapping method from a 256MB main memory with a 512KB cache, what is the number of bits for the TAG element in the address?",
            "options": [
                "A. 6",
                "B. 7",
                "C. 8",
                "D. 9"
            ],
            "answer": "D. 9",
            "explanation": "Main Memory size = 256MB = 2^28 bytes. Cache size = 512KB = 2^19 bytes. The number of bits for the address is 28. The number of bits for the (Line + Word) fields is determined by the cache size, which is 19. Therefore, Tag bits = Total bits - (Line + Word) bits = 28 - 19 = 9 bits."
        },
        "vi": {
            "question": "Trong ph∆∞∆°ng ph√°p √°nh x·∫° tr·ª±c ti·∫øp t·ª´ b·ªô nh·ªõ ch√≠nh 256MB v·ªõi b·ªô ƒë·ªám 512KB, s·ªë bit cho ph·∫ßn t·ª≠ TAG trong ƒë·ªãa ch·ªâ l√† bao nhi√™u?",
            "options": [
                "A. 6",
                "B. 7",
                "C. 8",
                "D. 9"
            ],
            "answer": "D. 9",
            "explanation": "K√≠ch th∆∞·ªõc b·ªô nh·ªõ ch√≠nh = 256MB = 2^28 byte. K√≠ch th∆∞·ªõc cache = 512KB = 2^19 byte. S·ªë bit cho ƒë·ªãa ch·ªâ l√† 28. S·ªë bit cho c√°c tr∆∞·ªùng (Line + Word) ƒë∆∞·ª£c x√°c ƒë·ªãnh b·ªüi k√≠ch th∆∞·ªõc cache, l√† 19. Do ƒë√≥, s·ªë bit Tag = T·ªïng s·ªë bit - (Line + Word) = 28 - 19 = 9 bit."
        }
    },
    {
        "id": 88,
        "en": {
            "question": "A two-way set associative cache has lines of 16 bytes and a total size of 8 Kbytes. The 64 Mbyte main memory is byte addressable. What are the values of the Tag, Set, and Byte offset fields?",
            "options": [
                "A. 14/8/4",
                "B. 16/6/4",
                "C. 12/10/4",
                "D. 15/7/4"
            ],
            "answer": "A. 14/8/4",
            "explanation": "Byte Offset = log2(line size) = log2(16) = 4 bits. Number of lines = 8KB / 16B = 512 lines. Number of sets = 512 lines / 2 (two-way) = 256 sets. Set bits = log2(256) = 8 bits. Main memory size = 64MB = 2^26 bytes, so total address is 26 bits. Tag bits = 26 - 8 (Set) - 4 (Offset) = 14 bits. Result: Tag=14, Set=8, Offset=4."
        },
        "vi": {
            "question": "M·ªôt b·ªô ƒë·ªám k·∫øt h·ª£p t·∫≠p h·ª£p hai chi·ªÅu c√≥ c√°c d√≤ng 16 byte v√† t·ªïng k√≠ch th∆∞·ªõc 8 Kbyte. B·ªô nh·ªõ ch√≠nh 64 Mbyte c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ theo byte. C√°c gi√° tr·ªã c·ªßa c√°c tr∆∞·ªùng Tag, Set v√† Byte offset l√† g√¨?",
            "options": [
                "A. 14/8/4",
                "B. 16/6/4",
                "C. 12/10/4",
                "D. 15/7/4"
            ],
            "answer": "A. 14/8/4",
            "explanation": "Byte Offset = log2(k√≠ch th∆∞·ªõc d√≤ng) = log2(16) = 4 bit. S·ªë d√≤ng = 8KB / 16B = 512 d√≤ng. S·ªë t·∫≠p h·ª£p (Set) = 512 d√≤ng / 2 (hai chi·ªÅu) = 256 t·∫≠p. S·ªë bit Set = log2(256) = 8 bit. K√≠ch th∆∞·ªõc b·ªô nh·ªõ ch√≠nh = 64MB = 2^26 byte, v·∫≠y t·ªïng ƒë·ªãa ch·ªâ l√† 26 bit. S·ªë bit Tag = 26 - 8 (Set) - 4 (Offset) = 14 bit. K·∫øt qu·∫£: Tag=14, Set=8, Offset=4."
        }
    },
    {
        "id": 89,
        "en": {
            "question": "A set-associative cache consists of 64 lines, divided into four-line sets. The 2^19 word main memory contains 4K blocks of 128 words each. How many bits are in the tag field of the cache?",
            "options": [
                "A. 5",
                "B. 6",
                "C. 7",
                "D. 8"
            ],
            "answer": "D. 8",
            "explanation": "Number of sets = 64 lines / 4 lines/set = 16 sets. Set bits = log2(16) = 4 bits. Word offset bits = log2(128 words) = 7 bits. Total main memory address bits = 19 bits. Tag bits = Total bits - Set bits - Word bits = 19 - 4 - 7 = 8 bits."
        },
        "vi": {
            "question": "M·ªôt b·ªô ƒë·ªám k·∫øt h·ª£p t·∫≠p h·ª£p bao g·ªìm 64 d√≤ng, ƒë∆∞·ª£c chia th√†nh c√°c t·∫≠p h·ª£p b·ªën d√≤ng. B·ªô nh·ªõ ch√≠nh 2^19 t·ª´ ch·ª©a c√°c kh·ªëi 4K g·ªìm 128 t·ª´ m·ªói kh·ªëi. C√≥ bao nhi√™u bit trong tr∆∞·ªùng th·∫ª (tag field) c·ªßa b·ªô ƒë·ªám?",
            "options": [
                "A. 5",
                "B. 6",
                "C. 7",
                "D. 8"
            ],
            "answer": "D. 8",
            "explanation": "S·ªë t·∫≠p h·ª£p = 64 d√≤ng / 4 d√≤ng/t·∫≠p = 16 t·∫≠p. S·ªë bit Set = log2(16) = 4 bit. S·ªë bit Word offset = log2(128 t·ª´) = 7 bit. T·ªïng s·ªë bit ƒë·ªãa ch·ªâ b·ªô nh·ªõ ch√≠nh = 19 bit. S·ªë bit Tag = T·ªïng s·ªë bit - Set - Word = 19 - 4 - 7 = 8 bit."
        }
    },
    {
        "id": 90,
        "en": {
            "question": "A ____ memory miss occurs if an accessed word is not found in the faster memory.",
            "options": [
                "A. miss",
                "B. hit",
                "C. line",
                "D. tag"
            ],
            "answer": "A. miss",
            "explanation": "A cache miss is the event where the requested data is not found in the cache, forcing the processor to fetch it from the slower main memory."
        },
        "vi": {
            "question": "M·ªôt ____ b·ªô nh·ªõ x·∫£y ra n·∫øu m·ªôt t·ª´ ƒë∆∞·ª£c truy c·∫≠p kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong b·ªô nh·ªõ nhanh h∆°n.",
            "options": [
                "A. miss (tr∆∞·ª£t)",
                "B. hit (tr√∫ng)",
                "C. line (d√≤ng)",
                "D. tag (th·∫ª)"
            ],
            "answer": "A. miss (tr∆∞·ª£t)",
            "explanation": "Cache miss l√† s·ª± ki·ªán m√† d·ªØ li·ªáu ƒë∆∞·ª£c y√™u c·∫ßu kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong cache, bu·ªôc b·ªô x·ª≠ l√Ω ph·∫£i t√¨m n·∫°p n√≥ t·ª´ b·ªô nh·ªõ ch√≠nh ch·∫≠m h∆°n."
        }
    },
    {
        "id": 91,
        "en": {
            "question": "A line consists of a ____ which identifies which particular block is currently being stored.",
            "options": [
                "A. hit",
                "B. tag",
                "C. cache",
                "D. locality"
            ],
            "answer": "B. tag",
            "explanation": "The tag is a portion of the memory address stored in the cache line that uniquely identifies which block of main memory is currently occupying that line."
        },
        "vi": {
            "question": "M·ªôt d√≤ng bao g·ªìm m·ªôt ____ x√°c ƒë·ªãnh kh·ªëi c·ª• th·ªÉ n√†o hi·ªán ƒëang ƒë∆∞·ª£c l∆∞u tr·ªØ.",
            "options": [
                "A. hit",
                "B. tag",
                "C. cache",
                "D. locality"
            ],
            "answer": "B. tag",
            "explanation": "Th·∫ª (tag) l√† m·ªôt ph·∫ßn c·ªßa ƒë·ªãa ch·ªâ b·ªô nh·ªõ ƒë∆∞·ª£c l∆∞u tr·ªØ trong d√≤ng cache, x√°c ƒë·ªãnh duy nh·∫•t kh·ªëi n√†o c·ªßa b·ªô nh·ªõ ch√≠nh hi·ªán ƒëang chi·∫øm gi·ªØ d√≤ng ƒë√≥."
        }
    },
    {
        "id": 92,
        "en": {
            "question": "The correspondence between main memory blocks and blocks in the cache is specified by the ____.",
            "options": [
                "A. Miss penalty",
                "B. Mapping function",
                "C. Replacement algorithm",
                "D. Hit rate"
            ],
            "answer": "B. Mapping function",
            "explanation": "The mapping function (e.g., direct, associative, set-associative) determines where a block from main memory can be placed in the cache."
        },
        "vi": {
            "question": "S·ª± t∆∞∆°ng ·ª©ng gi·ªØa c√°c kh·ªëi b·ªô nh·ªõ ch√≠nh v√† c√°c kh·ªëi trong b·ªô ƒë·ªám ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh b·ªüi ____.",
            "options": [
                "A. Miss penalty (Chi ph√≠ tr∆∞·ª£t)",
                "B. H√†m √°nh x·∫° (Mapping function)",
                "C. Thu·∫≠t to√°n thay th·∫ø (Replacement algorithm)",
                "D. T·ª∑ l·ªá tr√∫ng (Hit rate)"
            ],
            "answer": "B. H√†m √°nh x·∫° (Mapping function)",
            "explanation": "H√†m √°nh x·∫° (v√≠ d·ª•: tr·ª±c ti·∫øp, k·∫øt h·ª£p, k·∫øt h·ª£p t·∫≠p h·ª£p) x√°c ƒë·ªãnh n∆°i m·ªôt kh·ªëi t·ª´ b·ªô nh·ªõ ch√≠nh c√≥ th·ªÉ ƒë∆∞·ª£c ƒë·∫∑t trong cache."
        }
    },
    {
        "id": 93,
        "en": {
            "question": "The ____ main advantage is that it eliminates contention for the cache between the instruction fetch/decode unit and the execution unit.",
            "options": [
                "A. logical cache",
                "B. split cache",
                "C. unified cache",
                "D. physical cache"
            ],
            "answer": "B. split cache",
            "explanation": "A split cache (separate caches for instructions and data, common for L1) allows the instruction fetcher and the data access unit to access the cache simultaneously without conflict."
        },
        "vi": {
            "question": "∆Øu ƒëi·ªÉm ch√≠nh c·ªßa thi·∫øt k·∫ø ____ l√† n√≥ lo·∫°i b·ªè s·ª± tranh ch·∫•p cho cache gi·ªØa ƒë∆°n v·ªã t√¨m n·∫°p/gi·∫£i m√£ l·ªánh v√† ƒë∆°n v·ªã th·ª±c thi.",
            "options": [
                "A. cache logic",
                "B. cache chia (split cache)",
                "C. cache h·ª£p nh·∫•t",
                "D. cache v·∫≠t l√Ω"
            ],
            "answer": "B. cache chia (split cache)",
            "explanation": "M·ªôt cache chia (cache ri√™ng cho l·ªánh v√† d·ªØ li·ªáu, ph·ªï bi·∫øn cho L1) cho ph√©p b·ªô t√¨m n·∫°p l·ªánh v√† ƒë∆°n v·ªã truy c·∫≠p d·ªØ li·ªáu truy c·∫≠p cache ƒë·ªìng th·ªùi m√† kh√¥ng c√≥ xung ƒë·ªôt."
        }
    },
    {
        "id": 94,
        "en": {
            "question": "The ____ component of the Pentium 4 executes micro-operations, fetching the required data from the L1 data cache and temporarily storing results in registers.",
            "options": [
                "A. fetch/decode unit",
                "B. out-of-order execution logic",
                "C. execution unit",
                "D. memory subsystem"
            ],
            "answer": "C. execution unit",
            "explanation": "The execution unit is the part of the processor that contains the ALUs and other functional units that perform the actual computations specified by the instructions."
        },
        "vi": {
            "question": "Th√†nh ph·∫ßn ____ c·ªßa Pentium 4 th·ª±c thi c√°c vi ho·∫°t ƒë·ªông, t√¨m n·∫°p d·ªØ li·ªáu c·∫ßn thi·∫øt t·ª´ cache d·ªØ li·ªáu L1 v√† t·∫°m th·ªùi l∆∞u tr·ªØ k·∫øt qu·∫£ trong c√°c thanh ghi.",
            "options": [
                "A. ƒë∆°n v·ªã t√¨m n·∫°p/gi·∫£i m√£",
                "B. logic th·ª±c thi ngo√†i th·ª© t·ª±",
                "C. ƒë∆°n v·ªã th·ª±c thi (execution unit)",
                "D. h·ªá th·ªëng con b·ªô nh·ªõ"
            ],
            "answer": "C. ƒë∆°n v·ªã th·ª±c thi (execution unit)",
            "explanation": "ƒê∆°n v·ªã th·ª±c thi l√† b·ªô ph·∫≠n c·ªßa b·ªô x·ª≠ l√Ω ch·ª©a c√°c ALU v√† c√°c ƒë∆°n v·ªã ch·ª©c nƒÉng kh√°c th·ª±c hi·ªán c√°c t√≠nh to√°n th·ª±c t·∫ø ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh b·ªüi c√°c l·ªánh."
        }
    },
    {
        "id": 95,
        "en": {
            "question": "A logical cache stores data using ____.",
            "options": [
                "A. physical addresses",
                "B. virtual addresses",
                "C. random addresses",
                "D. none of the above"
            ],
            "answer": "B. virtual addresses",
            "explanation": "A logical cache (or virtual cache) is indexed and tagged with virtual addresses, allowing it to be checked before the Memory Management Unit (MMU) performs the virtual-to-physical address translation."
        },
        "vi": {
            "question": "M·ªôt cache logic l∆∞u tr·ªØ d·ªØ li·ªáu b·∫±ng c√°ch s·ª≠ d·ª•ng ____.",
            "options": [
                "A. ƒë·ªãa ch·ªâ v·∫≠t l√Ω",
                "B. ƒë·ªãa ch·ªâ ·∫£o",
                "C. ƒë·ªãa ch·ªâ ng·∫´u nhi√™n",
                "D. kh√¥ng c√≥ c√°i n√†o ·ªü tr√™n"
            ],
            "answer": "B. ƒë·ªãa ch·ªâ ·∫£o",
            "explanation": "M·ªôt cache logic (ho·∫∑c cache ·∫£o) ƒë∆∞·ª£c l·∫≠p ch·ªâ m·ª•c v√† g·∫Øn th·∫ª b·∫±ng c√°c ƒë·ªãa ch·ªâ ·∫£o, cho ph√©p n√≥ ƒë∆∞·ª£c ki·ªÉm tra tr∆∞·ªõc khi ƒê∆°n v·ªã qu·∫£n l√Ω b·ªô nh·ªõ (MMU) th·ª±c hi·ªán vi·ªác d·ªãch ƒë·ªãa ch·ªâ ·∫£o sang v·∫≠t l√Ω."
        }
    },
    {
        "id": 96,
        "en": {
            "question": "It has become possible to have a cache on the same chip as the processor.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "On-chip cache (L1, L2, and often L3) is standard in all modern processors, as it dramatically reduces memory access latency."
        },
        "vi": {
            "question": "ƒê√£ c√≥ th·ªÉ c√≥ m·ªôt cache tr√™n c√πng m·ªôt chip v·ªõi b·ªô x·ª≠ l√Ω.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Cache tr√™n chip (L1, L2, v√† th∆∞·ªùng l√† L3) l√† ti√™u chu·∫©n trong t·∫•t c·∫£ c√°c b·ªô x·ª≠ l√Ω hi·ªán ƒë·∫°i, v√¨ n√≥ l√†m gi·∫£m ƒë√°ng k·ªÉ ƒë·ªô tr·ªÖ truy c·∫≠p b·ªô nh·ªõ."
        }
    },
    {
        "id": 97,
        "en": {
            "question": "All Pentium processors include two on-chip L1 caches, one for data and one for instructions.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Starting with the Pentium, a split L1 cache (one for instructions and one for data) became a standard feature of Intel's high-performance processors to reduce contention."
        },
        "vi": {
            "question": "T·∫•t c·∫£ c√°c b·ªô x·ª≠ l√Ω Pentium bao g·ªìm hai cache L1 tr√™n chip, m·ªôt cho d·ªØ li·ªáu v√† m·ªôt cho l·ªánh.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "B·∫Øt ƒë·∫ßu t·ª´ Pentium, m·ªôt cache L1 chia (m·ªôt cho l·ªánh v√† m·ªôt cho d·ªØ li·ªáu) ƒë√£ tr·ªü th√†nh m·ªôt t√≠nh nƒÉng ti√™u chu·∫©n c·ªßa c√°c b·ªô x·ª≠ l√Ω hi·ªáu su·∫•t cao c·ªßa Intel ƒë·ªÉ gi·∫£m s·ª± tranh ch·∫•p."
        }
    },
    {
        "id": 98,
        "en": {
            "question": "The cache design for HPC is the same as for other hardware platforms and applications.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "High-Performance Computing (HPC) often involves very large datasets and specific access patterns, which may require different cache optimization strategies (e.g., larger caches, different associativity, or specialized prefetching) compared to general-purpose computers."
        },
        "vi": {
            "question": "Thi·∫øt k·∫ø cache cho HPC gi·ªëng nh∆∞ cho c√°c n·ªÅn t·∫£ng v√† ·ª©ng d·ª•ng ph·∫ßn c·ª©ng kh√°c.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "T√≠nh to√°n hi·ªáu nƒÉng cao (HPC) th∆∞·ªùng li√™n quan ƒë·∫øn c√°c b·ªô d·ªØ li·ªáu r·∫•t l·ªõn v√† c√°c m·∫´u truy c·∫≠p c·ª• th·ªÉ, c√≥ th·ªÉ y√™u c·∫ßu c√°c chi·∫øn l∆∞·ª£c t·ªëi ∆∞u h√≥a cache kh√°c nhau (v√≠ d·ª•: cache l·ªõn h∆°n, ƒë·ªô k·∫øt h·ª£p kh√°c nhau, ho·∫∑c t√¨m n·∫°p tr∆∞·ªõc chuy√™n d·ª•ng) so v·ªõi c√°c m√°y t√≠nh ƒëa nƒÉng."
        }
    },
    {
        "id": 99,
        "en": {
            "question": "The L1 cache is slower than the L3 cache.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The memory hierarchy is organized by speed and size. L1 is the smallest and fastest, followed by L2, then L3, which are progressively larger and slower."
        },
        "vi": {
            "question": "Cache L1 ch·∫≠m h∆°n cache L3.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "H·ªá th·ªëng ph√¢n c·∫•p b·ªô nh·ªõ ƒë∆∞·ª£c t·ªï ch·ª©c theo t·ªëc ƒë·ªô v√† k√≠ch th∆∞·ªõc. L1 l√† nh·ªè nh·∫•t v√† nhanh nh·∫•t, ti·∫øp theo l√† L2, r·ªìi ƒë·∫øn L3, ch√∫ng ng√†y c√†ng l·ªõn h∆°n v√† ch·∫≠m h∆°n."
        }
    },
    {
        "id": 100,
        "en": {
            "question": "Which method of accessing units of data is used to copy a block in main memory to the cache?",
            "options": [
                "A. Direct access",
                "B. Random access",
                "C. Sequential access",
                "D. Associative"
            ],
            "answer": "D. Associative",
            "explanation": "Associative memory is a content-addressable memory where a word is retrieved based on a portion of its content (the tag) rather than its address. This is the principle behind how a cache finds data."
        },
        "vi": {
            "question": "Ph∆∞∆°ng ph√°p truy c·∫≠p c√°c ƒë∆°n v·ªã d·ªØ li·ªáu n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ sao ch√©p m·ªôt kh·ªëi trong b·ªô nh·ªõ ch√≠nh v√†o b·ªô nh·ªõ cache?",
            "options": [
                "A. Truy c·∫≠p tr·ª±c ti·∫øp (Direct access)",
                "B. Truy c·∫≠p ng·∫´u nhi√™n (Random access)",
                "C. Truy c·∫≠p tu·∫ßn t·ª± (Sequential access)",
                "D. K·∫øt h·ª£p (Associative)"
            ],
            "answer": "D. K·∫øt h·ª£p (Associative)",
            "explanation": "B·ªô nh·ªõ k·∫øt h·ª£p l√† m·ªôt b·ªô nh·ªõ c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ theo n·ªôi dung, trong ƒë√≥ m·ªôt t·ª´ ƒë∆∞·ª£c truy xu·∫•t d·ª±a tr√™n m·ªôt ph·∫ßn n·ªôi dung c·ªßa n√≥ (th·∫ª tag) ch·ª© kh√¥ng ph·∫£i ƒë·ªãa ch·ªâ c·ªßa n√≥. ƒê√¢y l√† nguy√™n t·∫Øc ƒë·∫±ng sau c√°ch cache t√¨m th·∫•y d·ªØ li·ªáu."
        }
    },
    {
        "id": 101,
        "en": {
            "question": "A prefetch buffer is a memory cache located on the RAM chip.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Modern DRAM, such as DDR SDRAM, includes a small prefetch buffer on the chip itself to fetch a block of data (e.g., 8 bits for DDR3) in a burst, improving bandwidth."
        },
        "vi": {
            "question": "B·ªô ƒë·ªám t√¨m n·∫°p tr∆∞·ªõc l√† m·ªôt cache b·ªô nh·ªõ n·∫±m tr√™n chip RAM.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "DRAM hi·ªán ƒë·∫°i, ch·∫≥ng h·∫°n nh∆∞ DDR SDRAM, bao g·ªìm m·ªôt b·ªô ƒë·ªám t√¨m n·∫°p tr∆∞·ªõc nh·ªè tr√™n ch√≠nh con chip ƒë·ªÉ t√¨m n·∫°p m·ªôt kh·ªëi d·ªØ li·ªáu (v√≠ d·ª•: 8 bit cho DDR3) trong m·ªôt l·∫ßn truy·ªÅn, c·∫£i thi·ªán bƒÉng th√¥ng."
        }
    },
{
        "id": 102,
        "en": {
            "question": "Which of these is a valid byte?",
            "options": [
                "A. 10022011",
                "B. 00-11-FF-F",
                "C. AA-AA-BB-BB",
                "D. 11011011"
            ],
            "answer": "D. 11011011",
            "explanation": "A byte is a sequence of 8 bits. Only option D represents a valid 8-bit binary number."
        },
        "vi": {
            "question": "C√°i n√†o trong s·ªë n√†y l√† m·ªôt byte h·ª£p l·ªá?",
            "options": [
                "A. 10022011",
                "B. 00-11-FF-F",
                "C. AA-AA-BB-BB",
                "D. 11011011"
            ],
            "answer": "D. 11011011",
            "explanation": "M·ªôt byte l√† m·ªôt chu·ªói g·ªìm 8 bit. Ch·ªâ c√≥ ph∆∞∆°ng √°n D bi·ªÉu di·ªÖn m·ªôt s·ªë nh·ªã ph√¢n 8-bit h·ª£p l·ªá."
        }
    },
    {
        "id": 103,
        "en": {
            "question": "Which of the following statements is invalid regarding RAM?",
            "options": [
                "A. Both static and dynamic RAM are volatile; that is, power must be continuously supplied to the memory to preserve the bit values.",
                "B. A dynamic memory cell is simpler and smaller than a static memory cell.",
                "C. Both static and dynamic RAM require supporting refresh circuitry.",
                "D. SRAM is somewhat faster than DRAM."
            ],
            "answer": "C. Both static and dynamic RAM require supporting refresh circuitry.",
            "explanation": "This statement is invalid because only Dynamic RAM (DRAM) requires refresh circuitry to prevent the capacitors from losing their charge. Static RAM (SRAM) uses flip-flops which hold their state as long as power is supplied and do not need refreshing."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† kh√¥ng h·ª£p l·ªá v·ªÅ RAM?",
            "options": [
                "A. C·∫£ RAM tƒ©nh v√† ƒë·ªông ƒë·ªÅu l√† b·ªô nh·ªõ kh·∫£ bi·∫øn; nghƒ©a l√†, ngu·ªìn ƒëi·ªán ph·∫£i ƒë∆∞·ª£c cung c·∫•p li√™n t·ª•c cho b·ªô nh·ªõ ƒë·ªÉ b·∫£o to√†n c√°c gi√° tr·ªã bit.",
                "B. M·ªôt √¥ nh·ªõ ƒë·ªông ƒë∆°n gi·∫£n v√† nh·ªè h∆°n m·ªôt √¥ nh·ªõ tƒ©nh.",
                "C. C·∫£ RAM tƒ©nh v√† ƒë·ªông ƒë·ªÅu y√™u c·∫ßu m·∫°ch l√†m m·ªõi h·ªó tr·ª£.",
                "D. SRAM nhanh h∆°n m·ªôt ch√∫t so v·ªõi DRAM."
            ],
            "answer": "C. C·∫£ RAM tƒ©nh v√† ƒë·ªông ƒë·ªÅu y√™u c·∫ßu m·∫°ch l√†m m·ªõi h·ªó tr·ª£.",
            "explanation": "Ph√°t bi·ªÉu n√†y kh√¥ng h·ª£p l·ªá v√¨ ch·ªâ c√≥ RAM ƒë·ªông (DRAM) y√™u c·∫ßu m·∫°ch l√†m m·ªõi ƒë·ªÉ ngƒÉn c√°c t·ª• ƒëi·ªán m·∫•t ƒëi·ªán t√≠ch. RAM tƒ©nh (SRAM) s·ª≠ d·ª•ng flip-flop gi·ªØ tr·∫°ng th√°i mi·ªÖn l√† c√≥ ngu·ªìn ƒëi·ªán v√† kh√¥ng c·∫ßn l√†m m·ªõi."
        }
    },
    {
        "id": 104,
        "en": {
            "question": "What is the main advantage of double-data-rate SDRAM (DDR SDRAM) over standard SDRAM?",
            "options": [
                "A. It has a larger memory capacity.",
                "B. It can send data twice per clock cycle.",
                "C. It uses less power than SDRAM.",
                "D. It is only compatible with desktop computers."
            ],
            "answer": "B. It can send data twice per clock cycle.",
            "explanation": "The 'Double Data Rate' name comes from its ability to transfer data on both the rising and falling edges of the clock signal, effectively doubling the data rate without increasing the clock frequency."
        },
        "vi": {
            "question": "L·ª£i th·∫ø ch√≠nh c·ªßa SDRAM t·ªëc ƒë·ªô d·ªØ li·ªáu k√©p (double-data-rate SDRAM) so v·ªõi SDRAM ti√™u chu·∫©n l√† g√¨?",
            "options": [
                "A. N√≥ c√≥ dung l∆∞·ª£ng b·ªô nh·ªõ l·ªõn h∆°n.",
                "B. N√≥ c√≥ th·ªÉ g·ª≠i d·ªØ li·ªáu hai l·∫ßn m·ªói chu k·ª≥ xung nh·ªãp.",
                "C. N√≥ s·ª≠ d·ª•ng √≠t nƒÉng l∆∞·ª£ng h∆°n SDRAM.",
                "D. N√≥ ch·ªâ t∆∞∆°ng th√≠ch v·ªõi m√°y t√≠nh ƒë·ªÉ b√†n."
            ],
            "answer": "B. N√≥ c√≥ th·ªÉ g·ª≠i d·ªØ li·ªáu hai l·∫ßn m·ªói chu k·ª≥ xung nh·ªãp.",
            "explanation": "T√™n 'T·ªëc ƒë·ªô d·ªØ li·ªáu k√©p' xu·∫•t ph√°t t·ª´ kh·∫£ nƒÉng truy·ªÅn d·ªØ li·ªáu ·ªü c·∫£ s∆∞·ªùn l√™n v√† s∆∞·ªùn xu·ªëng c·ªßa t√≠n hi·ªáu xung nh·ªãp, th·ª±c s·ª± nh√¢n ƒë√¥i t·ªëc ƒë·ªô d·ªØ li·ªáu m√† kh√¥ng c·∫ßn tƒÉng t·∫ßn s·ªë xung nh·ªãp."
        }
    },
    {
        "id": 105,
        "en": {
            "question": "Which memory has the fastest speed and smallest capacity?",
            "options": [
                "A. Cache",
                "B. Main memory",
                "C. HDD",
                "D. Magnetic Disk"
            ],
            "answer": "A. Cache",
            "explanation": "In the memory hierarchy, cache memory is the fastest and closest to the CPU, but also has the smallest capacity and is the most expensive per bit."
        },
        "vi": {
            "question": "B·ªô nh·ªõ n√†o c√≥ t·ªëc ƒë·ªô nhanh nh·∫•t v√† dung l∆∞·ª£ng nh·ªè nh·∫•t?",
            "options": [
                "A. Cache",
                "B. B·ªô nh·ªõ ch√≠nh (Main memory)",
                "C. HDD",
                "D. ƒêƒ©a t·ª´ (Magnetic Disk)"
            ],
            "answer": "A. Cache",
            "explanation": "Trong h·ªá th·ªëng ph√¢n c·∫•p b·ªô nh·ªõ, b·ªô nh·ªõ cache l√† nhanh nh·∫•t v√† g·∫ßn CPU nh·∫•t, nh∆∞ng c≈©ng c√≥ dung l∆∞·ª£ng nh·ªè nh·∫•t v√† ƒë·∫Øt nh·∫•t tr√™n m·ªói bit."
        }
    },
    {
        "id": 106,
        "en": {
            "question": "What is the difference between Synchronous DRAM (SDRAM) and Dynamic RAM (DRAM) in terms of performance?",
            "options": [
                "A. DRAM uses a buffer to improve speed, whereas SDRAM does not.",
                "B. SDRAM is synchronized with the system clock, allowing for faster and more reliable data transfers.",
                "C. SDRAM is non-volatile, whereas DRAM stores data unstably.",
                "D. SDRAM is asynchronous, which makes it faster in data transfer."
            ],
            "answer": "B. SDRAM is synchronized with the system clock, allowing for faster and more reliable data transfers.",
            "explanation": "The 'S' in SDRAM stands for Synchronous. By synchronizing its operations with the system clock, it can handle data transfers in a more controlled and high-speed manner compared to older asynchronous DRAM."
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát ch√≠nh gi·ªØa Synchronous DRAM (SDRAM) v√† Dynamic RAM (DRAM) v·ªÅ hi·ªáu su·∫•t l√† g√¨?",
            "options": [
                "A. DRAM s·ª≠ d·ª•ng b·ªô ƒë·ªám ƒë·ªÉ c·∫£i thi·ªán t·ªëc ƒë·ªô, trong khi SDRAM th√¨ kh√¥ng.",
                "B. SDRAM ƒë∆∞·ª£c ƒë·ªìng b·ªô h√≥a v·ªõi ƒë·ªìng h·ªì h·ªá th·ªëng, cho ph√©p truy·ªÅn d·ªØ li·ªáu nhanh h∆°n v√† ƒë√°ng tin c·∫≠y h∆°n.",
                "C. SDRAM l√† b·ªô nh·ªõ b·∫•t bi·∫øn, trong khi DRAM l∆∞u tr·ªØ d·ªØ li·ªáu kh√¥ng ·ªïn ƒë·ªãnh.",
                "D. SDRAM kh√¥ng ƒë·ªìng b·ªô, gi√∫p n√≥ nhanh h∆°n trong vi·ªác truy·ªÅn d·ªØ li·ªáu."
            ],
            "answer": "B. SDRAM ƒë∆∞·ª£c ƒë·ªìng b·ªô h√≥a v·ªõi ƒë·ªìng h·ªì h·ªá th·ªëng, cho ph√©p truy·ªÅn d·ªØ li·ªáu nhanh h∆°n v√† ƒë√°ng tin c·∫≠y h∆°n.",
            "explanation": "Ch·ªØ 'S' trong SDRAM l√† vi·∫øt t·∫Øt c·ªßa Synchronous (ƒê·ªìng b·ªô). B·∫±ng c√°ch ƒë·ªìng b·ªô h√≥a c√°c ho·∫°t ƒë·ªông c·ªßa n√≥ v·ªõi ƒë·ªìng h·ªì h·ªá th·ªëng, n√≥ c√≥ th·ªÉ x·ª≠ l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu m·ªôt c√°ch c√≥ ki·ªÉm so√°t v√† t·ªëc ƒë·ªô cao h∆°n so v·ªõi DRAM kh√¥ng ƒë·ªìng b·ªô c≈© h∆°n."
        }
    },
    {
        "id": 107,
        "en": {
            "question": "How does Dynamic RAM (DRAM) differ from static RAM (SRAM) in performance and usage?",
            "options": [
                "A. DRAM has a larger storage capacity than SRAM but is less reliable.",
                "B. DRAM is faster but consumes more power.",
                "C. DRAM stores data in capacitors that need to be refreshed periodically, while SRAM uses flip-flops and doesn't need refreshing.",
                "D. DRAM is more expensive than SRAM because it uses complex transistors for storage."
            ],
            "answer": "C. DRAM stores data in capacitors that need to be refreshed periodically, while SRAM uses flip-flops and doesn't need refreshing.",
            "explanation": "This is the fundamental difference. DRAM's capacitor-based cells are simple and dense (allowing for large capacities like in main memory) but require constant refreshing. SRAM's flip-flop-based cells are much faster and don't need refreshing (used for cache) but are larger and more expensive."
        },
        "vi": {
            "question": "Dynamic RAM (DRAM) kh√°c v·ªõi static RAM (SRAM) v·ªÅ hi·ªáu su·∫•t v√† c√°ch s·ª≠ d·ª•ng nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. DRAM c√≥ dung l∆∞·ª£ng l∆∞u tr·ªØ l·ªõn h∆°n SRAM nh∆∞ng k√©m tin c·∫≠y h∆°n.",
                "B. DRAM nhanh h∆°n nh∆∞ng ti√™u th·ª• nhi·ªÅu nƒÉng l∆∞·ª£ng h∆°n.",
                "C. DRAM l∆∞u tr·ªØ d·ªØ li·ªáu trong c√°c t·ª• ƒëi·ªán c·∫ßn ƒë∆∞·ª£c l√†m m·ªõi th∆∞·ªùng xuy√™n, trong khi SRAM s·ª≠ d·ª•ng c√°c flip-flop v√† kh√¥ng c·∫ßn l√†m m·ªõi.",
                "D. DRAM ƒë·∫Øt h∆°n SRAM v√¨ n√≥ s·ª≠ d·ª•ng c√°c b√≥ng b√°n d·∫´n ph·ª©c t·∫°p ƒë·ªÉ l∆∞u tr·ªØ."
            ],
            "answer": "C. DRAM l∆∞u tr·ªØ d·ªØ li·ªáu trong c√°c t·ª• ƒëi·ªán c·∫ßn ƒë∆∞·ª£c l√†m m·ªõi th∆∞·ªùng xuy√™n, trong khi SRAM s·ª≠ d·ª•ng c√°c flip-flop v√† kh√¥ng c·∫ßn l√†m m·ªõi.",
            "explanation": "ƒê√¢y l√† s·ª± kh√°c bi·ªát c∆° b·∫£n. C√°c √¥ nh·ªõ d·ª±a tr√™n t·ª• ƒëi·ªán c·ªßa DRAM ƒë∆°n gi·∫£n v√† c√≥ m·∫≠t ƒë·ªô cao (cho ph√©p dung l∆∞·ª£ng l·ªõn nh∆∞ trong b·ªô nh·ªõ ch√≠nh) nh∆∞ng y√™u c·∫ßu l√†m m·ªõi li√™n t·ª•c. C√°c √¥ nh·ªõ d·ª±a tr√™n flip-flop c·ªßa SRAM nhanh h∆°n nhi·ªÅu v√† kh√¥ng c·∫ßn l√†m m·ªõi (ƒë∆∞·ª£c s·ª≠ d·ª•ng cho cache) nh∆∞ng l·ªõn h∆°n v√† ƒë·∫Øt h∆°n."
        }
    },
    {
        "id": 108,
        "en": {
            "question": "The basic element of semiconductor memory is the memory cell.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "All semiconductor memory, whether RAM or ROM, is composed of a vast array of memory cells, each capable of storing a single bit (1 or 0)."
        },
        "vi": {
            "question": "Y·∫øu t·ªë c∆° b·∫£n c·ªßa b·ªô nh·ªõ b√°n d·∫´n l√† √¥ nh·ªõ.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "T·∫•t c·∫£ b·ªô nh·ªõ b√°n d·∫´n, d√π l√† RAM hay ROM, ƒë·ªÅu ƒë∆∞·ª£c c·∫•u t·∫°o t·ª´ m·ªôt m·∫£ng l·ªõn c√°c √¥ nh·ªõ, m·ªói √¥ c√≥ kh·∫£ nƒÉng l∆∞u tr·ªØ m·ªôt bit duy nh·∫•t (1 ho·∫∑c 0)."
        }
    },
    {
        "id": 109,
        "en": {
            "question": "A characteristic of ROM is that it is volatile.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ROM stands for Read-Only Memory and is non-volatile, meaning it retains its data even when the power is turned off. RAM is volatile."
        },
        "vi": {
            "question": "M·ªôt ƒë·∫∑c t√≠nh c·ªßa ROM l√† kh·∫£ bi·∫øn.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ROM l√† vi·∫øt t·∫Øt c·ªßa Read-Only Memory (B·ªô nh·ªõ ch·ªâ ƒë·ªçc) v√† l√† b·ªô nh·ªõ b·∫•t bi·∫øn, nghƒ©a l√† n√≥ gi·ªØ l·∫°i d·ªØ li·ªáu ngay c·∫£ khi t·∫Øt ngu·ªìn. RAM m·ªõi l√† b·ªô nh·ªõ kh·∫£ bi·∫øn."
        }
    },
    {
        "id": 110,
        "en": {
            "question": "Nonvolatile RAM means that power must be continuously supplied to the memory to preserve the bit values.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "This is the definition of volatile memory. Nonvolatile memory (like ROM or Flash) retains its data without power."
        },
        "vi": {
            "question": "RAM b·∫•t bi·∫øn c√≥ nghƒ©a l√† ngu·ªìn ƒëi·ªán ph·∫£i ƒë∆∞·ª£c cung c·∫•p li√™n t·ª•c cho b·ªô nh·ªõ ƒë·ªÉ b·∫£o to√†n c√°c gi√° tr·ªã bit.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa b·ªô nh·ªõ kh·∫£ bi·∫øn (volatile). B·ªô nh·ªõ b·∫•t bi·∫øn (nh∆∞ ROM ho·∫∑c Flash) gi·ªØ l·∫°i d·ªØ li·ªáu c·ªßa n√≥ m√† kh√¥ng c·∫ßn ngu·ªìn ƒëi·ªán."
        }
    },
    {
        "id": 111,
        "en": {
            "question": "The advantage of RAM is that the data or program is permanently in main memory and never needs to be loaded from a secondary storage device.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "This is false. RAM is volatile, so its contents are lost when power is off. Programs and data must be loaded from secondary storage (like an SSD or HDD) into RAM each time the computer starts."
        },
        "vi": {
            "question": "L·ª£i th·∫ø c·ªßa RAM l√† d·ªØ li·ªáu ho·∫∑c ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ vƒ©nh vi·ªÖn trong b·ªô nh·ªõ ch√≠nh v√† kh√¥ng bao gi·ªù c·∫ßn ƒë∆∞·ª£c n·∫°p t·ª´ m·ªôt thi·∫øt b·ªã l∆∞u tr·ªØ th·ª© c·∫•p.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ƒêi·ªÅu n√†y l√† sai. RAM l√† b·ªô nh·ªõ kh·∫£ bi·∫øn, v√¨ v·∫≠y n·ªôi dung c·ªßa n√≥ b·ªã m·∫•t khi t·∫Øt ngu·ªìn. C√°c ch∆∞∆°ng tr√¨nh v√† d·ªØ li·ªáu ph·∫£i ƒë∆∞·ª£c n·∫°p t·ª´ b·ªô l∆∞u tr·ªØ th·ª© c·∫•p (nh∆∞ SSD ho·∫∑c HDD) v√†o RAM m·ªói khi m√°y t√≠nh kh·ªüi ƒë·ªông."
        }
    },
    {
        "id": 112,
        "en": {
            "question": "Semiconductor memory comes in packaged chips.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Semiconductor memory is fabricated on silicon wafers which are then cut into dies and packaged into chips with pins for connection to the motherboard."
        },
        "vi": {
            "question": "B·ªô nh·ªõ b√°n d·∫´n c√≥ trong c√°c chip ƒë√≥ng g√≥i.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "B·ªô nh·ªõ b√°n d·∫´n ƒë∆∞·ª£c ch·∫ø t·∫°o tr√™n c√°c t·∫•m wafer silicon, sau ƒë√≥ ƒë∆∞·ª£c c·∫Øt th√†nh c√°c ƒë·∫ø (die) v√† ƒë√≥ng g√≥i th√†nh c√°c con chip c√≥ ch√¢n c·∫Øm ƒë·ªÉ k·∫øt n·ªëi v·ªõi bo m·∫°ch ch·ªß."
        }
    },
    {
        "id": 113,
        "en": {
            "question": "What is the primary difference in the architecture of NOR and NAND flash memory?",
            "options": [
                "A. NOR flash memory cells are connected in series, while NAND flash memory cells are connected in parallel.",
                "B. NOR flash memory cells are connected in parallel, while NAND flash memory cells are connected in series.",
                "C. Both NOR and NAND flash memory cells are connected in series.",
                "D. Both NOR and NAND flash memory cells are connected in parallel."
            ],
            "answer": "B. NOR flash memory cells are connected in parallel, while NAND flash memory cells are connected in series.",
            "explanation": "This architectural difference is key to their characteristics. NOR's parallel connection allows for fast random access (like RAM), while NAND's series connection is denser and allows for faster sequential reads/writes (like a hard drive)."
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát ch√≠nh trong ki·∫øn tr√∫c c·ªßa b·ªô nh·ªõ flash NOR v√† NAND l√† g√¨?",
            "options": [
                "A. C√°c √¥ nh·ªõ flash NOR ƒë∆∞·ª£c k·∫øt n·ªëi n·ªëi ti·∫øp, trong khi c√°c √¥ nh·ªõ flash NAND ƒë∆∞·ª£c k·∫øt n·ªëi song song.",
                "B. C√°c √¥ nh·ªõ flash NOR ƒë∆∞·ª£c k·∫øt n·ªëi song song, trong khi c√°c √¥ nh·ªõ flash NAND ƒë∆∞·ª£c k·∫øt n·ªëi n·ªëi ti·∫øp.",
                "C. C·∫£ hai √¥ nh·ªõ flash NOR v√† NAND ƒë·ªÅu ƒë∆∞·ª£c k·∫øt n·ªëi n·ªëi ti·∫øp.",
                "D. C·∫£ hai √¥ nh·ªõ flash NOR v√† NAND ƒë·ªÅu ƒë∆∞·ª£c k·∫øt n·ªëi song song."
            ],
            "answer": "B. C√°c √¥ nh·ªõ flash NOR ƒë∆∞·ª£c k·∫øt n·ªëi song song, trong khi c√°c √¥ nh·ªõ flash NAND ƒë∆∞·ª£c k·∫øt n·ªëi n·ªëi ti·∫øp.",
            "explanation": "S·ª± kh√°c bi·ªát v·ªÅ ki·∫øn tr√∫c n√†y l√† ch√¨a kh√≥a cho c√°c ƒë·∫∑c ƒëi·ªÉm c·ªßa ch√∫ng. K·∫øt n·ªëi song song c·ªßa NOR cho ph√©p truy c·∫≠p ng·∫´u nhi√™n nhanh (gi·ªëng nh∆∞ RAM), trong khi k·∫øt n·ªëi n·ªëi ti·∫øp c·ªßa NAND c√≥ m·∫≠t ƒë·ªô cao h∆°n v√† cho ph√©p ƒë·ªçc/ghi tu·∫ßn t·ª± nhanh h∆°n (gi·ªëng nh∆∞ ·ªï c·ª©ng)."
        }
    },
    {
        "id": 114,
        "en": {
            "question": "Which of the following memory types is nonvolatile?",
            "options": [
                "A. Erasable PROM",
                "B. Programmable ROM",
                "C. flash memory",
                "D. all of the above"
            ],
            "answer": "D. all of the above",
            "explanation": "All forms of ROM (Read-Only Memory), including PROM, EPROM, EEPROM, and Flash Memory, are nonvolatile, meaning they retain data without power."
        },
        "vi": {
            "question": "Lo·∫°i b·ªô nh·ªõ n√†o sau ƒë√¢y l√† b·∫•t bi·∫øn?",
            "options": [
                "A. PROM c√≥ th·ªÉ x√≥a ƒë∆∞·ª£c (EPROM)",
                "B. ROM c√≥ th·ªÉ l·∫≠p tr√¨nh (PROM)",
                "C. b·ªô nh·ªõ flash",
                "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n"
            ],
            "answer": "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n",
            "explanation": "T·∫•t c·∫£ c√°c d·∫°ng ROM (B·ªô nh·ªõ ch·ªâ ƒë·ªçc), bao g·ªìm PROM, EPROM, EEPROM v√† B·ªô nh·ªõ Flash, ƒë·ªÅu l√† b·∫•t bi·∫øn, nghƒ©a l√† ch√∫ng gi·ªØ l·∫°i d·ªØ li·ªáu m√† kh√¥ng c·∫ßn ngu·ªìn ƒëi·ªán."
        }
    },
    {
        "id": 115,
        "en": {
            "question": "In a ____, binary values are stored using traditional flip-flop logic-gate configurations.",
            "options": [
                "A. ROM",
                "B. SRAM",
                "C. DRAM",
                "D. RAM"
            ],
            "answer": "B. SRAM",
            "explanation": "SRAM (Static RAM) uses a latching circuitry (flip-flop) made of multiple transistors to store each bit. This makes it faster but less dense than DRAM."
        },
        "vi": {
            "question": "Trong m·ªôt ____, c√°c gi√° tr·ªã nh·ªã ph√¢n ƒë∆∞·ª£c l∆∞u tr·ªØ b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c c·∫•u h√¨nh c·ªïng logic flip-flop truy·ªÅn th·ªëng.",
            "options": [
                "A. ROM",
                "B. SRAM",
                "C. DRAM",
                "D. RAM"
            ],
            "answer": "B. SRAM",
            "explanation": "SRAM (RAM tƒ©nh) s·ª≠ d·ª•ng m·ªôt m·∫°ch ch·ªët (flip-flop) ƒë∆∞·ª£c l√†m t·ª´ nhi·ªÅu b√≥ng b√°n d·∫´n ƒë·ªÉ l∆∞u tr·ªØ m·ªói bit. ƒêi·ªÅu n√†y l√†m cho n√≥ nhanh h∆°n nh∆∞ng c√≥ m·∫≠t ƒë·ªô th·∫•p h∆°n DRAM."
        }
    },
    {
        "id": 116,
        "en": {
            "question": "With ____, the microchip is organized so that a section of memory cells are erased in a single action.",
            "options": [
                "A. flash memory",
                "B. SDRAM",
                "C. DRAM",
                "D. EEPROM"
            ],
            "answer": "A. flash memory",
            "explanation": "Flash memory is a type of EEPROM that is erased and reprogrammed in large blocks, making it faster for large write operations compared to traditional EEPROM which erases byte-by-byte."
        },
        "vi": {
            "question": "V·ªõi ____, vi m·∫°ch ƒë∆∞·ª£c t·ªï ch·ª©c sao cho m·ªôt ph·∫ßn c·ªßa c√°c √¥ nh·ªõ b·ªã x√≥a trong m·ªôt h√†nh ƒë·ªông duy nh·∫•t.",
            "options": [
                "A. b·ªô nh·ªõ flash",
                "B. SDRAM",
                "C. DRAM",
                "D. EEPROM"
            ],
            "answer": "A. b·ªô nh·ªõ flash",
            "explanation": "B·ªô nh·ªõ flash l√† m·ªôt lo·∫°i EEPROM ƒë∆∞·ª£c x√≥a v√† l·∫≠p tr√¨nh l·∫°i theo c√°c kh·ªëi l·ªõn, gi√∫p n√≥ nhanh h∆°n cho c√°c ho·∫°t ƒë·ªông ghi l·ªõn so v·ªõi EEPROM truy·ªÅn th·ªëng x√≥a t·ª´ng byte m·ªôt."
        }
    },
    {
        "id": 117,
        "en": {
            "question": "In an ECC (single Error Correcting Code), how many bits are used to correct one bit in an 8-bit data?",
            "options": [
                "A. 4",
                "B. 5",
                "C. 6",
                "D. 7"
            ],
            "answer": "A. 4",
            "explanation": "Using the formula 2^k >= m + k + 1, where m=8 (data bits) and k is the number of check bits. For k=3, 2^3=8 < 8+3+1=12 (fails). For k=4, 2^4=16 >= 8+4+1=13 (succeeds). So, 4 check bits are needed."
        },
        "vi": {
            "question": "Trong m√£ s·ª≠a l·ªói (ECC ƒë∆°n), c√≥ bao nhi√™u bit ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ s·ª≠a m·ªôt bit trong d·ªØ li·ªáu 8-bit?",
            "options": [
                "A. 4",
                "B. 5",
                "C. 6",
                "D. 7"
            ],
            "answer": "A. 4",
            "explanation": "S·ª≠ d·ª•ng c√¥ng th·ª©c 2^k >= m + k + 1, v·ªõi m=8 (bit d·ªØ li·ªáu) v√† k l√† s·ªë bit ki·ªÉm tra. V·ªõi k=3, 2^3=8 < 8+3+1=12 (kh√¥ng th·ªèa). V·ªõi k=4, 2^4=16 >= 8+4+1=13 (th·ªèa). V·∫≠y c·∫ßn 4 bit ki·ªÉm tra."
        }
    },
    {
        "id": 118,
        "en": {
            "question": "What is the main idea of using Hamming code for error correction?",
            "options": [
                "A. Add additional parity bits to the data bits so that the number of 1s in each subset of bits is even.",
                "B. Add additional parity bits to the data bits so that the number of 1s in each subset of bits is odd.",
                "C. Add additional parity bits to the data bits so that the parity bits form a binary number indicating the position of the erroneous bit.",
                "D. Add additional parity bits to the data bits so that the parity bits form a binary number indicating the number of erroneous bits."
            ],
            "answer": "C. Add additional parity bits to the data bits so that the parity bits form a binary number indicating the position of the erroneous bit.",
            "explanation": "The cleverness of Hamming code is that the combination of parity check results (the 'syndrome') directly points to the bit position that is in error, allowing for automatic correction."
        },
        "vi": {
            "question": "√ù t∆∞·ªüng ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng m√£ Hamming ƒë·ªÉ s·ª≠a l·ªói l√† g√¨?",
            "options": [
                "A. Th√™m c√°c bit ch·∫µn l·∫ª b·ªï sung v√†o c√°c bit d·ªØ li·ªáu sao cho s·ªë l∆∞·ª£ng bit 1 trong m·ªói t·∫≠p con c·ªßa c√°c bit l√† ch·∫µn.",
                "B. Th√™m c√°c bit ch·∫µn l·∫ª b·ªï sung v√†o c√°c bit d·ªØ li·ªáu sao cho s·ªë l∆∞·ª£ng bit 1 trong m·ªói t·∫≠p con c·ªßa c√°c bit l√† l·∫ª.",
                "C. Th√™m c√°c bit ch·∫µn l·∫ª b·ªï sung v√†o c√°c bit d·ªØ li·ªáu sao cho c√°c bit ch·∫µn l·∫ª t·∫°o th√†nh m·ªôt s·ªë nh·ªã ph√¢n ch·ªâ ra v·ªã tr√≠ c·ªßa bit l·ªói.",
                "D. Th√™m c√°c bit ch·∫µn l·∫ª b·ªï sung v√†o c√°c bit d·ªØ li·ªáu sao cho c√°c bit ch·∫µn l·∫ª t·∫°o th√†nh m·ªôt s·ªë nh·ªã ph√¢n ch·ªâ ra s·ªë l∆∞·ª£ng bit l·ªói."
            ],
            "answer": "C. Th√™m c√°c bit ch·∫µn l·∫ª b·ªï sung v√†o c√°c bit d·ªØ li·ªáu sao cho c√°c bit ch·∫µn l·∫ª t·∫°o th√†nh m·ªôt s·ªë nh·ªã ph√¢n ch·ªâ ra v·ªã tr√≠ c·ªßa bit l·ªói.",
            "explanation": "S·ª± th√¥ng minh c·ªßa m√£ Hamming l√† s·ª± k·∫øt h·ª£p c·ªßa c√°c k·∫øt qu·∫£ ki·ªÉm tra ch·∫µn l·∫ª ('syndrome') ch·ªâ tr·ª±c ti·∫øp ƒë·∫øn v·ªã tr√≠ bit b·ªã l·ªói, cho ph√©p s·ª≠a l·ªói t·ª± ƒë·ªông."
        }
    },
    {
        "id": 119,
        "en": {
            "question": "Why is Error Correction Code (ECC) DRAM important in high-reliability applications?",
            "options": [
                "A. It detects and corrects errors in real-time to ensure data integrity in critical systems.",
                "B. It reduces the need for additional cooling systems by using low-power systems.",
                "C. It allows for faster data retrieval by optimizing memory locations.",
                "D. It automatically adjusts memory speed to prevent data corruption."
            ],
            "answer": "A. It detects and corrects errors in real-time to ensure data integrity in critical systems.",
            "explanation": "ECC memory contains extra circuitry to detect and correct single-bit memory errors on the fly. This is crucial for servers, scientific computing, and other applications where data integrity is paramount."
        },
        "vi": {
            "question": "T·∫°i sao DRAM M√£ s·ª≠a l·ªói (ECC) l·∫°i quan tr·ªçng trong c√°c ·ª©ng d·ª•ng c√≥ ƒë·ªô tin c·∫≠y cao?",
            "options": [
                "A. N√≥ ph√°t hi·ªán v√† s·ª≠a c√°c l·ªói trong th·ªùi gian th·ª±c ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn d·ªØ li·ªáu trong c√°c h·ªá th·ªëng quan tr·ªçng.",
                "B. N√≥ l√†m gi·∫£m nhu c·∫ßu v·ªÅ c√°c h·ªá th·ªëng l√†m m√°t b·ªï sung b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c h·ªá th·ªëng nƒÉng l∆∞·ª£ng th·∫•p.",
                "C. N√≥ cho ph√©p truy xu·∫•t d·ªØ li·ªáu nhanh h∆°n b·∫±ng c√°ch t·ªëi ∆∞u h√≥a c√°c v·ªã tr√≠ b·ªô nh·ªõ.",
                "D. N√≥ t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô b·ªô nh·ªõ ƒë·ªÉ ngƒÉn ng·ª´a h·ªèng d·ªØ li·ªáu."
            ],
            "answer": "A. N√≥ ph√°t hi·ªán v√† s·ª≠a c√°c l·ªói trong th·ªùi gian th·ª±c ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn d·ªØ li·ªáu trong c√°c h·ªá th·ªëng quan tr·ªçng.",
            "explanation": "B·ªô nh·ªõ ECC ch·ª©a m·∫°ch b·ªï sung ƒë·ªÉ ph√°t hi·ªán v√† s·ª≠a c√°c l·ªói b·ªô nh·ªõ ƒë∆°n bit m·ªôt c√°ch nhanh ch√≥ng. ƒêi·ªÅu n√†y r·∫•t quan tr·ªçng ƒë·ªëi v·ªõi c√°c m√°y ch·ªß, t√≠nh to√°n khoa h·ªçc v√† c√°c ·ª©ng d·ª•ng kh√°c m√† t√≠nh to√†n v·∫πn d·ªØ li·ªáu l√† t·ªëi quan tr·ªçng."
        }
    },
    {
        "id": 120,
        "en": {
            "question": "How many check bits are needed if the Hamming error correction code is used to detect single bit errors in a 128-bit data word?",
            "options": [
                "A. 6 bits",
                "B. 7 bits",
                "C. 8 bits",
                "D. 9 bits"
            ],
            "answer": "C. 8 bits",
            "explanation": "Using the formula 2^k >= m + k + 1, where m=128. For k=7, 2^7=128, but 128 is not >= 128+7+1=136. For k=8, 2^8=256, which is >= 128+8+1=137. So, 8 check bits are needed."
        },
        "vi": {
            "question": "C·∫ßn bao nhi√™u bit ki·ªÉm tra n·∫øu m√£ s·ª≠a l·ªói Hamming ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√°t hi·ªán l·ªói bit ƒë∆°n trong m·ªôt t·ª´ d·ªØ li·ªáu 128-bit?",
            "options": [
                "A. 6 bits",
                "B. 7 bits",
                "C. 8 bits",
                "D. 9 bits"
            ],
            "answer": "C. 8 bits",
            "explanation": "S·ª≠ d·ª•ng c√¥ng th·ª©c 2^k >= m + k + 1, v·ªõi m=128. V·ªõi k=7, 2^7=128, nh∆∞ng 128 kh√¥ng >= 128+7+1=136. V·ªõi k=8, 2^8=256, l·ªõn h∆°n >= 128+8+1=137. V·∫≠y c·∫ßn 8 bit ki·ªÉm tra."
        }
    },
    {
        "id": 121,
        "en": {
            "question": "How many check bits are needed for Hamming error correction code to detect and correct single errors in a 1 KByte data word?",
            "options": [
                "A. 11 bits",
                "B. 12 bits",
                "C. 13 bits",
                "D. 14 bits"
            ],
            "answer": "D. 14 bits",
            "explanation": "1 KByte = 1024 bytes = 8192 bits (m=8192). Using 2^k >= m + k + 1. For k=13, 2^13=8192, but 8192 is not >= 8192+13+1=8206. For k=14, 2^14=16384, which is >= 8192+14+1=8207. So, 14 check bits are needed."
        },
        "vi": {
            "question": "C·∫ßn bao nhi√™u bit ki·ªÉm tra cho m√£ s·ª≠a l·ªói Hamming ƒë·ªÉ ph√°t hi·ªán v√† s·ª≠a l·ªói ƒë∆°n trong m·ªôt t·ª´ d·ªØ li·ªáu 1 KByte?",
            "options": [
                "A. 11 bits",
                "B. 12 bits",
                "C. 13 bits",
                "D. 14 bits"
            ],
            "answer": "D. 14 bits",
            "explanation": "1 KByte = 1024 byte = 8192 bit (m=8192). S·ª≠ d·ª•ng c√¥ng th·ª©c 2^k >= m + k + 1. V·ªõi k=13, 2^13=8192, nh∆∞ng 8192 kh√¥ng >= 8192+13+1=8206. V·ªõi k=14, 2^14=16384, l·ªõn h∆°n >= 8192+14+1=8207. V·∫≠y c·∫ßn 14 bit ki·ªÉm tra."
        }
    },
    {
        "id": 122,
        "en": {
            "question": "____ can be caused by harsh environmental abuse, manufacturing defects, and wear.",
            "options": [
                "A. SEC errors",
                "B. Hard errors",
                "C. syndrome errors",
                "D. soft errors"
            ],
            "answer": "B. Hard errors",
            "explanation": "Hard errors are permanent physical defects in memory that cause bits to be stuck at 0 or 1, often resulting from physical damage or manufacturing flaws."
        },
        "vi": {
            "question": "____ c√≥ th·ªÉ ƒë∆∞·ª£c g√¢y ra b·ªüi l·∫°m d·ª•ng m√¥i tr∆∞·ªùng kh·∫Øc nghi·ªát, l·ªói s·∫£n xu·∫•t v√† hao m√≤n.",
            "options": [
                "A. l·ªói SEC",
                "B. l·ªói c·ª©ng (Hard errors)",
                "C. l·ªói h·ªôi ch·ª©ng",
                "D. l·ªói m·ªÅm"
            ],
            "answer": "B. l·ªói c·ª©ng (Hard errors)",
            "explanation": "L·ªói c·ª©ng l√† c√°c khuy·∫øt t·∫≠t v·∫≠t l√Ω vƒ©nh vi·ªÖn trong b·ªô nh·ªõ khi·∫øn c√°c bit b·ªã k·∫πt ·ªü 0 ho·∫∑c 1, th∆∞·ªùng do h∆∞ h·ªèng v·∫≠t l√Ω ho·∫∑c l·ªói s·∫£n xu·∫•t."
        }
    },
    {
        "id": 123,
        "en": {
            "question": "What is the primary advantage of using semiconductor memory over traditional magnetic systems?",
            "options": [
                "A. It consumes less power and generates less heat, making it ideal for mobile devices.",
                "B. It is cheaper to manufacture than other types of memory.",
                "C. It offers higher storage capacity at faster data retrieval speeds.",
                "D. It provides better long-term data retention without a power source."
            ],
            "answer": "C. It offers higher storage capacity at faster data retrieval speeds.",
            "explanation": "The key advantage of semiconductor memory (like RAM) is its extremely fast, random-access capability, which is orders of magnitude faster than magnetic storage (like HDDs)."
        },
        "vi": {
            "question": "L·ª£i th·∫ø ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng b·ªô nh·ªõ b√°n d·∫´n so v·ªõi c√°c h·ªá th·ªëng t·ª´ t√≠nh truy·ªÅn th·ªëng l√† g√¨?",
            "options": [
                "A. N√≥ ti√™u th·ª• √≠t nƒÉng l∆∞·ª£ng h∆°n v√† t·∫°o ra √≠t nhi·ªát h∆°n, l√†m cho n√≥ l√Ω t∆∞·ªüng cho c√°c thi·∫øt b·ªã di ƒë·ªông.",
                "B. N√≥ r·∫ª h∆°n ƒë·ªÉ s·∫£n xu·∫•t so v·ªõi c√°c lo·∫°i b·ªô nh·ªõ kh√°c.",
                "C. N√≥ cung c·∫•p dung l∆∞·ª£ng l∆∞u tr·ªØ cao h∆°n v·ªõi t·ªëc ƒë·ªô truy xu·∫•t d·ªØ li·ªáu nhanh h∆°n.",
                "D. N√≥ cung c·∫•p kh·∫£ nƒÉng l∆∞u gi·ªØ d·ªØ li·ªáu d√†i h·∫°n t·ªët h∆°n m√† kh√¥ng c·∫ßn ngu·ªìn ƒëi·ªán."
            ],
            "answer": "C. N√≥ cung c·∫•p dung l∆∞·ª£ng l∆∞u tr·ªØ cao h∆°n v·ªõi t·ªëc ƒë·ªô truy xu·∫•t d·ªØ li·ªáu nhanh h∆°n.",
            "explanation": "L·ª£i th·∫ø ch√≠nh c·ªßa b·ªô nh·ªõ b√°n d·∫´n (nh∆∞ RAM) l√† kh·∫£ nƒÉng truy c·∫≠p ng·∫´u nhi√™n c·ª±c nhanh, nhanh h∆°n nhi·ªÅu l·∫ßn so v·ªõi b·ªô nh·ªõ t·ª´ t√≠nh (nh∆∞ HDD)."
        }
    },
    {
        "id": 124,
        "en": {
            "question": "In 3D DRAM architecture, how does stacking memory chips improve performance?",
            "options": [
                "A. It stores data in multiple locations, ensuring higher reliability during data retrieval.",
                "B. It reduces the physical space needed for memory, increasing system compactness.",
                "C. It increases operating temperatures, allowing the memory to run at higher speeds.",
                "D. It allows for vertical memory access, reducing latency and improving overall data transfer speeds."
            ],
            "answer": "D. It allows for vertical memory access, reducing latency and improving overall data transfer speeds.",
            "explanation": "Stacking memory dies vertically and connecting them with Through-Silicon Vias (TSVs) creates much shorter, wider, and more numerous data paths, which significantly increases bandwidth and reduces latency compared to traditional planar layouts."
        },
        "vi": {
            "question": "Trong ki·∫øn tr√∫c 3D DRAM, vi·ªác x·∫øp ch·ªìng c√°c chip nh·ªõ c·∫£i thi·ªán hi·ªáu su·∫•t nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ l∆∞u tr·ªØ d·ªØ li·ªáu ·ªü nhi·ªÅu v·ªã tr√≠, ƒë·∫£m b·∫£o ƒë·ªô tin c·∫≠y cao h∆°n trong qu√° tr√¨nh truy xu·∫•t d·ªØ li·ªáu.",
                "B. N√≥ l√†m gi·∫£m kh√¥ng gian v·∫≠t l√Ω c·∫ßn thi·∫øt cho b·ªô nh·ªõ, tƒÉng ƒë·ªô g·ªçn nh·∫π c·ªßa h·ªá th·ªëng.",
                "C. N√≥ l√†m tƒÉng nhi·ªát ƒë·ªô ho·∫°t ƒë·ªông, cho ph√©p b·ªô nh·ªõ ch·∫°y ·ªü t·ªëc ƒë·ªô cao h∆°n.",
                "D. N√≥ cho ph√©p truy c·∫≠p b·ªô nh·ªõ theo chi·ªÅu d·ªçc, gi·∫£m ƒë·ªô tr·ªÖ v√† c·∫£i thi·ªán t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu t·ªïng th·ªÉ."
            ],
            "answer": "D. N√≥ cho ph√©p truy c·∫≠p b·ªô nh·ªõ theo chi·ªÅu d·ªçc, gi·∫£m ƒë·ªô tr·ªÖ v√† c·∫£i thi·ªán t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu t·ªïng th·ªÉ.",
            "explanation": "Vi·ªác x·∫øp ch·ªìng c√°c ƒë·∫ø nh·ªõ theo chi·ªÅu d·ªçc v√† k·∫øt n·ªëi ch√∫ng b·∫±ng c√°c Via xuy√™n Silicon (TSV) t·∫°o ra c√°c ƒë∆∞·ªùng d·∫´n d·ªØ li·ªáu ng·∫Øn h∆°n, r·ªông h∆°n v√† nhi·ªÅu h∆°n, gi√∫p tƒÉng ƒë√°ng k·ªÉ bƒÉng th√¥ng v√† gi·∫£m ƒë·ªô tr·ªÖ so v·ªõi b·ªë c·ª•c ph·∫≥ng truy·ªÅn th·ªëng."
        }
    },
    {
        "id": 125,
        "en": {
            "question": "EEPROM is read-only and volatile memory.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "EEPROM (Electrically Erasable Programmable Read-Only Memory) is non-volatile (retains data without power) and can be written to, not just read from."
        },
        "vi": {
            "question": "EEPROM l√† b·ªô nh·ªõ ch·ªâ ƒë·ªçc v√† kh·∫£ bi·∫øn (volatile).",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "EEPROM (B·ªô nh·ªõ ch·ªâ ƒë·ªçc c√≥ th·ªÉ l·∫≠p tr√¨nh v√† x√≥a b·∫±ng ƒëi·ªán) l√† b·ªô nh·ªõ b·∫•t bi·∫øn (gi·ªØ d·ªØ li·ªáu khi m·∫•t ƒëi·ªán) v√† c√≥ th·ªÉ ghi v√†o ƒë∆∞·ª£c, kh√¥ng ch·ªâ ƒë·ªçc."
        }
    },
    {
        "id": 126,
        "en": {
            "question": "DRAM is much more expensive than SRAM.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "SRAM is much more expensive than DRAM per bit. DRAM cells are simpler and smaller, allowing for much higher density and lower cost, which is why it's used for main memory."
        },
        "vi": {
            "question": "DRAM ƒë·∫Øt h∆°n nhi·ªÅu so v·ªõi SRAM.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "SRAM ƒë·∫Øt h∆°n nhi·ªÅu so v·ªõi DRAM tr√™n m·ªói bit. C√°c √¥ nh·ªõ DRAM ƒë∆°n gi·∫£n v√† nh·ªè h∆°n, cho ph√©p m·∫≠t ƒë·ªô cao h∆°n nhi·ªÅu v√† chi ph√≠ th·∫•p h∆°n, ƒë√≥ l√† l√Ω do t·∫°i sao n√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho b·ªô nh·ªõ ch√≠nh."
        }
    },
    {
        "id": 127,
        "en": {
            "question": "RDRAM was limited by the fact that it could only send data to the processor once per bus clock cycle.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "RDRAM (Rambus DRAM) was known for its high clock rate and could transfer data on both edges of the clock signal, similar to DDR, but it had a narrower bus."
        },
        "vi": {
            "question": "RDRAM b·ªã gi·ªõi h·∫°n b·ªüi th·ª±c t·∫ø l√† n√≥ ch·ªâ c√≥ th·ªÉ g·ª≠i d·ªØ li·ªáu ƒë·∫øn b·ªô x·ª≠ l√Ω m·ªôt l·∫ßn cho m·ªói chu k·ª≥ xung nh·ªãp bus.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "RDRAM (Rambus DRAM) ƒë∆∞·ª£c bi·∫øt ƒë·∫øn v·ªõi t·ªëc ƒë·ªô xung nh·ªãp cao v√† c√≥ th·ªÉ truy·ªÅn d·ªØ li·ªáu ·ªü c·∫£ hai s∆∞·ªùn c·ªßa t√≠n hi·ªáu xung nh·ªãp, t∆∞∆°ng t·ª± nh∆∞ DDR, nh∆∞ng n√≥ c√≥ m·ªôt bus h·∫πp h∆°n."
        }
    },
    {
        "id": 128,
        "en": {
            "question": "A memory module is a printed circuit board on which memory chips are mounted.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "This is the definition of a memory module, such as a DIMM or SO-DIMM, which is how RAM is installed in most computers."
        },
        "vi": {
            "question": "M·ªôt m√¥-ƒëun b·ªô nh·ªõ l√† m·ªôt b·∫£ng m·∫°ch in tr√™n ƒë√≥ c√°c chip nh·ªõ ƒë∆∞·ª£c g·∫Øn.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m·ªôt m√¥-ƒëun b·ªô nh·ªõ, ch·∫≥ng h·∫°n nh∆∞ DIMM ho·∫∑c SO-DIMM, l√† c√°ch RAM ƒë∆∞·ª£c l·∫Øp ƒë·∫∑t trong h·∫ßu h·∫øt c√°c m√°y t√≠nh."
        }
    },
    {
        "id": 129,
        "en": {
            "question": "What is the main advantage of using dual-channel DRAM over single-channel DRAM?",
            "options": [
                "A. It provides higher memory bandwidth by allowing concurrent data transfers over two channels.",
                "B. It reduces the number of pins required for memory access, reducing manufacturing costs.",
                "C. It reduces latency by using only one memory module for access.",
                "D. It increases memory capacity without impacting performance."
            ],
            "answer": "A. It provides higher memory bandwidth by allowing concurrent data transfers over two channels.",
            "explanation": "Dual-channel architecture effectively doubles the theoretical bandwidth between the memory controller and the RAM by creating two parallel 64-bit data paths."
        },
        "vi": {
            "question": "L·ª£i th·∫ø ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng DRAM k√™nh ƒë√¥i so v·ªõi DRAM k√™nh ƒë∆°n l√† g√¨?",
            "options": [
                "A. N√≥ cung c·∫•p bƒÉng th√¥ng b·ªô nh·ªõ cao h∆°n b·∫±ng c√°ch cho ph√©p truy·ªÅn d·ªØ li·ªáu ƒë·ªìng th·ªùi qua hai k√™nh.",
                "B. N√≥ l√†m gi·∫£m s·ªë l∆∞·ª£ng ch√¢n c·∫Øm c·∫ßn thi·∫øt cho vi·ªác truy c·∫≠p b·ªô nh·ªõ, gi·∫£m chi ph√≠ s·∫£n xu·∫•t.",
                "C. N√≥ l√†m gi·∫£m ƒë·ªô tr·ªÖ b·∫±ng c√°ch ch·ªâ s·ª≠ d·ª•ng m·ªôt m√¥-ƒëun b·ªô nh·ªõ ƒë·ªÉ truy c·∫≠p.",
                "D. N√≥ tƒÉng dung l∆∞·ª£ng b·ªô nh·ªõ m√† kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t."
            ],
            "answer": "A. N√≥ cung c·∫•p bƒÉng th√¥ng b·ªô nh·ªõ cao h∆°n b·∫±ng c√°ch cho ph√©p truy·ªÅn d·ªØ li·ªáu ƒë·ªìng th·ªùi qua hai k√™nh.",
            "explanation": "Ki·∫øn tr√∫c k√™nh ƒë√¥i th·ª±c s·ª± nh√¢n ƒë√¥i bƒÉng th√¥ng l√Ω thuy·∫øt gi·ªØa b·ªô ƒëi·ªÅu khi·ªÉn b·ªô nh·ªõ v√† RAM b·∫±ng c√°ch t·∫°o ra hai ƒë∆∞·ªùng d·∫´n d·ªØ li·ªáu 64-bit song song."
        }
    },
    {
        "id": 130,
        "en": {
            "question": "Which of these is a form of memory that can be programmed and erased electrically, but only in blocks?",
            "options": [
                "A. EEPROM",
                "B. Flash Memory",
                "C. EPROM",
                "D. DRAM"
            ],
            "answer": "B. Flash Memory",
            "explanation": "Flash memory is a type of EEPROM that is erased and reprogrammed in large blocks, making it faster for large write operations."
        },
        "vi": {
            "question": "Lo·∫°i b·ªô nh·ªõ n√†o c√≥ th·ªÉ ƒë∆∞·ª£c l·∫≠p tr√¨nh v√† x√≥a b·∫±ng ƒëi·ªán, nh∆∞ng ch·ªâ theo t·ª´ng kh·ªëi?",
            "options": [
                "A. EEPROM",
                "B. B·ªô nh·ªõ Flash",
                "C. EPROM",
                "D. DRAM"
            ],
            "answer": "B. B·ªô nh·ªõ Flash",
            "explanation": "B·ªô nh·ªõ flash l√† m·ªôt lo·∫°i EEPROM ƒë∆∞·ª£c x√≥a v√† l·∫≠p tr√¨nh l·∫°i theo c√°c kh·ªëi l·ªõn, gi√∫p n√≥ nhanh h∆°n cho c√°c ho·∫°t ƒë·ªông ghi l·ªõn."
        }
    },
    {
        "id": 131,
        "en": {
            "question": "For internal memory, the ____ is equal to the number of electrical lines into and out of the memory module.",
            "options": [
                "A. access time",
                "B. unit of transfer",
                "C. capacity",
                "D. memory ratio"
            ],
            "answer": "B. unit of transfer",
            "explanation": "The unit of transfer is the number of bits read out of or written into memory at a time. This is often equal to the width of the data bus."
        },
        "vi": {
            "question": "ƒê·ªëi v·ªõi b·ªô nh·ªõ trong, ____ b·∫±ng v·ªõi s·ªë l∆∞·ª£ng ƒë∆∞·ªùng ƒëi·ªán v√†o v√† ra kh·ªèi m√¥-ƒëun b·ªô nh·ªõ.",
            "options": [
                "A. th·ªùi gian truy c·∫≠p",
                "B. ƒë∆°n v·ªã truy·ªÅn (unit of transfer)",
                "C. dung l∆∞·ª£ng",
                "D. t·ª∑ l·ªá b·ªô nh·ªõ"
            ],
            "answer": "B. ƒë∆°n v·ªã truy·ªÅn (unit of transfer)",
            "explanation": "ƒê∆°n v·ªã truy·ªÅn l√† s·ªë l∆∞·ª£ng bit ƒë∆∞·ª£c ƒë·ªçc ra ho·∫∑c ghi v√†o b·ªô nh·ªõ t·∫°i m·ªôt th·ªùi ƒëi·ªÉm. ƒêi·ªÅu n√†y th∆∞·ªùng b·∫±ng v·ªõi ƒë·ªô r·ªông c·ªßa bus d·ªØ li·ªáu."
        }
    },
    // Chuy√™n m·ª•c 6: External Memory (B·ªô nh·ªõ ngo√†i) - 33 c√¢u
    {
        "id": 132,
        "en": {
            "question": "Which of the following statements is NOT true about the advantages of an SSD over an HDD?",
            "options": [
                "A. Higher access times and latency: 10x slower than HDD.",
                "B. Durability: More resistant to physical shock and vibration.",
                "C. Longer lifespan: SSDs do not suffer from mechanical wear.",
                "D. Lower power consumption: SSDs use significantly less energy.",
                "E. Quieter and cooler operation."
            ],
            "answer": "A. Higher access times and latency: 10x slower than HDD.",
            "explanation": "This statement is incorrect. SSDs have significantly LOWER (i.e., faster) access times and latency compared to HDDs because they have no moving mechanical parts."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† kh√¥ng ƒë√∫ng v·ªÅ nh·ªØng ∆∞u ƒëi·ªÉm c·ªßa ·ªï SSD so v·ªõi HDD?",
            "options": [
                "A. Th·ªùi gian truy c·∫≠p v√† ƒë·ªô tr·ªÖ cao h∆°n: Ch·∫≠m h∆°n 10 l·∫ßn so v·ªõi HDD.",
                "B. ƒê·ªô b·ªÅn: √çt b·ªã s·ªëc v√† rung v·∫≠t l√Ω.",
                "C. Tu·ªïi th·ªç d√†i h∆°n: SSD kh√¥ng b·ªã m√†i m√≤n c∆° h·ªçc.",
                "D. Ti√™u th·ª• ƒëi·ªán nƒÉng th·∫•p h∆°n: SSD s·ª≠ d·ª•ng √≠t nƒÉng l∆∞·ª£ng h∆°n ƒë√°ng k·ªÉ.",
                "E. Ho·∫°t ƒë·ªông √™m h∆°n v√† m√°t h∆°n."
            ],
            "answer": "A. Th·ªùi gian truy c·∫≠p v√† ƒë·ªô tr·ªÖ cao h∆°n: Ch·∫≠m h∆°n 10 l·∫ßn so v·ªõi HDD.",
            "explanation": "Ph√°t bi·ªÉu n√†y kh√¥ng ch√≠nh x√°c. SSD c√≥ th·ªùi gian truy c·∫≠p v√† ƒë·ªô tr·ªÖ TH·∫§P h∆°n ƒë√°ng k·ªÉ (t·ª©c l√† nhanh h∆°n) so v·ªõi HDD v√¨ ch√∫ng kh√¥ng c√≥ b·ªô ph·∫≠n c∆° kh√≠ chuy·ªÉn ƒë·ªông."
        }
    },
    {
        "id": 133,
        "en": {
            "question": "What is the primary reason why magnetic disks are commonly used for data storage in modern computer systems?",
            "options": [
                "A. They provide faster access times than solid-state drives (SSDs).",
                "B. They consume significantly less power than other forms of storage, such as RAM.",
                "C. They are non-volatile, meaning they retain data even when power is turned off.",
                "D. They have a higher storage density and are cheaper to manufacture than optical disks."
            ],
            "answer": "C. They are non-volatile, meaning they retain data even when power is turned off.",
            "explanation": "The most fundamental reason for using magnetic disks (and SSDs) for mass storage is their non-volatility. They provide persistent storage for the operating system, applications, and user data."
        },
        "vi": {
            "question": "L√Ω do ch√≠nh t·∫°i sao ƒëƒ©a t·ª´ th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu trong c√°c h·ªá th·ªëng m√°y t√≠nh hi·ªán ƒë·∫°i l√† g√¨?",
            "options": [
                "A. Ch√∫ng cung c·∫•p th·ªùi gian truy c·∫≠p nhanh h∆°n ·ªï ƒëƒ©a th·ªÉ r·∫Øn (SSD).",
                "B. Ch√∫ng ti√™u th·ª• √≠t nƒÉng l∆∞·ª£ng h∆°n ƒë√°ng k·ªÉ so v·ªõi c√°c d·∫°ng l∆∞u tr·ªØ kh√°c, ch·∫≥ng h·∫°n nh∆∞ RAM.",
                "C. Ch√∫ng l√† b·ªô nh·ªõ b·∫•t bi·∫øn, nghƒ©a l√† ch√∫ng gi·ªØ l·∫°i d·ªØ li·ªáu ngay c·∫£ khi ngu·ªìn ƒëi·ªán b·ªã t·∫Øt.",
                "D. Ch√∫ng c√≥ m·∫≠t ƒë·ªô l∆∞u tr·ªØ cao h∆°n v√† r·∫ª h∆°n ƒë·ªÉ s·∫£n xu·∫•t so v·ªõi ƒëƒ©a quang."
            ],
            "answer": "C. Ch√∫ng l√† b·ªô nh·ªõ b·∫•t bi·∫øn, nghƒ©a l√† ch√∫ng gi·ªØ l·∫°i d·ªØ li·ªáu ngay c·∫£ khi ngu·ªìn ƒëi·ªán b·ªã t·∫Øt.",
            "explanation": "L√Ω do c∆° b·∫£n nh·∫•t ƒë·ªÉ s·ª≠ d·ª•ng ƒëƒ©a t·ª´ (v√† SSD) cho l∆∞u tr·ªØ dung l∆∞·ª£ng l·ªõn l√† t√≠nh b·∫•t bi·∫øn c·ªßa ch√∫ng. Ch√∫ng cung c·∫•p b·ªô l∆∞u tr·ªØ li√™n t·ª•c cho h·ªá ƒëi·ªÅu h√†nh, ·ª©ng d·ª•ng v√† d·ªØ li·ªáu ng∆∞·ªùi d√πng."
        }
    },
    {
        "id": 134,
        "en": {
            "question": "How does disk fragmentation affect the performance of a magnetic disk over time?",
            "options": [
                "A. It leads to data loss, causing the disk to fail prematurely.",
                "B. It reduces the overall capacity of the disk, forcing the use of multiple disks.",
                "C. It increases the rotational speed of the disk, increasing read/write speeds.",
                "D. It causes the read/write head to move less efficiently, increasing seek time as data becomes scattered across the disk."
            ],
            "answer": "D. It causes the read/write head to move less efficiently, increasing seek time as data becomes scattered across the disk.",
            "explanation": "Fragmentation means a single file is stored in non-contiguous blocks. To read the file, the read/write head must move to different locations on the platter, increasing seek time and slowing down access."
        },
        "vi": {
            "question": "Ph√¢n m·∫£nh ƒëƒ©a ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t c·ªßa ƒëƒ©a t·ª´ theo th·ªùi gian nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ d·∫´n ƒë·∫øn m·∫•t d·ªØ li·ªáu, khi·∫øn ƒëƒ©a b·ªã h·ªèng s·ªõm.",
                "B. N√≥ l√†m gi·∫£m dung l∆∞·ª£ng t·ªïng th·ªÉ c·ªßa ƒëƒ©a, bu·ªôc ph·∫£i s·ª≠ d·ª•ng nhi·ªÅu ƒëƒ©a.",
                "C. N√≥ l√†m tƒÉng t·ªëc ƒë·ªô quay c·ªßa ƒëƒ©a, tƒÉng t·ªëc ƒë·ªô ƒë·ªçc/ghi.",
                "D. N√≥ khi·∫øn ƒë·∫ßu ƒë·ªçc/ghi ph·∫£i di chuy·ªÉn k√©m hi·ªáu qu·∫£ h∆°n, tƒÉng th·ªùi gian t√¨m ki·∫øm v√¨ d·ªØ li·ªáu b·ªã ph√¢n t√°n tr√™n ƒëƒ©a."
            ],
            "answer": "D. N√≥ khi·∫øn ƒë·∫ßu ƒë·ªçc/ghi ph·∫£i di chuy·ªÉn k√©m hi·ªáu qu·∫£ h∆°n, tƒÉng th·ªùi gian t√¨m ki·∫øm v√¨ d·ªØ li·ªáu b·ªã ph√¢n t√°n tr√™n ƒëƒ©a.",
            "explanation": "Ph√¢n m·∫£nh c√≥ nghƒ©a l√† m·ªôt t·ªáp duy nh·∫•t ƒë∆∞·ª£c l∆∞u tr·ªØ trong c√°c kh·ªëi kh√¥ng li·ªÅn k·ªÅ. ƒê·ªÉ ƒë·ªçc t·ªáp, ƒë·∫ßu ƒë·ªçc/ghi ph·∫£i di chuy·ªÉn ƒë·∫øn c√°c v·ªã tr√≠ kh√°c nhau tr√™n ƒëƒ©a, l√†m tƒÉng th·ªùi gian t√¨m ki·∫øm v√† l√†m ch·∫≠m truy c·∫≠p."
        }
    },
    {
        "id": 135,
        "en": {
            "question": "In the context of magnetic disk organization, what is the purpose of sectoring?",
            "options": [
                "A. It allows for faster data encryption, ensuring the security of sensitive information.",
                "B. It increases read/write speeds by creating larger blocks of data for sequential access.",
                "C. It divides the disk into small, fixed-size blocks, allowing for more efficient data retrieval and error correction.",
                "D. It stores data on different platters to increase redundancy and reliability."
            ],
            "answer": "C. It divides the disk into small, fixed-size blocks, allowing for more efficient data retrieval and error correction.",
            "explanation": "Tracks are subdivided into sectors, which are the smallest addressable unit of storage on a disk. This fixed-size block structure simplifies addressing and error checking."
        },
        "vi": {
            "question": "V·ªÅ t·ªï ch·ª©c ƒëƒ©a t·ª´, m·ª•c ƒë√≠ch c·ªßa vi·ªác ph√¢n chia sector l√† g√¨?",
            "options": [
                "A. N√≥ cho ph√©p m√£ h√≥a d·ªØ li·ªáu nhanh h∆°n, ƒë·∫£m b·∫£o t√≠nh b·∫£o m·∫≠t c·ªßa th√¥ng tin nh·∫°y c·∫£m.",
                "B. N√≥ l√†m tƒÉng t·ªëc ƒë·ªô ƒë·ªçc/ghi b·∫±ng c√°ch t·∫°o ra c√°c kh·ªëi d·ªØ li·ªáu l·ªõn h∆°n ƒë·ªÉ truy c·∫≠p tu·∫ßn t·ª±.",
                "C. N√≥ chia ƒëƒ©a th√†nh c√°c kh·ªëi nh·ªè, c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh, cho ph√©p truy xu·∫•t d·ªØ li·ªáu v√† s·ª≠a l·ªói hi·ªáu qu·∫£ h∆°n.",
                "D. N√≥ l∆∞u tr·ªØ d·ªØ li·ªáu tr√™n c√°c ƒëƒ©a kh√°c nhau ƒë·ªÉ tƒÉng t√≠nh d·ª± ph√≤ng v√† ƒë·ªô tin c·∫≠y."
            ],
            "answer": "C. N√≥ chia ƒëƒ©a th√†nh c√°c kh·ªëi nh·ªè, c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh, cho ph√©p truy xu·∫•t d·ªØ li·ªáu v√† s·ª≠a l·ªói hi·ªáu qu·∫£ h∆°n.",
            "explanation": "C√°c r√£nh (track) ƒë∆∞·ª£c chia nh·ªè th√†nh c√°c sector, l√† ƒë∆°n v·ªã l∆∞u tr·ªØ c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ nh·ªè nh·∫•t tr√™n ƒëƒ©a. C·∫•u tr√∫c kh·ªëi c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh n√†y gi√∫p ƒë∆°n gi·∫£n h√≥a vi·ªác ƒë·ªãnh ƒë·ªãa ch·ªâ v√† ki·ªÉm tra l·ªói."
        }
    },
    {
        "id": 136,
        "en": {
            "question": "Which of the following is an issue specific to SSDs compared to HDDs?",
            "options": [
                "A. Performance slows down as the device is used.",
                "B. A certain number of writes renders the flash memory unusable.",
                "C. They are more susceptible to physical damage.",
                "D. They require defragmentation to maintain performance."
            ],
            "answer": "B. A certain number of writes renders the flash memory unusable.",
            "explanation": "SSD memory cells have a finite number of program-erase cycles (write endurance). While modern SSDs have wear-leveling algorithms to mitigate this, it remains a fundamental limitation of NAND flash technology. Performance degradation (A) also occurs, but B is a more fundamental issue."
        },
        "vi": {
            "question": "V·∫•n ƒë·ªÅ n√†o sau ƒë√¢y l√† ƒë·∫∑c th√π c·ªßa SSD so v·ªõi HDD?",
            "options": [
                "A. Hi·ªáu su·∫•t ch·∫≠m l·∫°i khi thi·∫øt b·ªã ƒë∆∞·ª£c s·ª≠ d·ª•ng.",
                "B. M·ªôt s·ªë l∆∞·ª£ng ghi nh·∫•t ƒë·ªãnh l√†m cho b·ªô nh·ªõ flash kh√¥ng th·ªÉ s·ª≠ d·ª•ng ƒë∆∞·ª£c.",
                "C. Ch√∫ng d·ªÖ b·ªã h∆∞ h·ªèng v·∫≠t l√Ω h∆°n.",
                "D. Ch√∫ng y√™u c·∫ßu ch·ªëng ph√¢n m·∫£nh ƒë·ªÉ duy tr√¨ hi·ªáu su·∫•t."
            ],
            "answer": "B. M·ªôt s·ªë l∆∞·ª£ng ghi nh·∫•t ƒë·ªãnh l√†m cho b·ªô nh·ªõ flash kh√¥ng th·ªÉ s·ª≠ d·ª•ng ƒë∆∞·ª£c.",
            "explanation": "C√°c √¥ nh·ªõ SSD c√≥ m·ªôt s·ªë chu k·ª≥ ghi/x√≥a h·ªØu h·∫°n (ƒë·ªô b·ªÅn ghi). M·∫∑c d√π c√°c ·ªï SSD hi·ªán ƒë·∫°i c√≥ c√°c thu·∫≠t to√°n c√¢n b·∫±ng ƒë·ªô m√≤n ƒë·ªÉ gi·∫£m thi·ªÉu ƒëi·ªÅu n√†y, n√≥ v·∫´n l√† m·ªôt h·∫°n ch·∫ø c∆° b·∫£n c·ªßa c√¥ng ngh·ªá flash NAND. Suy gi·∫£m hi·ªáu su·∫•t (A) c≈©ng x·∫£y ra, nh∆∞ng B l√† m·ªôt v·∫•n ƒë·ªÅ c∆° b·∫£n h∆°n."
        }
    },
    {
        "id": 137,
        "en": {
            "question": "Which RAID level uses striping with a minimum of 3 disks and provides fault tolerance through the use of parity bits?",
            "options": [
                "A. RAID 0",
                "B. RAID 1",
                "C. RAID 2",
                "D. RAID 3 (or the more common RAID 5)"
            ],
            "answer": "D. RAID 3 (or the more common RAID 5)",
            "explanation": "RAID 3 uses byte-level striping with a dedicated parity disk. RAID 5, which is more common, uses block-level striping with distributed parity. Both fit the general description of striping with parity for fault tolerance."
        },
        "vi": {
            "question": "M·ª©c RAID n√†o s·ª≠ d·ª•ng k·ªπ thu·∫≠t striping v·ªõi t·ªëi thi·ªÉu 3 ƒëƒ©a v√† cung c·∫•p kh·∫£ nƒÉng ch·ªãu l·ªói th√¥ng qua vi·ªác s·ª≠ d·ª•ng bit ch·∫µn l·∫ª?",
            "options": [
                "A. RAID 0",
                "B. RAID 1",
                "C. RAID 2",
                "D. RAID 3 (ho·∫∑c RAID 5 ph·ªï bi·∫øn h∆°n)"
            ],
            "answer": "D. RAID 3 (ho·∫∑c RAID 5 ph·ªï bi·∫øn h∆°n)",
            "explanation": "RAID 3 s·ª≠ d·ª•ng striping c·∫•p byte v·ªõi m·ªôt ƒëƒ©a ch·∫µn l·∫ª chuy√™n d·ª•ng. RAID 5, ph·ªï bi·∫øn h∆°n, s·ª≠ d·ª•ng striping c·∫•p kh·ªëi v·ªõi ch·∫µn l·∫ª ph√¢n t√°n. C·∫£ hai ƒë·ªÅu ph√π h·ª£p v·ªõi m√¥ t·∫£ chung v·ªÅ striping v·ªõi ch·∫µn l·∫ª ƒë·ªÉ ch·ªãu l·ªói."
        }
    },
    {
        "id": 138,
        "en": {
            "question": "In a Winchester hard disk, how many bytes of data does each sector contain?",
            "options": [
                "A. 128 bytes",
                "B. 256 bytes",
                "C. 512 bytes",
                "D. 1024 bytes"
            ],
            "answer": "C. 512 bytes",
            "explanation": "For many years, 512 bytes was the standard sector size for hard disk drives. Modern drives are transitioning to Advanced Format with 4096-byte (4K) sectors, but 512 is the classic answer."
        },
        "vi": {
            "question": "M·ªói sector trong ƒëƒ©a c·ª©ng Winchester c√≥ bao nhi√™u byte d·ªØ li·ªáu?",
            "options": [
                "A. 128 bytes",
                "B. 256 bytes",
                "C. 512 bytes",
                "D. 1024 bytes"
            ],
            "answer": "C. 512 bytes",
            "explanation": "Trong nhi·ªÅu nƒÉm, 512 byte l√† k√≠ch th∆∞·ªõc sector ti√™u chu·∫©n cho c√°c ·ªï ƒëƒ©a c·ª©ng. C√°c ·ªï ƒëƒ©a hi·ªán ƒë·∫°i ƒëang chuy·ªÉn sang ƒê·ªãnh d·∫°ng N√¢ng cao v·ªõi c√°c sector 4096 byte (4K), nh∆∞ng 512 l√† c√¢u tr·∫£ l·ªùi kinh ƒëi·ªÉn."
        }
    },
    {
        "id": 139,
        "en": {
            "question": "You are concerned about the data delivery rate when configuring a RAID drive for a Multimedia Streaming Server. This server has two hard disks installed. What type of RAID should you install and what type of data will be stored on Disk 1 and Disk 2?",
            "options": [
                "A. RAID 0 - Disk 1 (Stripe) and Disk 2 (Stripe)",
                "B. RAID 0 - Disk 1 (Mirror) and Disk 2 (Mirror)",
                "C. RAID 1 - Disk 1 (Stripe) and Disk 2 (Stripe)",
                "D. RAID 1 - Disk 1 (Mirror) and Disk 2 (Mirror)"
            ],
            "answer": "A. RAID 0 - Disk 1 (Stripe) and Disk 2 (Stripe)",
            "explanation": "RAID 0 (striping) is used for maximum performance (data delivery rate) as it writes data across both disks simultaneously. It offers no redundancy. RAID 1 (mirroring) is used for redundancy, not speed."
        },
        "vi": {
            "question": "T·ªëc ƒë·ªô ph√¢n ph·ªëi d·ªØ li·ªáu l√† m·ªëi quan t√¢m ch√≠nh c·ªßa b·∫°n khi c·∫•u h√¨nh ·ªï ƒëƒ©a RAID cho M√°y ch·ªß Truy·ªÅn ph√°t ƒêa ph∆∞∆°ng ti·ªán. M√°y ch·ªß n√†y c√≥ hai ƒëƒ©a c·ª©ng ƒë∆∞·ª£c c√†i ƒë·∫∑t. B·∫°n n√™n c√†i ƒë·∫∑t lo·∫°i RAID n√†o v√† lo·∫°i d·ªØ li·ªáu n√†o s·∫Ω ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n ƒêƒ©a 1 v√† ƒêƒ©a 2?",
            "options": [
                "A. RAID 0 - ƒêƒ©a 1 (Stripe) v√† ƒêƒ©a 2 (Stripe)",
                "B. RAID 0 - ƒêƒ©a 1 (Mirror) v√† ƒêƒ©a 2 (Mirror)",
                "C. RAID 1 - ƒêƒ©a 1 (Stripe) v√† ƒêƒ©a 2 (Stripe)",
                "D. RAID 1 - ƒêƒ©a 1 (Mirror) v√† ƒêƒ©a 2 (Mirror)"
            ],
            "answer": "A. RAID 0 - ƒêƒ©a 1 (Stripe) v√† ƒêƒ©a 2 (Stripe)",
            "explanation": "RAID 0 (striping) ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ƒë·∫°t hi·ªáu su·∫•t t·ªëi ƒëa (t·ªëc ƒë·ªô ph√¢n ph·ªëi d·ªØ li·ªáu) v√¨ n√≥ ghi d·ªØ li·ªáu tr√™n c·∫£ hai ƒëƒ©a ƒë·ªìng th·ªùi. N√≥ kh√¥ng cung c·∫•p d·ª± ph√≤ng. RAID 1 (mirroring) ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ d·ª± ph√≤ng, kh√¥ng ph·∫£i t·ªëc ƒë·ªô."
        }
    },
    {
        "id": 140,
        "en": {
            "question": "Which of the following memory devices has the lowest access speed?",
            "options": [
                "A. ROM",
                "B. Flash memory",
                "C. Magnetic tape",
                "D. HDD"
            ],
            "answer": "C. Magnetic tape",
            "explanation": "Magnetic tape is a sequential access medium. To read data, you may have to wind through a long reel of tape, making its access time extremely slow compared to other devices."
        },
        "vi": {
            "question": "Thi·∫øt b·ªã b·ªô nh·ªõ n√†o sau ƒë√¢y c√≥ t·ªëc ƒë·ªô truy c·∫≠p th·∫•p nh·∫•t?",
            "options": [
                "A. ROM",
                "B. B·ªô nh·ªõ flash",
                "C. BƒÉng t·ª´ (Magnetic tape)",
                "D. HDD"
            ],
            "answer": "C. BƒÉng t·ª´ (Magnetic tape)",
            "explanation": "BƒÉng t·ª´ l√† m·ªôt ph∆∞∆°ng ti·ªán truy c·∫≠p tu·∫ßn t·ª±. ƒê·ªÉ ƒë·ªçc d·ªØ li·ªáu, b·∫°n c√≥ th·ªÉ ph·∫£i tua qua m·ªôt cu·ªôn bƒÉng d√†i, l√†m cho th·ªùi gian truy c·∫≠p c·ªßa n√≥ c·ª±c k·ª≥ ch·∫≠m so v·ªõi c√°c thi·∫øt b·ªã kh√°c."
        }
    },
    {
        "id": 141,
        "en": {
            "question": "Which statement about RAID is incorrect?",
            "options": [
                "A. RAID is a set of physical disk drives viewed by the operating system as a single logical drive.",
                "B. Data are distributed across the physical drives of an array in a scheme known as striping.",
                "C. RAID is only used for Windows OS.",
                "D. Redundant disk capacity is used to store parity information, which guarantees data recoverability in case of a disk failure."
            ],
            "answer": "C. RAID is only used for Windows OS.",
            "explanation": "RAID is a hardware/software technology that is platform-independent. It is used across all major operating systems, including Linux, macOS, and various UNIX flavors, not just Windows."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o l√† kh√¥ng ch√≠nh x√°c v·ªÅ RAID?",
            "options": [
                "A. RAID l√† m·ªôt t·∫≠p h·ª£p c√°c ·ªï ƒëƒ©a v·∫≠t l√Ω ƒë∆∞·ª£c h·ªá ƒëi·ªÅu h√†nh xem nh∆∞ m·ªôt ·ªï ƒëƒ©a logic duy nh·∫•t.",
                "B. D·ªØ li·ªáu ƒë∆∞·ª£c ph√¢n ph·ªëi tr√™n c√°c ·ªï ƒëƒ©a v·∫≠t l√Ω c·ªßa m·ªôt m·∫£ng theo m·ªôt l∆∞·ª£c ƒë·ªì ƒë∆∞·ª£c g·ªçi l√† striping.",
                "C. RAID ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho Windows OS.",
                "D. Dung l∆∞·ª£ng ƒëƒ©a d·ª± ph√≤ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ th√¥ng tin ch·∫µn l·∫ª, ƒë·∫£m b·∫£o kh·∫£ nƒÉng ph·ª•c h·ªìi d·ªØ li·ªáu trong tr∆∞·ªùng h·ª£p h·ªèng ƒëƒ©a."
            ],
            "answer": "C. RAID ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho Windows OS.",
            "explanation": "RAID l√† m·ªôt c√¥ng ngh·ªá ph·∫ßn c·ª©ng/ph·∫ßn m·ªÅm ƒë·ªôc l·∫≠p v·ªõi n·ªÅn t·∫£ng. N√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng tr√™n t·∫•t c·∫£ c√°c h·ªá ƒëi·ªÅu h√†nh ch√≠nh, bao g·ªìm Linux, macOS v√† c√°c bi·∫øn th·ªÉ UNIX kh√°c, kh√¥ng ch·ªâ Windows."
        }
    },
    {
        "id": 142,
        "en": {
            "question": "Regarding performance, what is the main advantage of solid-state drives over magnetic disks?",
            "options": [
                "A. Solid-state drives have faster access times, lower latency, and higher reliability.",
                "B. Solid-state drives have larger capacity, lower power consumption, and lower cost.",
                "C. Solid-state drives have better compatibility, longer lifespan, and higher security.",
                "D. Solid-state drives have none of the mentioned advantages over magnetic disks."
            ],
            "answer": "A. Solid-state drives have faster access times, lower latency, and higher reliability.",
            "explanation": "The lack of moving parts gives SSDs a significant performance advantage in access time and latency. They are also more resistant to physical shock, making them more reliable."
        },
        "vi": {
            "question": "V·ªÅ hi·ªáu su·∫•t, ∆∞u ƒëi·ªÉm ch√≠nh c·ªßa ·ªï ƒëƒ©a th·ªÉ r·∫Øn so v·ªõi ƒëƒ©a t·ª´ l√† g√¨?",
            "options": [
                "A. ·ªî ƒëƒ©a th·ªÉ r·∫Øn c√≥ th·ªùi gian truy c·∫≠p nhanh h∆°n, ƒë·ªô tr·ªÖ th·∫•p h∆°n v√† ƒë·ªô tin c·∫≠y cao h∆°n.",
                "B. ·ªî ƒëƒ©a th·ªÉ r·∫Øn c√≥ dung l∆∞·ª£ng l·ªõn h∆°n, ti√™u th·ª• ƒëi·ªán nƒÉng th·∫•p h∆°n v√† chi ph√≠ th·∫•p h∆°n.",
                "C. ·ªî ƒëƒ©a th·ªÉ r·∫Øn c√≥ kh·∫£ nƒÉng t∆∞∆°ng th√≠ch t·ªët h∆°n, tu·ªïi th·ªç d√†i h∆°n v√† b·∫£o m·∫≠t cao h∆°n.",
                "D. ·ªî ƒëƒ©a th·ªÉ r·∫Øn kh√¥ng c√≥ ∆∞u ƒëi·ªÉm n√†o ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p so v·ªõi ƒëƒ©a t·ª´."
            ],
            "answer": "A. ·ªî ƒëƒ©a th·ªÉ r·∫Øn c√≥ th·ªùi gian truy c·∫≠p nhanh h∆°n, ƒë·ªô tr·ªÖ th·∫•p h∆°n v√† ƒë·ªô tin c·∫≠y cao h∆°n.",
            "explanation": "Vi·ªác kh√¥ng c√≥ c√°c b·ªô ph·∫≠n chuy·ªÉn ƒë·ªông mang l·∫°i cho SSD m·ªôt l·ª£i th·∫ø hi·ªáu su·∫•t ƒë√°ng k·ªÉ v·ªÅ th·ªùi gian truy c·∫≠p v√† ƒë·ªô tr·ªÖ. Ch√∫ng c≈©ng c√≥ kh·∫£ nƒÉng ch·ªëng s·ªëc v·∫≠t l√Ω t·ªët h∆°n, l√†m cho ch√∫ng ƒë√°ng tin c·∫≠y h∆°n."
        }
    },
    {
        "id": 143,
        "en": {
            "question": "For hard disk data layout, the set of all tracks in the same relative position on the platter is referred to as a(n) ____.",
            "options": [
                "A. Cylinder",
                "B. Tracks",
                "C. Inter-track gap",
                "D. Sector"
            ],
            "answer": "A. Cylinder",
            "explanation": "A cylinder is a logical concept representing all the tracks that are at the same distance from the center on all platters. The read/write heads can access any track in a cylinder without moving (seeking)."
        },
        "vi": {
            "question": "V·ªõi b·ªë c·ª•c d·ªØ li·ªáu ƒëƒ©a c·ª©ng, t·∫≠p h·ª£p t·∫•t c·∫£ c√°c r√£nh ·ªü c√πng m·ªôt v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi tr√™n ƒëƒ©a ƒë∆∞·ª£c g·ªçi l√† ___.",
            "options": [
                "A. Cylinder",
                "B. Tracks",
                "C. Inter-track gap",
                "D. Sector"
            ],
            "answer": "A. Cylinder",
            "explanation": "M·ªôt cylinder l√† m·ªôt kh√°i ni·ªám logic ƒë·∫°i di·ªán cho t·∫•t c·∫£ c√°c r√£nh ·ªü c√πng m·ªôt kho·∫£ng c√°ch t·ª´ t√¢m tr√™n t·∫•t c·∫£ c√°c ƒëƒ©a. C√°c ƒë·∫ßu ƒë·ªçc/ghi c√≥ th·ªÉ truy c·∫≠p b·∫•t k·ª≥ r√£nh n√†o trong m·ªôt cylinder m√† kh√¥ng c·∫ßn di chuy·ªÉn (t√¨m ki·∫øm)."
        }
    },
    {
        "id": 144,
        "en": {
            "question": "In terms of data storage, what is the key difference between solid-state drives and magnetic disks?",
            "options": [
                "A. Magnetic disks use a spinning platter and a read/write head, while solid-state drives use flash memory chips.",
                "B. Magnetic disks use flash memory chips, while solid-state drives use a spinning platter and a read/write head.",
                "C. Both magnetic disks and solid-state drives use flash memory chips, but with different interfaces.",
                "D. Both magnetic disks and solid-state drives use a spinning platter and a read/write head, but at different speeds."
            ],
            "answer": "A. Magnetic disks use a spinning platter and a read/write head, while solid-state drives use flash memory chips.",
            "explanation": "This describes the fundamental physical difference. HDDs are mechanical devices with moving parts, while SSDs are purely electronic with no moving parts."
        },
        "vi": {
            "question": "V·ªÅ l∆∞u tr·ªØ d·ªØ li·ªáu, s·ª± kh√°c bi·ªát ch√≠nh gi·ªØa ·ªï ƒëƒ©a th·ªÉ r·∫Øn v√† ƒëƒ©a t·ª´ l√† g√¨?",
            "options": [
                "A. ƒêƒ©a t·ª´ s·ª≠ d·ª•ng m·ªôt ƒëƒ©a quay v√† m·ªôt ƒë·∫ßu ƒë·ªçc/ghi, trong khi ·ªï ƒëƒ©a th·ªÉ r·∫Øn s·ª≠ d·ª•ng chip nh·ªõ flash.",
                "B. ƒêƒ©a t·ª´ s·ª≠ d·ª•ng chip nh·ªõ flash, trong khi ·ªï ƒëƒ©a th·ªÉ r·∫Øn s·ª≠ d·ª•ng m·ªôt ƒëƒ©a quay v√† m·ªôt ƒë·∫ßu ƒë·ªçc/ghi.",
                "C. ƒêƒ©a t·ª´ v√† ·ªï ƒëƒ©a th·ªÉ r·∫Øn ƒë·ªÅu s·ª≠ d·ª•ng chip nh·ªõ flash, nh∆∞ng v·ªõi c√°c giao di·ªán kh√°c nhau.",
                "D. ƒêƒ©a t·ª´ v√† ·ªï ƒëƒ©a th·ªÉ r·∫Øn ƒë·ªÅu s·ª≠ d·ª•ng m·ªôt ƒëƒ©a quay v√† m·ªôt ƒë·∫ßu ƒë·ªçc/ghi, nh∆∞ng v·ªõi t·ªëc ƒë·ªô kh√°c nhau."
            ],
            "answer": "A. ƒêƒ©a t·ª´ s·ª≠ d·ª•ng m·ªôt ƒëƒ©a quay v√† m·ªôt ƒë·∫ßu ƒë·ªçc/ghi, trong khi ·ªï ƒëƒ©a th·ªÉ r·∫Øn s·ª≠ d·ª•ng chip nh·ªõ flash.",
            "explanation": "ƒêi·ªÅu n√†y m√¥ t·∫£ s·ª± kh√°c bi·ªát v·∫≠t l√Ω c∆° b·∫£n. HDD l√† thi·∫øt b·ªã c∆° kh√≠ c√≥ c√°c b·ªô ph·∫≠n chuy·ªÉn ƒë·ªông, trong khi SSD ho√†n to√†n l√† ƒëi·ªán t·ª≠ kh√¥ng c√≥ b·ªô ph·∫≠n chuy·ªÉn ƒë·ªông."
        }
    },
    {
        "id": 145,
        "en": {
            "question": "The ____ is a storage device that the user can write information to only once.",
            "options": [
                "A. CD-RW",
                "B. CD-R",
                "C. CD-ROM",
                "D. CD-RR"
            ],
            "answer": "B. CD-R",
            "explanation": "CD-R stands for Compact Disc-Recordable. Data can be written to it once (in one or multiple sessions), but it cannot be erased and rewritten."
        },
        "vi": {
            "question": "____ l√† m·ªôt thi·∫øt b·ªã l∆∞u tr·ªØ m√† ng∆∞·ªùi d√πng ch·ªâ c√≥ th·ªÉ ghi th√¥ng tin m·ªôt l·∫ßn.",
            "options": [
                "A. CD-RW",
                "B. CD-R",
                "C. CD-ROM",
                "D. CD-RR"
            ],
            "answer": "B. CD-R",
            "explanation": "CD-R l√† vi·∫øt t·∫Øt c·ªßa Compact Disc-Recordable. D·ªØ li·ªáu c√≥ th·ªÉ ƒë∆∞·ª£c ghi v√†o n√≥ m·ªôt l·∫ßn (trong m·ªôt ho·∫∑c nhi·ªÅu phi√™n), nh∆∞ng kh√¥ng th·ªÉ x√≥a v√† ghi l·∫°i."
        }
    },
    {
        "id": 146,
        "en": {
            "question": "The ____ is a storage device that can undergo multiple writes and erasures.",
            "options": [
                "A. CD-RR",
                "B. CD-RW",
                "C. CD-R",
                "D. CD-ROM"
            ],
            "answer": "B. CD-RW",
            "explanation": "CD-RW stands for Compact Disc-ReWritable. It uses a phase-change metallic alloy that allows data to be erased and rewritten many times."
        },
        "vi": {
            "question": "____ l√† m·ªôt thi·∫øt b·ªã l∆∞u tr·ªØ c√≥ th·ªÉ tr·∫£i qua nhi·ªÅu l·∫ßn ghi v√† x√≥a.",
            "options": [
                "A. CD-RR",
                "B. CD-RW",
                "C. CD-R",
                "D. CD-ROM"
            ],
            "answer": "B. CD-RW",
            "explanation": "CD-RW l√† vi·∫øt t·∫Øt c·ªßa Compact Disc-ReWritable. N√≥ s·ª≠ d·ª•ng m·ªôt h·ª£p kim kim lo·∫°i thay ƒë·ªïi pha cho ph√©p d·ªØ li·ªáu ƒë∆∞·ª£c x√≥a v√† ghi l·∫°i nhi·ªÅu l·∫ßn."
        }
    },
    {
        "id": 147,
        "en": {
            "question": "The ____ can store 25 Gbytes on a single layer on one side.",
            "options": [
                "A. DVD",
                "B. DVD-R",
                "C. DVD-RW",
                "D. Blu-ray DVD"
            ],
            "answer": "D. Blu-ray DVD",
            "explanation": "Blu-ray Discs use a blue-violet laser, which has a shorter wavelength than the red laser used for DVDs. This allows for much higher storage density, with a standard single-layer disc holding 25 GB."
        },
        "vi": {
            "question": "____ c√≥ th·ªÉ l∆∞u tr·ªØ 25 Gbyte tr√™n m·ªôt l·ªõp duy nh·∫•t ·ªü m·ªôt m·∫∑t.",
            "options": [
                "A. DVD",
                "B. DVD-R",
                "C. DVD-RW",
                "D. Blu-ray DVD"
            ],
            "answer": "D. Blu-ray DVD",
            "explanation": "ƒêƒ©a Blu-ray s·ª≠ d·ª•ng tia laser m√†u xanh-t√≠m, c√≥ b∆∞·ªõc s√≥ng ng·∫Øn h∆°n tia laser m√†u ƒë·ªè ƒë∆∞·ª£c s·ª≠ d·ª•ng cho DVD. ƒêi·ªÅu n√†y cho ph√©p m·∫≠t ƒë·ªô l∆∞u tr·ªØ cao h∆°n nhi·ªÅu, v·ªõi m·ªôt ƒëƒ©a m·ªôt l·ªõp ti√™u chu·∫©n ch·ª©a 25 GB."
        }
    },
    {
        "id": 148,
        "en": {
            "question": "The areas between pits are called ____.",
            "options": [
                "A. lands",
                "B. sectors",
                "C. cylinders",
                "D. strips"
            ],
            "answer": "A. lands",
            "explanation": "On an optical disc like a CD or DVD, information is encoded as a series of microscopic indentations (pits) and flat areas (lands) along a spiral track."
        },
        "vi": {
            "question": "C√°c v√πng gi·ªØa c√°c h·ªë (pits) ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. lands",
                "B. sectors",
                "C. cylinders",
                "D. strips"
            ],
            "answer": "A. lands",
            "explanation": "Tr√™n m·ªôt ƒëƒ©a quang nh∆∞ CD ho·∫∑c DVD, th√¥ng tin ƒë∆∞·ª£c m√£ h√≥a th√†nh m·ªôt chu·ªói c√°c v·∫øt l√µm vi m√¥ (pits) v√† c√°c v√πng ph·∫≥ng (lands) d·ªçc theo m·ªôt r√£nh xo·∫Øn ·ªëc."
        }
    },
    {
        "id": 149,
        "en": {
            "question": "Scanning information at the same rate by spinning the disk at a fixed speed is known as ____.",
            "options": [
                "A. constant angular velocity",
                "B. magnetoresistive",
                "C. rotational delay",
                "D. constant linear velocity"
            ],
            "answer": "A. constant angular velocity",
            "explanation": "CAV (Constant Angular Velocity) means the disk spins at a constant number of revolutions per minute. This is typical for hard drives. In contrast, CDs often use CLV (Constant Linear Velocity)."
        },
        "vi": {
            "question": "Qu√©t th√¥ng tin v·ªõi c√πng t·ªëc ƒë·ªô b·∫±ng c√°ch quay ƒëƒ©a ·ªü m·ªôt t·ªëc ƒë·ªô c·ªë ƒë·ªãnh ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. v·∫≠n t·ªëc g√≥c kh√¥ng ƒë·ªïi (constant angular velocity)",
                "B. t·ª´ tr·ªü (magnetoresistive)",
                "C. ƒë·ªô tr·ªÖ quay (rotational delay)",
                "D. v·∫≠n t·ªëc tuy·∫øn t√≠nh kh√¥ng ƒë·ªïi (constant linear velocity)"
            ],
            "answer": "A. v·∫≠n t·ªëc g√≥c kh√¥ng ƒë·ªïi (constant angular velocity)",
            "explanation": "CAV (V·∫≠n t·ªëc g√≥c kh√¥ng ƒë·ªïi) c√≥ nghƒ©a l√† ƒëƒ©a quay v·ªõi m·ªôt s·ªë v√≤ng quay kh√¥ng ƒë·ªïi m·ªói ph√∫t. ƒê√¢y l√† ƒë·∫∑c ƒëi·ªÉm ƒëi·ªÉn h√¨nh c·ªßa ·ªï ƒëƒ©a c·ª©ng. Ng∆∞·ª£c l·∫°i, ƒëƒ©a CD th∆∞·ªùng s·ª≠ d·ª•ng CLV (V·∫≠n t·ªëc tuy·∫øn t√≠nh kh√¥ng ƒë·ªïi)."
        }
    },
    {
        "id": 150,
        "en": {
            "question": "The disadvantage of ____ is that the amount of data that can be stored on the long outer tracks is only the same as what can be stored on the short inner tracks.",
            "options": [
                "A. SSD",
                "B. CAV",
                "C. ROM",
                "D. CLV"
            ],
            "answer": "B. CAV",
            "explanation": "With Constant Angular Velocity (CAV), the data density is lower on the outer tracks compared to the inner tracks because the surface is moving past the head faster."
        },
        "vi": {
            "question": "Nh∆∞·ª£c ƒëi·ªÉm c·ªßa ____ l√† l∆∞·ª£ng d·ªØ li·ªáu c√≥ th·ªÉ ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n c√°c r√£nh ngo√†i d√†i ch·ªâ b·∫±ng l∆∞·ª£ng d·ªØ li·ªáu c√≥ th·ªÉ ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n c√°c r√£nh trong ng·∫Øn.",
            "options": [
                "A. SSD",
                "B. CAV",
                "C. ROM",
                "D. CLV"
            ],
            "answer": "B. CAV",
            "explanation": "V·ªõi V·∫≠n t·ªëc g√≥c kh√¥ng ƒë·ªïi (CAV), m·∫≠t ƒë·ªô d·ªØ li·ªáu ·ªü c√°c r√£nh ngo√†i th·∫•p h∆°n so v·ªõi c√°c r√£nh trong v√¨ b·ªÅ m·∫∑t di chuy·ªÉn qua ƒë·∫ßu ƒë·ªçc nhanh h∆°n."
        }
    },
    {
        "id": 151,
        "en": {
            "question": "When the magnetizable coating is applied to both sides of the platter, the disk is then referred to as ____.",
            "options": [
                "A. multiple sided",
                "B. substrate",
                "C. double sided",
                "D. all of the above"
            ],
            "answer": "C. double sided",
            "explanation": "A disk platter that can store data on both its top and bottom surfaces is called a double-sided disk."
        },
        "vi": {
            "question": "Khi l·ªõp ph·ªß t·ª´ h√≥a ƒë∆∞·ª£c √°p d·ª•ng cho c·∫£ hai m·∫∑t c·ªßa ƒëƒ©a, ƒëƒ©a ƒë√≥ ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. nhi·ªÅu m·∫∑t",
                "B. ƒë·∫ø",
                "C. hai m·∫∑t (double sided)",
                "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n"
            ],
            "answer": "C. hai m·∫∑t (double sided)",
            "explanation": "M·ªôt ƒëƒ©a c·ª©ng c√≥ th·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu tr√™n c·∫£ b·ªÅ m·∫∑t tr√™n v√† d∆∞·ªõi c·ªßa n√≥ ƒë∆∞·ª£c g·ªçi l√† ƒëƒ©a hai m·∫∑t."
        }
    },
    {
        "id": 152,
        "en": {
            "question": "____ is equal to the time it takes to get into position to read or write.",
            "options": [
                "A. access time",
                "B. gap time",
                "C. transfer time",
                "D. constant angular velocity"
            ],
            "answer": "A. access time",
            "explanation": "Access time for a hard drive is the sum of seek time (moving the head to the correct track) and rotational latency (waiting for the correct sector to spin under the head)."
        },
        "vi": {
            "question": "____ b·∫±ng v·ªõi th·ªùi gian c·∫ßn thi·∫øt ƒë·ªÉ v√†o v·ªã tr√≠ ƒë·ªçc ho·∫∑c ghi.",
            "options": [
                "A. th·ªùi gian truy c·∫≠p (access time)",
                "B. th·ªùi gian kho·∫£ng tr·ªëng (gap time)",
                "C. th·ªùi gian truy·ªÅn (transfer time)",
                "D. v·∫≠n t·ªëc g√≥c kh√¥ng ƒë·ªïi"
            ],
            "answer": "A. th·ªùi gian truy c·∫≠p (access time)",
            "explanation": "Th·ªùi gian truy c·∫≠p cho m·ªôt ·ªï ƒëƒ©a c·ª©ng l√† t·ªïng c·ªßa th·ªùi gian t√¨m ki·∫øm (di chuy·ªÉn ƒë·∫ßu ƒë·ªçc ƒë·∫øn ƒë√∫ng r√£nh) v√† ƒë·ªô tr·ªÖ quay (ch·ªù cho ƒë√∫ng sector quay ƒë·∫øn d∆∞·ªõi ƒë·∫ßu ƒë·ªçc)."
        }
    },
    {
        "id": 153,
        "en": {
            "question": "RAID level ____ has the highest disk overhead of all RAID types.",
            "options": [
                "A. 0",
                "B. 1",
                "C. 3",
                "D. 5"
            ],
            "answer": "B. 1",
            "explanation": "RAID 1 (mirroring) has a 100% overhead (or requires 2x the storage capacity of the data) because every piece of data is written to two separate disks for redundancy."
        },
        "vi": {
            "question": "M·ª©c RAID ____ c√≥ chi ph√≠ ƒëƒ©a cao nh·∫•t trong t·∫•t c·∫£ c√°c lo·∫°i RAID.",
            "options": [
                "A. 0",
                "B. 1",
                "C. 3",
                "D. 5"
            ],
            "answer": "B. 1",
            "explanation": "RAID 1 (ph·∫£n chi·∫øu) c√≥ chi ph√≠ (overhead) 100% (ho·∫∑c y√™u c·∫ßu dung l∆∞·ª£ng l∆∞u tr·ªØ g·∫•p 2 l·∫ßn d·ªØ li·ªáu) v√¨ m·ªói m·∫©u d·ªØ li·ªáu ƒë∆∞·ª£c ghi v√†o hai ƒëƒ©a ri√™ng bi·ªát ƒë·ªÉ d·ª± ph√≤ng."
        }
    },
    {
        "id": 154,
        "en": {
            "question": "What is the function of TRIM in a Solid State Drive (SSD) and why is it important?",
            "options": [
                "A. TRIM increases data transfer rates by optimizing the read/write queue on the SSD.",
                "B. TRIM reduces wear on the NAND flash memory by writing additional data onto existing blocks.",
                "C. TRIM informs the SSD which data blocks are no longer in use, allowing it to manage storage more efficiently and prolonging the drive's lifespan.",
                "D. TRIM helps recover lost data by restoring deleted data blocks."
            ],
            "answer": "C. TRIM informs the SSD which data blocks are no longer in use, allowing it to manage storage more efficiently and prolonging the drive's lifespan.",
            "explanation": "TRIM is a command that allows the OS to tell the SSD which data blocks are no longer needed. This allows the SSD's internal garbage collection to work more effectively, preventing performance degradation and improving write endurance."
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng c·ªßa TRIM trong m·ªôt ·ªî ƒëƒ©a th·ªÉ r·∫Øn (SSD) l√† g√¨ v√† t·∫°i sao n√≥ l·∫°i quan tr·ªçng?",
            "options": [
                "A. TRIM l√†m tƒÉng t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu b·∫±ng c√°ch t·ªëi ∆∞u h√≥a h√†ng ƒë·ª£i ƒë·ªçc/ghi tr√™n SSD.",
                "B. TRIM l√†m gi·∫£m s·ª± hao m√≤n tr√™n b·ªô nh·ªõ flash NAND b·∫±ng c√°ch ghi th√™m d·ªØ li·ªáu l√™n c√°c kh·ªëi hi·ªán c√≥.",
                "C. TRIM th√¥ng b√°o cho SSD bi·∫øt nh·ªØng kh·ªëi d·ªØ li·ªáu n√†o kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng, cho ph√©p n√≥ qu·∫£n l√Ω vi·ªác l∆∞u tr·ªØ hi·ªáu qu·∫£ h∆°n v√† k√©o d√†i tu·ªïi th·ªç c·ªßa ·ªï ƒëƒ©a.",
                "D. TRIM gi√∫p kh√¥i ph·ª•c d·ªØ li·ªáu b·ªã m·∫•t b·∫±ng c√°ch kh√¥i ph·ª•c c√°c kh·ªëi d·ªØ li·ªáu ƒë√£ x√≥a."
            ],
            "answer": "C. TRIM th√¥ng b√°o cho SSD bi·∫øt nh·ªØng kh·ªëi d·ªØ li·ªáu n√†o kh√¥ng c√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng, cho ph√©p n√≥ qu·∫£n l√Ω vi·ªác l∆∞u tr·ªØ hi·ªáu qu·∫£ h∆°n v√† k√©o d√†i tu·ªïi th·ªç c·ªßa ·ªï ƒëƒ©a.",
            "explanation": "TRIM l√† m·ªôt l·ªánh cho ph√©p HƒêH b√°o cho SSD bi·∫øt kh·ªëi d·ªØ li·ªáu n√†o kh√¥ng c√≤n c·∫ßn thi·∫øt. ƒêi·ªÅu n√†y cho ph√©p b·ªô thu gom r√°c n·ªôi b·ªô c·ªßa SSD ho·∫°t ƒë·ªông hi·ªáu qu·∫£ h∆°n, ngƒÉn ch·∫∑n s·ª± suy gi·∫£m hi·ªáu su·∫•t v√† c·∫£i thi·ªán ƒë·ªô b·ªÅn ghi."
        }
    },
    {
        "id": 155,
        "en": {
            "question": "RAID 10 (RAID 1+0) combines the features of RAID 1 and RAID 0 in what way?",
            "options": [
                "A. It provides high redundancy by using only mirroring and no striping.",
                "B. It mirrors data for redundancy and stripes the data across two or more disks to improve performance.",
                "C. It combines data parity with mirroring to provide fault tolerance and high data transfer rates.",
                "D. It stripes data for faster access times but includes no redundancy."
            ],
            "answer": "B. It mirrors data for redundancy and stripes the data across two or more disks to improve performance.",
            "explanation": "RAID 10 is a 'stripe of mirrors'. It takes pairs of disks, mirrors them (RAID 1 for redundancy), and then stripes data across these mirrored pairs (RAID 0 for performance), offering both speed and fault tolerance."
        },
        "vi": {
            "question": "RAID 10 (RAID 1+0) k·∫øt h·ª£p c√°c t√≠nh nƒÉng c·ªßa RAID 1 v√† RAID 0 nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ cung c·∫•p d·ª± ph√≤ng cao b·∫±ng c√°ch ch·ªâ s·ª≠ d·ª•ng ph·∫£n chi·∫øu v√† kh√¥ng s·ª≠ d·ª•ng ph√¢n chia.",
                "B. N√≥ ph·∫£n chi·∫øu d·ªØ li·ªáu ƒë·ªÉ d·ª± ph√≤ng v√† ph√¢n chia d·ªØ li·ªáu tr√™n hai ho·∫∑c nhi·ªÅu ƒëƒ©a ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t.",
                "C. N√≥ k·∫øt h·ª£p ch·∫µn l·∫ª d·ªØ li·ªáu v·ªõi ph·∫£n chi·∫øu ƒë·ªÉ cung c·∫•p kh·∫£ nƒÉng ch·ªãu l·ªói v√† t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu cao.",
                "D. N√≥ ph√¢n chia d·ªØ li·ªáu ƒë·ªÉ c√≥ th·ªùi gian truy c·∫≠p nhanh h∆°n nh∆∞ng kh√¥ng bao g·ªìm d·ª± ph√≤ng."
            ],
            "answer": "B. N√≥ ph·∫£n chi·∫øu d·ªØ li·ªáu ƒë·ªÉ d·ª± ph√≤ng v√† ph√¢n chia d·ªØ li·ªáu tr√™n hai ho·∫∑c nhi·ªÅu ƒëƒ©a ƒë·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t.",
            "explanation": "RAID 10 l√† m·ªôt 'd·∫£i c√°c g∆∞∆°ng'. N√≥ l·∫•y c√°c c·∫∑p ƒëƒ©a, ph·∫£n chi·∫øu ch√∫ng (RAID 1 ƒë·ªÉ d·ª± ph√≤ng), v√† sau ƒë√≥ ph√¢n chia d·ªØ li·ªáu tr√™n c√°c c·∫∑p ƒë∆∞·ª£c ph·∫£n chi·∫øu n√†y (RAID 0 ƒë·ªÉ tƒÉng hi·ªáu su·∫•t), cung c·∫•p c·∫£ t·ªëc ƒë·ªô v√† kh·∫£ nƒÉng ch·ªãu l·ªói."
        }
    },
    {
        "id": 156,
        "en": {
            "question": "Why is seek time important when evaluating the performance of a magnetic disk?",
            "options": [
                "A. It determines the time it takes for data to be transferred from the disk to the system's RAM.",
                "B. It measures the delay before the read/write head reaches the correct location on the disk to access the required data.",
                "C. It determines the amount of time required to load the disk's operating system.",
                "D. It calculates the number of read/write cycles a disk can perform before it fails."
            ],
            "answer": "B. It measures the delay before the read/write head reaches the correct location on the disk to access the required data.",
            "explanation": "Seek time is the time taken for the read/write head to move to the correct track. It is a major component of the total access time and a significant performance bottleneck for random I/O operations on HDDs."
        },
        "vi": {
            "question": "T·∫°i sao th·ªùi gian t√¨m ki·∫øm l·∫°i quan tr·ªçng khi ƒë√°nh gi√° hi·ªáu su·∫•t c·ªßa m·ªôt ƒëƒ©a t·ª´?",
            "options": [
                "A. N√≥ x√°c ƒë·ªãnh th·ªùi gian c·∫ßn thi·∫øt ƒë·ªÉ d·ªØ li·ªáu ƒë∆∞·ª£c truy·ªÅn t·ª´ ƒëƒ©a ƒë·∫øn RAM c·ªßa h·ªá th·ªëng.",
                "B. N√≥ ƒëo l∆∞·ªùng ƒë·ªô tr·ªÖ tr∆∞·ªõc khi ƒë·∫ßu ƒë·ªçc/ghi ƒë·∫°t ƒë·∫øn v·ªã tr√≠ ch√≠nh x√°c tr√™n ƒëƒ©a ƒë·ªÉ truy c·∫≠p d·ªØ li·ªáu c·∫ßn thi·∫øt.",
                "C. N√≥ x√°c ƒë·ªãnh l∆∞·ª£ng th·ªùi gian c·∫ßn thi·∫øt ƒë·ªÉ t·∫£i h·ªá ƒëi·ªÅu h√†nh c·ªßa ƒëƒ©a.",
                "D. N√≥ t√≠nh to√°n s·ªë chu k·ª≥ ƒë·ªçc/ghi m√† m·ªôt ƒëƒ©a c√≥ th·ªÉ th·ª±c hi·ªán tr∆∞·ªõc khi n√≥ h·ªèng."
            ],
            "answer": "B. N√≥ ƒëo l∆∞·ªùng ƒë·ªô tr·ªÖ tr∆∞·ªõc khi ƒë·∫ßu ƒë·ªçc/ghi ƒë·∫°t ƒë·∫øn v·ªã tr√≠ ch√≠nh x√°c tr√™n ƒëƒ©a ƒë·ªÉ truy c·∫≠p d·ªØ li·ªáu c·∫ßn thi·∫øt.",
            "explanation": "Th·ªùi gian t√¨m ki·∫øm l√† th·ªùi gian c·∫ßn thi·∫øt ƒë·ªÉ ƒë·∫ßu ƒë·ªçc/ghi di chuy·ªÉn ƒë·∫øn ƒë√∫ng r√£nh. N√≥ l√† m·ªôt th√†nh ph·∫ßn ch√≠nh c·ªßa t·ªïng th·ªùi gian truy c·∫≠p v√† l√† m·ªôt n√∫t th·∫Øt c·ªï chai hi·ªáu su·∫•t ƒë√°ng k·ªÉ cho c√°c ho·∫°t ƒë·ªông I/O ng·∫´u nhi√™n tr√™n HDD."
        }
    },
    {
        "id": 157,
        "en": {
            "question": "How does the absence of moving parts in a Solid State Drive (SSD) affect its performance compared to traditional hard drives?",
            "options": [
                "A. SSDs offer higher storage capacity at a lower cost per gigabyte compared to hard drives.",
                "B. SSDs are more prone to overheating due to the lack of mechanical components, affecting performance.",
                "C. SSDs have faster data access times, as there are no mechanical parts to move, reducing latency.",
                "D. SSDs offer slower data access speeds but are more reliable over time."
            ],
            "answer": "C. SSDs have faster data access times, as there are no mechanical parts to move, reducing latency.",
            "explanation": "Because SSDs are electronic, they do not have the mechanical delays (seek time, rotational latency) of HDDs. This results in near-instantaneous access times, which is their primary performance advantage."
        },
        "vi": {
            "question": "Vi·ªác kh√¥ng c√≥ c√°c b·ªô ph·∫≠n chuy·ªÉn ƒë·ªông trong m·ªôt ·ªî ƒëƒ©a th·ªÉ r·∫Øn (SSD) ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t c·ªßa n√≥ so v·ªõi c√°c ·ªï ƒëƒ©a c·ª©ng truy·ªÅn th·ªëng nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. SSD cung c·∫•p dung l∆∞·ª£ng l∆∞u tr·ªØ cao h∆°n v·ªõi chi ph√≠ th·∫•p h∆°n cho m·ªói gigabyte so v·ªõi ·ªï ƒëƒ©a c·ª©ng.",
                "B. SSD d·ªÖ b·ªã qu√° nhi·ªát do thi·∫øu c√°c th√†nh ph·∫ßn c∆° kh√≠, ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t.",
                "C. SSD c√≥ th·ªùi gian truy c·∫≠p d·ªØ li·ªáu nhanh h∆°n, v√¨ kh√¥ng c√≥ b·ªô ph·∫≠n c∆° kh√≠ n√†o ƒë·ªÉ di chuy·ªÉn, l√†m gi·∫£m ƒë·ªô tr·ªÖ.",
                "D. SSD cung c·∫•p t·ªëc ƒë·ªô truy c·∫≠p d·ªØ li·ªáu ch·∫≠m h∆°n nh∆∞ng ƒë√°ng tin c·∫≠y h∆°n theo th·ªùi gian."
            ],
            "answer": "C. SSD c√≥ th·ªùi gian truy c·∫≠p d·ªØ li·ªáu nhanh h∆°n, v√¨ kh√¥ng c√≥ b·ªô ph·∫≠n c∆° kh√≠ n√†o ƒë·ªÉ di chuy·ªÉn, l√†m gi·∫£m ƒë·ªô tr·ªÖ.",
            "explanation": "B·ªüi v√¨ SSD l√† ƒëi·ªán t·ª≠, ch√∫ng kh√¥ng c√≥ c√°c ƒë·ªô tr·ªÖ c∆° h·ªçc (th·ªùi gian t√¨m ki·∫øm, ƒë·ªô tr·ªÖ quay) c·ªßa HDD. ƒêi·ªÅu n√†y d·∫´n ƒë·∫øn th·ªùi gian truy c·∫≠p g·∫ßn nh∆∞ t·ª©c th·ªùi, ƒë√≥ l√† l·ª£i th·∫ø hi·ªáu su·∫•t ch√≠nh c·ªßa ch√∫ng."
        }
    },
    {
        "id": 158,
        "en": {
            "question": "What is the primary drawback of NAND flash memory used in SSDs?",
            "options": [
                "A. It has a limited number of write/erase cycles, which can wear out the memory over time.",
                "B. It is much slower than traditional hard drives in terms of read/write speeds.",
                "C. It is less power-efficient than traditional hard drives, leading to higher power consumption.",
                "D. It requires frequent defragmentation to maintain optimal performance."
            ],
            "answer": "A. It has a limited number of write/erase cycles, which can wear out the memory over time.",
            "explanation": "This is known as write endurance. Each cell in a NAND flash drive can only be written to a finite number of times before it fails. Wear-leveling algorithms are used to distribute writes evenly and maximize the drive's lifespan."
        },
        "vi": {
            "question": "Nh∆∞·ª£c ƒëi·ªÉm ch√≠nh c·ªßa b·ªô nh·ªõ flash NAND ƒë∆∞·ª£c s·ª≠ d·ª•ng trong SSD l√† g√¨?",
            "options": [
                "A. N√≥ c√≥ s·ªë chu k·ª≥ ghi/x√≥a h·∫°n ch·∫ø, c√≥ th·ªÉ l√†m m√≤n b·ªô nh·ªõ theo th·ªùi gian.",
                "B. N√≥ ch·∫≠m h∆°n nhi·ªÅu so v·ªõi c√°c ·ªï ƒëƒ©a c·ª©ng truy·ªÅn th·ªëng v·ªÅ t·ªëc ƒë·ªô ƒë·ªçc/ghi.",
                "C. N√≥ k√©m hi·ªáu qu·∫£ v·ªÅ nƒÉng l∆∞·ª£ng so v·ªõi c√°c ·ªï ƒëƒ©a c·ª©ng truy·ªÅn th·ªëng, d·∫´n ƒë·∫øn ti√™u th·ª• ƒëi·ªán nƒÉng cao h∆°n.",
                "D. N√≥ y√™u c·∫ßu ch·ªëng ph√¢n m·∫£nh th∆∞·ªùng xuy√™n ƒë·ªÉ duy tr√¨ hi·ªáu su·∫•t t·ªëi ∆∞u."
            ],
            "answer": "A. N√≥ c√≥ s·ªë chu k·ª≥ ghi/x√≥a h·∫°n ch·∫ø, c√≥ th·ªÉ l√†m m√≤n b·ªô nh·ªõ theo th·ªùi gian.",
            "explanation": "ƒêi·ªÅu n√†y ƒë∆∞·ª£c g·ªçi l√† ƒë·ªô b·ªÅn ghi. M·ªói √¥ trong m·ªôt ·ªï flash NAND ch·ªâ c√≥ th·ªÉ ƒë∆∞·ª£c ghi v√†o m·ªôt s·ªë l·∫ßn h·ªØu h·∫°n tr∆∞·ªõc khi n√≥ h·ªèng. C√°c thu·∫≠t to√°n c√¢n b·∫±ng ƒë·ªô m√≤n ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n ph·ªëi c√°c l·∫ßn ghi ƒë·ªÅu v√† t·ªëi ƒëa h√≥a tu·ªïi th·ªç c·ªßa ·ªï ƒëƒ©a."
        }
    },
    {
        "id": 159,
        "en": {
            "question": "What is the main advantage of using RAID 1 (mirroring) over other RAID levels?",
            "options": [
                "A. It provides the best performance for write-intensive workloads by striping data across multiple disks.",
                "B. It provides a high level of redundancy by duplicating data on two disks, ensuring data availability in case one disk fails.",
                "C. It increases storage capacity by combining the storage of two disks into a single large drive.",
                "D. It improves data transfer speeds by using parity data for faster read operations."
            ],
            "answer": "B. It provides a high level of redundancy by duplicating data on two disks, ensuring data availability in case one disk fails.",
            "explanation": "RAID 1's sole purpose is redundancy. It creates an exact copy (mirror) of a set of data on two or more disks. If one disk fails, the data is still accessible from the other disk(s)."
        },
        "vi": {
            "question": "∆Øu ƒëi·ªÉm ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng RAID 1 (ph·∫£n chi·∫øu) so v·ªõi c√°c c·∫•p RAID kh√°c l√† g√¨?",
            "options": [
                "A. N√≥ cung c·∫•p hi·ªáu su·∫•t t·ªët nh·∫•t cho c√°c kh·ªëi l∆∞·ª£ng c√¥ng vi·ªác ghi nhi·ªÅu b·∫±ng c√°ch ph√¢n chia d·ªØ li·ªáu tr√™n nhi·ªÅu ƒëƒ©a.",
                "B. N√≥ cung c·∫•p m·ªôt m·ª©c ƒë·ªô d·ª± ph√≤ng cao b·∫±ng c√°ch sao ch√©p d·ªØ li·ªáu tr√™n hai ƒëƒ©a, ƒë·∫£m b·∫£o t√≠nh s·∫µn c√≥ c·ªßa d·ªØ li·ªáu trong tr∆∞·ªùng h·ª£p m·ªôt ƒëƒ©a b·ªã l·ªói.",
                "C. N√≥ tƒÉng dung l∆∞·ª£ng l∆∞u tr·ªØ b·∫±ng c√°ch k·∫øt h·ª£p vi·ªác l∆∞u tr·ªØ c·ªßa hai ƒëƒ©a th√†nh m·ªôt ·ªï ƒëƒ©a l·ªõn duy nh·∫•t.",
                "D. N√≥ c·∫£i thi·ªán t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu b·∫±ng c√°ch s·ª≠ d·ª•ng d·ªØ li·ªáu ch·∫µn l·∫ª cho c√°c ho·∫°t ƒë·ªông ƒë·ªçc nhanh h∆°n."
            ],
            "answer": "B. N√≥ cung c·∫•p m·ªôt m·ª©c ƒë·ªô d·ª± ph√≤ng cao b·∫±ng c√°ch sao ch√©p d·ªØ li·ªáu tr√™n hai ƒëƒ©a, ƒë·∫£m b·∫£o t√≠nh s·∫µn c√≥ c·ªßa d·ªØ li·ªáu trong tr∆∞·ªùng h·ª£p m·ªôt ƒëƒ©a b·ªã l·ªói.",
            "explanation": "M·ª•c ƒë√≠ch duy nh·∫•t c·ªßa RAID 1 l√† d·ª± ph√≤ng. N√≥ t·∫°o ra m·ªôt b·∫£n sao ch√≠nh x√°c (g∆∞∆°ng) c·ªßa m·ªôt t·∫≠p h·ª£p d·ªØ li·ªáu tr√™n hai ho·∫∑c nhi·ªÅu ƒëƒ©a. N·∫øu m·ªôt ƒëƒ©a b·ªã l·ªói, d·ªØ li·ªáu v·∫´n c√≥ th·ªÉ truy c·∫≠p ƒë∆∞·ª£c t·ª´(c√°c) ƒëƒ©a kh√°c."
        }
    },
    {
        "id": 160,
        "en": {
            "question": "In the context of external storage devices like hard drives and SSDs, what does hot swapping refer to?",
            "options": [
                "A. The ability to transfer data between two devices simultaneously without performance degradation.",
                "B. The process of replacing or connecting a device while the computer is running, without needing to reboot the system.",
                "C. The automatic backup of data from one device to another when connected to a computer.",
                "D. The act of upgrading a device's storage capacity by swapping out its internal components."
            ],
            "answer": "B. The process of replacing or connecting a device while the computer is running, without needing to reboot the system.",
            "explanation": "Hot swapping allows for the addition or removal of components (like drives in a RAID array) without interrupting the system's operation, which is critical for high-availability systems."
        },
        "vi": {
            "question": "Trong c√°c thi·∫øt b·ªã l∆∞u tr·ªØ ngo√†i nh∆∞ ·ªï ƒëƒ©a c·ª©ng v√† SSD, ho√°n ƒë·ªïi n√≥ng (hot swapping) ƒë·ªÅ c·∫≠p ƒë·∫øn ƒëi·ªÅu g√¨?",
            "options": [
                "A. Kh·∫£ nƒÉng truy·ªÅn d·ªØ li·ªáu gi·ªØa hai thi·∫øt b·ªã ƒë·ªìng th·ªùi m√† kh√¥ng l√†m gi·∫£m hi·ªáu su·∫•t.",
                "B. Qu√° tr√¨nh thay th·∫ø ho·∫∑c k·∫øt n·ªëi m·ªôt thi·∫øt b·ªã khi m√°y t√≠nh ƒëang ch·∫°y, m√† kh√¥ng c·∫ßn kh·ªüi ƒë·ªông l·∫°i h·ªá th·ªëng.",
                "C. Vi·ªác sao l∆∞u d·ªØ li·ªáu t·ª± ƒë·ªông t·ª´ m·ªôt thi·∫øt b·ªã sang m·ªôt thi·∫øt b·ªã kh√°c khi ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi m√°y t√≠nh.",
                "D. H√†nh ƒë·ªông n√¢ng c·∫•p dung l∆∞·ª£ng l∆∞u tr·ªØ c·ªßa m·ªôt thi·∫øt b·ªã b·∫±ng c√°ch ho√°n ƒë·ªïi c√°c th√†nh ph·∫ßn b√™n trong c·ªßa n√≥."
            ],
            "answer": "B. Qu√° tr√¨nh thay th·∫ø ho·∫∑c k·∫øt n·ªëi m·ªôt thi·∫øt b·ªã khi m√°y t√≠nh ƒëang ch·∫°y, m√† kh√¥ng c·∫ßn kh·ªüi ƒë·ªông l·∫°i h·ªá th·ªëng.",
            "explanation": "Ho√°n ƒë·ªïi n√≥ng cho ph√©p th√™m ho·∫∑c b·ªõt c√°c th√†nh ph·∫ßn (nh∆∞ ·ªï ƒëƒ©a trong m·ªôt m·∫£ng RAID) m√† kh√¥ng l√†m gi√°n ƒëo·∫°n ho·∫°t ƒë·ªông c·ªßa h·ªá th·ªëng, ƒëi·ªÅu n√†y r·∫•t quan tr·ªçng ƒë·ªëi v·ªõi c√°c h·ªá th·ªëng c√≥ t√≠nh s·∫µn s√†ng cao."
        }
    },
    {
        "id": 161,
        "en": {
            "question": "In a RAID 5 configuration, how are data and parity distributed across the disks?",
            "options": [
                "A. Data is distributed evenly, but no parity is used in RAID 5, making it less fault-tolerant.",
                "B. Data is stored on a single disk, and parity is stored on all remaining disks.",
                "C. Data is mirrored on a single disk, and parity is stored on a single disk.",
                "D. Data and parity are striped across all disks, with one disk's worth of space used for parity in each stripe."
            ],
            "answer": "D. Data and parity are striped across all disks, with one disk's worth of space used for parity in each stripe.",
            "explanation": "RAID 5 uses block-level striping and distributes the parity block across all the drives in the array. This allows any single disk to fail without data loss and improves write performance over a dedicated parity disk (like in RAID 3/4)."
        },
        "vi": {
            "question": "Trong c·∫•u h√¨nh RAID 5, d·ªØ li·ªáu v√† ch·∫µn l·∫ª ƒë∆∞·ª£c ph√¢n ph·ªëi tr√™n c√°c ƒëƒ©a nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. D·ªØ li·ªáu ƒë∆∞·ª£c ph√¢n ph·ªëi ƒë·ªÅu, nh∆∞ng kh√¥ng c√≥ ch·∫µn l·∫ª ƒë∆∞·ª£c s·ª≠ d·ª•ng trong RAID 5, l√†m cho n√≥ k√©m ch·ªãu l·ªói h∆°n.",
                "B. D·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n m·ªôt ƒëƒ©a duy nh·∫•t, v√† ch·∫µn l·∫ª ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n t·∫•t c·∫£ c√°c ƒëƒ©a c√≤n l·∫°i.",
                "C. D·ªØ li·ªáu ƒë∆∞·ª£c ph·∫£n chi·∫øu tr√™n m·ªôt ƒëƒ©a duy nh·∫•t, v√† ch·∫µn l·∫ª ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n m·ªôt ƒëƒ©a duy nh·∫•t.",
                "D. D·ªØ li·ªáu v√† ch·∫µn l·∫ª ƒë∆∞·ª£c ph√¢n chia tr√™n t·∫•t c·∫£ c√°c ƒëƒ©a, v·ªõi m·ªôt ƒëƒ©a ƒë∆∞·ª£c s·ª≠ d·ª•ng cho ch·∫µn l·∫ª trong m·ªói d·∫£i."
            ],
            "answer": "D. D·ªØ li·ªáu v√† ch·∫µn l·∫ª ƒë∆∞·ª£c ph√¢n chia tr√™n t·∫•t c·∫£ c√°c ƒëƒ©a, v·ªõi m·ªôt ƒëƒ©a ƒë∆∞·ª£c s·ª≠ d·ª•ng cho ch·∫µn l·∫ª trong m·ªói d·∫£i.",
            "explanation": "RAID 5 s·ª≠ d·ª•ng striping c·∫•p kh·ªëi v√† ph√¢n ph·ªëi kh·ªëi ch·∫µn l·∫ª tr√™n t·∫•t c·∫£ c√°c ·ªï ƒëƒ©a trong m·∫£ng. ƒêi·ªÅu n√†y cho ph√©p b·∫•t k·ª≥ m·ªôt ƒëƒ©a n√†o b·ªã l·ªói m√† kh√¥ng m·∫•t d·ªØ li·ªáu v√† c·∫£i thi·ªán hi·ªáu su·∫•t ghi so v·ªõi m·ªôt ƒëƒ©a ch·∫µn l·∫ª chuy√™n d·ª•ng (nh∆∞ trong RAID 3/4)."
        }
    },
    // Chuy√™n m·ª•c 7: Input/Output (Nh·∫≠p/Xu·∫•t) - 35 c√¢u
    {
        "id": 162,
        "en": {
            "question": "What is the main difference between Interrupt-Driven I/O and Direct Memory Access (DMA)?",
            "options": [
                "A. Interrupt-driven I/O involves the CPU in every data transfer, while DMA bypasses the CPU and transfers data directly between the I/O device and memory.",
                "B. Interrupt-driven I/O requires special hardware and software support, while DMA does not need any additional components.",
                "C. Interrupt-driven I/O is suitable for small and frequent data transfers, while DMA is suitable for large and infrequent data transfers.",
                "D. All of the above."
            ],
            "answer": "A. Interrupt-driven I/O involves the CPU in every data transfer, while DMA bypasses the CPU and transfers data directly between the I/O device and memory.",
            "explanation": "This is the core difference. With interrupts, the CPU still has to move the data word-by-word from the I/O module to memory. With DMA, the CPU sets up the transfer and is then free to do other work while the DMA controller handles the entire block transfer."
        },
        "vi": {
            "question": "ƒê√¢u l√† s·ª± kh√°c bi·ªát ch√≠nh gi·ªØa I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt (Interrupt-Driven I/O) v√† Truy c·∫≠p b·ªô nh·ªõ tr·ª±c ti·∫øp (DMA)?",
            "options": [
                "A. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt li√™n quan ƒë·∫øn CPU trong m·ªçi l·∫ßn truy·ªÅn d·ªØ li·ªáu, trong khi DMA b·ªè qua CPU v√† truy·ªÅn d·ªØ li·ªáu tr·ª±c ti·∫øp gi·ªØa thi·∫øt b·ªã I/O v√† b·ªô nh·ªõ.",
                "B. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt y√™u c·∫ßu h·ªó tr·ª£ ph·∫ßn c·ª©ng v√† ph·∫ßn m·ªÅm ƒë·∫∑c bi·ªát, trong khi DMA kh√¥ng c·∫ßn b·∫•t k·ª≥ th√†nh ph·∫ßn b·ªï sung n√†o.",
                "C. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt ph√π h·ª£p cho c√°c l·∫ßn truy·ªÅn d·ªØ li·ªáu nh·ªè v√† th∆∞·ªùng xuy√™n, trong khi DMA ph√π h·ª£p cho c√°c l·∫ßn truy·ªÅn d·ªØ li·ªáu l·ªõn v√† kh√¥ng th∆∞·ªùng xuy√™n.",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n."
            ],
            "answer": "A. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt li√™n quan ƒë·∫øn CPU trong m·ªçi l·∫ßn truy·ªÅn d·ªØ li·ªáu, trong khi DMA b·ªè qua CPU v√† truy·ªÅn d·ªØ li·ªáu tr·ª±c ti·∫øp gi·ªØa thi·∫øt b·ªã I/O v√† b·ªô nh·ªõ.",
            "explanation": "ƒê√¢y l√† s·ª± kh√°c bi·ªát c·ªët l√µi. V·ªõi ng·∫Øt, CPU v·∫´n ph·∫£i di chuy·ªÉn d·ªØ li·ªáu t·ª´ng t·ª´ m·ªôt t·ª´ m√¥-ƒëun I/O v√†o b·ªô nh·ªõ. V·ªõi DMA, CPU thi·∫øt l·∫≠p vi·ªác truy·ªÅn v√† sau ƒë√≥ r·∫£nh r·ªói ƒë·ªÉ l√†m vi·ªác kh√°c trong khi b·ªô ƒëi·ªÅu khi·ªÉn DMA x·ª≠ l√Ω to√†n b·ªô vi·ªác truy·ªÅn kh·ªëi."
        }
    },
    {
        "id": 163,
        "en": {
            "question": "Which basic registers help the CPU to establish a connection with an I/O device?",
            "options": [
                "A. I/OAR, I/OBR",
                "B. I/OAR, MAR",
                "C. I/OBR, MBR",
                "D. MAR, MBR"
            ],
            "answer": "A. I/OAR, I/OBR",
            "explanation": "Similar to how MAR and MBR are used for memory, the I/O Address Register (I/OAR) holds the address of a specific I/O port, and the I/O Buffer Register (I/OBR) holds the data to be transferred."
        },
        "vi": {
            "question": "C√°c thanh ghi c∆° b·∫£n n√†o gi√∫p CPU thi·∫øt l·∫≠p k·∫øt n·ªëi v·ªõi m·ªôt thi·∫øt b·ªã I/O?",
            "options": [
                "A. I/OAR, I/OBR",
                "B. I/OAR, MAR",
                "C. I/OBR, MBR",
                "D. MAR, MBR"
            ],
            "answer": "A. I/OAR, I/OBR",
            "explanation": "T∆∞∆°ng t·ª± nh∆∞ c√°ch MAR v√† MBR ƒë∆∞·ª£c s·ª≠ d·ª•ng cho b·ªô nh·ªõ, Thanh ghi ƒê·ªãa ch·ªâ I/O (I/OAR) gi·ªØ ƒë·ªãa ch·ªâ c·ªßa m·ªôt c·ªïng I/O c·ª• th·ªÉ, v√† Thanh ghi B·ªô ƒë·ªám I/O (I/OBR) gi·ªØ d·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c truy·ªÅn."
        }
    },
    {
        "id": 164,
        "en": {
            "question": "What is an interrupt vector?",
            "options": [
                "A. A portion of memory containing the addresses of interrupt handlers.",
                "B. A signal that an I/O device sends to the CPU.",
                "C. A signal that an I/O software sends to the CPU.",
                "D. None of the answers are correct."
            ],
            "answer": "A. A portion of memory containing the addresses of interrupt handlers.",
            "explanation": "The interrupt vector is a table in memory that maps interrupt numbers to the memory addresses of their corresponding Interrupt Service Routines (ISRs). When an interrupt occurs, the CPU uses this table to find and jump to the correct handler."
        },
        "vi": {
            "question": "Vector ng·∫Øt (interrupt vector) l√† g√¨?",
            "options": [
                "A. M·ªôt ph·∫ßn c·ªßa b·ªô nh·ªõ ch·ª©a ƒë·ªãa ch·ªâ c·ªßa c√°c tr√¨nh x·ª≠ l√Ω ng·∫Øt.",
                "B. M·ªôt t√≠n hi·ªáu m√† m·ªôt thi·∫øt b·ªã I/O g·ª≠i ƒë·∫øn CPU.",
                "C. M·ªôt t√≠n hi·ªáu m√† m·ªôt ph·∫ßn m·ªÅm I/O g·ª≠i ƒë·∫øn CPU.",
                "D. Kh√¥ng c√≥ ph∆∞∆°ng √°n n√†o ƒë√∫ng."
            ],
            "answer": "A. M·ªôt ph·∫ßn c·ªßa b·ªô nh·ªõ ch·ª©a ƒë·ªãa ch·ªâ c·ªßa c√°c tr√¨nh x·ª≠ l√Ω ng·∫Øt.",
            "explanation": "Vector ng·∫Øt l√† m·ªôt b·∫£ng trong b·ªô nh·ªõ √°nh x·∫° c√°c s·ªë ng·∫Øt ƒë·∫øn ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa c√°c Quy tr√¨nh D·ªãch v·ª• Ng·∫Øt (ISR) t∆∞∆°ng ·ª©ng. Khi m·ªôt ng·∫Øt x·∫£y ra, CPU s·ª≠ d·ª•ng b·∫£ng n√†y ƒë·ªÉ t√¨m v√† nh·∫£y ƒë·∫øn tr√¨nh x·ª≠ l√Ω ƒë√∫ng."
        }
    },
    {
        "id": 165,
        "en": {
            "question": "Which type of interrupt is illustrated by 'division by zero, attempt to execute an illegal machine instruction'?",
            "options": [
                "A. Program",
                "B. Timer",
                "C. I/O",
                "D. Hardware failure"
            ],
            "answer": "A. Program",
            "explanation": "Program interrupts (also known as exceptions or traps) are generated internally by the CPU as a result of executing an instruction, such as an illegal operation or arithmetic error."
        },
        "vi": {
            "question": "Lo·∫°i ng·∫Øt n√†o ƒë∆∞·ª£c minh h·ªça b·∫±ng \"chia cho kh√¥ng, c·ªë g·∫Øng th·ª±c hi·ªán m·ªôt l·ªánh m√°y b·∫•t h·ª£p ph√°p\"?",
            "options": [
                "A. Ch∆∞∆°ng tr√¨nh (Program)",
                "B. H·∫πn gi·ªù (Timer)",
                "C. I/O",
                "D. L·ªói ph·∫ßn c·ª©ng (Hardware failure)"
            ],
            "answer": "A. Ch∆∞∆°ng tr√¨nh (Program)",
            "explanation": "Ng·∫Øt ch∆∞∆°ng tr√¨nh (c√≤n ƒë∆∞·ª£c g·ªçi l√† ngo·∫°i l·ªá ho·∫∑c b·∫´y) ƒë∆∞·ª£c t·∫°o ra b√™n trong CPU do k·∫øt qu·∫£ c·ªßa vi·ªác th·ª±c thi m·ªôt l·ªánh, ch·∫≥ng h·∫°n nh∆∞ m·ªôt ho·∫°t ƒë·ªông b·∫•t h·ª£p ph√°p ho·∫∑c l·ªói s·ªë h·ªçc."
        }
    },
    {
        "id": 166,
        "en": {
            "question": "The hardware mechanism that allows a device to notify the CPU is called ____.",
            "options": [
                "A. polling",
                "B. interrupt",
                "C. driver",
                "D. controlling"
            ],
            "answer": "B. interrupt",
            "explanation": "An interrupt is a hardware signal sent from a device to the processor, which temporarily stops what the processor is doing to service the device."
        },
        "vi": {
            "question": "C∆° ch·∫ø ph·∫ßn c·ª©ng cho ph√©p m·ªôt thi·∫øt b·ªã th√¥ng b√°o cho CPU ƒë∆∞·ª£c g·ªçi l√† ___.",
            "options": [
                "A. thƒÉm d√≤ (polling)",
                "B. ng·∫Øt (interrupt)",
                "C. tr√¨nh ƒëi·ªÅu khi·ªÉn (driver)",
                "D. ƒëi·ªÅu khi·ªÉn (controlling)"
            ],
            "answer": "B. ng·∫Øt (interrupt)",
            "explanation": "M·ªôt ng·∫Øt l√† m·ªôt t√≠n hi·ªáu ph·∫ßn c·ª©ng ƒë∆∞·ª£c g·ª≠i t·ª´ m·ªôt thi·∫øt b·ªã ƒë·∫øn b·ªô x·ª≠ l√Ω, t·∫°m th·ªùi d·ª´ng nh·ªØng g√¨ b·ªô x·ª≠ l√Ω ƒëang l√†m ƒë·ªÉ ph·ª•c v·ª• thi·∫øt b·ªã."
        }
    },
    {
        "id": 167,
        "en": {
            "question": "Which of the following is a DISADVANTAGE of using programmed I/O?",
            "options": [
                "A. Increased system efficiency.",
                "B. Reduced CPU involvement in I/O operations.",
                "C. Requires the CPU to be constantly busy with I/O tasks.",
                "D. Increased system complexity."
            ],
            "answer": "C. Requires the CPU to be constantly busy with I/O tasks.",
            "explanation": "In programmed I/O, the CPU spends most of its time in a tight loop checking the status of the I/O device (a technique called 'busy-waiting'), which is very inefficient."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† m·ªôt B·∫§T L·ª¢I c·ªßa vi·ªác s·ª≠ d·ª•ng I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh (programmed I/O)?",
            "options": [
                "A. TƒÉng hi·ªáu qu·∫£ h·ªá th·ªëng.",
                "B. Gi·∫£m s·ª± tham gia c·ªßa CPU trong c√°c ho·∫°t ƒë·ªông I/O.",
                "C. Y√™u c·∫ßu CPU ph·∫£i li√™n t·ª•c b·∫≠n r·ªôn v·ªõi c√°c t√°c v·ª• I/O.",
                "D. TƒÉng ƒë·ªô ph·ª©c t·∫°p c·ªßa h·ªá th·ªëng."
            ],
            "answer": "C. Y√™u c·∫ßu CPU ph·∫£i li√™n t·ª•c b·∫≠n r·ªôn v·ªõi c√°c t√°c v·ª• I/O.",
            "explanation": "Trong I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh, CPU d√†nh ph·∫ßn l·ªõn th·ªùi gian c·ªßa m√¨nh trong m·ªôt v√≤ng l·∫∑p ch·∫∑t ch·∫Ω ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i c·ªßa thi·∫øt b·ªã I/O (m·ªôt k·ªπ thu·∫≠t ƒë∆∞·ª£c g·ªçi l√† 'ch·ªù b·∫≠n'), ƒëi·ªÅu n√†y r·∫•t kh√¥ng hi·ªáu qu·∫£."
        }
    },
    {
        "id": 168,
        "en": {
            "question": "The I/O technique where the processor is busy waiting for an I/O operation to be completed is called ____.",
            "options": [
                "A. Programmed I/O or DMA",
                "B. Interrupt-driven I/O",
                "C. Direct memory access (DMA)",
                "D. Programmed I/O"
            ],
            "answer": "D. Programmed I/O",
            "explanation": "This 'busy-waiting' is the defining characteristic of programmed I/O, where the CPU constantly polls the I/O device's status register."
        },
        "vi": {
            "question": "K·ªπ thu·∫≠t I/O m√† b·ªô x·ª≠ l√Ω b·∫≠n ch·ªù m·ªôt ho·∫°t ƒë·ªông I/O ho√†n th√†nh ƒë∆∞·ª£c g·ªçi l√† ___.",
            "options": [
                "A. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh ho·∫∑c DMA",
                "B. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt",
                "C. Truy c·∫≠p b·ªô nh·ªõ tr·ª±c ti·∫øp (DMA)",
                "D. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh (Programmed I/O)"
            ],
            "answer": "D. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh (Programmed I/O)",
            "explanation": "'Ch·ªù b·∫≠n' n√†y l√† ƒë·∫∑c ƒëi·ªÉm x√°c ƒë·ªãnh c·ªßa I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh, n∆°i CPU li√™n t·ª•c thƒÉm d√≤ thanh ghi tr·∫°ng th√°i c·ªßa thi·∫øt b·ªã I/O."
        }
    },
    {
        "id": 169,
        "en": {
            "question": "In which I/O technique does an I/O channel or processor manage the data transfer, thus freeing up the CPU?",
            "options": [
                "A. Programmed I/O",
                "B. Interrupt-driven I/O",
                "C. Channel I/O",
                "D. Memory-mapped I/O"
            ],
            "answer": "C. Channel I/O",
            "explanation": "Channel I/O uses a dedicated, special-purpose processor (an I/O channel) that executes its own set of I/O instructions, offloading the entire I/O task from the main CPU. This is common in mainframes."
        },
        "vi": {
            "question": "Trong k·ªπ thu·∫≠t I/O n√†o, m·ªôt k√™nh I/O ho·∫∑c b·ªô x·ª≠ l√Ω qu·∫£n l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu, do ƒë√≥ gi·∫£i ph√≥ng CPU?",
            "options": [
                "A. I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh",
                "B. I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt",
                "C. K√™nh I/O (Channel I/O)",
                "D. I/O √°nh x·∫° b·ªô nh·ªõ"
            ],
            "answer": "C. K√™nh I/O (Channel I/O)",
            "explanation": "K√™nh I/O s·ª≠ d·ª•ng m·ªôt b·ªô x·ª≠ l√Ω chuy√™n d·ª•ng, c√≥ m·ª•c ƒë√≠ch ƒë·∫∑c bi·ªát (m·ªôt k√™nh I/O) th·ª±c thi t·∫≠p l·ªánh I/O c·ªßa ri√™ng n√≥, gi·∫£m t·∫£i to√†n b·ªô t√°c v·ª• I/O kh·ªèi CPU ch√≠nh. ƒêi·ªÅu n√†y ph·ªï bi·∫øn trong c√°c m√°y t√≠nh l·ªõn."
        }
    },
    {
        "id": 170,
        "en": {
            "question": "In isolated I/O, ____.",
            "options": [
                "A. I/O devices and memory share the same address space",
                "B. I/O devices have a separate address space from memory",
                "C. memory and I/O devices have a related address space",
                "D. a portion of memory is set aside for I/O operation"
            ],
            "answer": "B. I/O devices have a separate address space from memory",
            "explanation": "Isolated I/O (or port-mapped I/O) uses special CPU instructions like IN and OUT to access a separate address space dedicated to I/O ports."
        },
        "vi": {
            "question": "Trong I/O c√¥ l·∫≠p (isolated I/O), ___.",
            "options": [
                "A. c√°c thi·∫øt b·ªã I/O v√† b·ªô nh·ªõ chia s·∫ª c√πng m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ",
                "B. c√°c thi·∫øt b·ªã I/O c√≥ m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ ri√™ng bi·ªát v·ªõi b·ªô nh·ªõ",
                "C. b·ªô nh·ªõ v√† c√°c thi·∫øt b·ªã I/O c√≥ m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ li√™n quan",
                "D. m·ªôt ph·∫ßn c·ªßa b·ªô nh·ªõ ƒë∆∞·ª£c d√†nh ri√™ng cho ho·∫°t ƒë·ªông I/O"
            ],
            "answer": "B. c√°c thi·∫øt b·ªã I/O c√≥ m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ ri√™ng bi·ªát v·ªõi b·ªô nh·ªõ",
            "explanation": "I/O c√¥ l·∫≠p (ho·∫∑c I/O √°nh x·∫° c·ªïng) s·ª≠ d·ª•ng c√°c l·ªánh CPU ƒë·∫∑c bi·ªát nh∆∞ IN v√† OUT ƒë·ªÉ truy c·∫≠p m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ ri√™ng bi·ªát d√†nh cho c√°c c·ªïng I/O."
        }
    },
    {
        "id": 171,
        "en": {
            "question": "Who initiates the data transfer in programmed I/O?",
            "options": [
                "A. I/O controller",
                "B. CPU",
                "C. DMA controller",
                "D. Operating system"
            ],
            "answer": "B. CPU",
            "explanation": "In programmed I/O, the CPU is responsible for everything: checking the device status, issuing the command, and transferring the data."
        },
        "vi": {
            "question": "Trong I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh, ai kh·ªüi t·∫°o vi·ªác truy·ªÅn d·ªØ li·ªáu?",
            "options": [
                "A. B·ªô ƒëi·ªÅu khi·ªÉn I/O",
                "B. CPU",
                "C. B·ªô ƒëi·ªÅu khi·ªÉn DMA",
                "D. H·ªá ƒëi·ªÅu h√†nh"
            ],
            "answer": "B. CPU",
            "explanation": "Trong I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh, CPU ch·ªãu tr√°ch nhi·ªám cho m·ªçi th·ª©: ki·ªÉm tra tr·∫°ng th√°i thi·∫øt b·ªã, ƒë∆∞a ra l·ªánh v√† truy·ªÅn d·ªØ li·ªáu."
        }
    },
    {
        "id": 172,
        "en": {
            "question": "From a structural standpoint, external devices are controlled by ____.",
            "options": [
                "A. Control signals",
                "B. Peripherals",
                "C. I/O modules",
                "D. Remote devices"
            ],
            "answer": "C. I/O modules",
            "explanation": "The I/O module (or controller) acts as the intermediary between the CPU/system bus and the external peripheral device."
        },
        "vi": {
            "question": "T·ª´ quan ƒëi·ªÉm c·∫•u tr√∫c, c√°c thi·∫øt b·ªã b√™n ngo√†i ƒë∆∞·ª£c ƒëi·ªÅu khi·ªÉn b·ªüi ___.",
            "options": [
                "A. T√≠n hi·ªáu ƒëi·ªÅu khi·ªÉn",
                "B. Thi·∫øt b·ªã ngo·∫°i vi",
                "C. M√¥-ƒëun I/O",
                "D. Thi·∫øt b·ªã t·ª´ xa"
            ],
            "answer": "C. M√¥-ƒëun I/O",
            "explanation": "M√¥-ƒëun I/O (ho·∫∑c b·ªô ƒëi·ªÅu khi·ªÉn) ho·∫°t ƒë·ªông nh∆∞ m·ªôt trung gian gi·ªØa CPU/bus h·ªá th·ªëng v√† thi·∫øt b·ªã ngo·∫°i vi b√™n ngo√†i."
        }
    },
    {
        "id": 173,
        "en": {
            "question": "Which are the primary roles of an IO module? (choose two correct answers)",
            "options": [
                "A. Its role is to transfer data, it will transfer data to and from peripherals.",
                "B. Its role is to control device communication, it manages and controls the flow of data between the CPU and peripherals.",
                "C. Its role is to format data and convert analog signals into digital audio data for the CPU.",
                "D. Its role is to protect data from users, ensuring that sensitive information is not lost or intercepted."
            ],
            "answer": "A. Its role is to transfer data, it will transfer data to and from peripherals.",
            "explanation": "The two main roles are acting as an interface for data transfer (A) and providing the necessary control signals and communication logic to manage that transfer (B)."
        },
        "vi": {
            "question": "Vai tr√≤ ch√≠nh c·ªßa m√¥-ƒëun IO l√† g√¨? (ch·ªçn hai c√¢u tr·∫£ l·ªùi ƒë√∫ng)",
            "options": [
                "A. Vai tr√≤ c·ªßa n√≥ l√† truy·ªÅn d·ªØ li·ªáu, n√≥ s·∫Ω truy·ªÅn d·ªØ li·ªáu ƒë·∫øn v√† t·ª´ c√°c thi·∫øt b·ªã ngo·∫°i vi.",
                "B. Vai tr√≤ c·ªßa n√≥ l√† ƒëi·ªÅu khi·ªÉn giao ti·∫øp thi·∫øt b·ªã, n√≥ qu·∫£n l√Ω v√† ƒëi·ªÅu khi·ªÉn lu·ªìng d·ªØ li·ªáu gi·ªØa CPU v√† c√°c thi·∫øt b·ªã ngo·∫°i vi.",
                "C. Vai tr√≤ c·ªßa n√≥ l√† ƒë·ªãnh d·∫°ng d·ªØ li·ªáu v√† chuy·ªÉn ƒë·ªïi t√≠n hi·ªáu analog th√†nh d·ªØ li·ªáu √¢m thanh s·ªë cho CPU.",
                "D. Vai tr√≤ c·ªßa n√≥ l√† b·∫£o v·ªá d·ªØ li·ªáu kh·ªèi ng∆∞·ªùi d√πng, ƒë·∫£m b·∫£o th√¥ng tin nh·∫°y c·∫£m kh√¥ng b·ªã m·∫•t ho·∫∑c b·ªã ch·∫∑n."
            ],
            "answer": "A. Vai tr√≤ c·ªßa n√≥ l√† truy·ªÅn d·ªØ li·ªáu, n√≥ s·∫Ω truy·ªÅn d·ªØ li·ªáu ƒë·∫øn v√† t·ª´ c√°c thi·∫øt b·ªã ngo·∫°i vi.",
            "explanation": "Hai vai tr√≤ ch√≠nh l√† ho·∫°t ƒë·ªông nh∆∞ m·ªôt giao di·ªán ƒë·ªÉ truy·ªÅn d·ªØ li·ªáu (A) v√† cung c·∫•p c√°c t√≠n hi·ªáu ƒëi·ªÅu khi·ªÉn v√† logic giao ti·∫øp c·∫ßn thi·∫øt ƒë·ªÉ qu·∫£n l√Ω vi·ªác truy·ªÅn ƒë√≥ (B). (C√¢u B c≈©ng l√† ƒë√°p √°n ƒë√∫ng)."
        }
    },
    {
        "id": 174,
        "en": {
            "question": "In computers, what types of external devices are included? (choose 3 correct answers)",
            "options": [
                "A. Human readable",
                "B. Communication",
                "C. Data Conversion",
                "D. Machine readable"
            ],
            "answer": "A. Human readable",
            "explanation": "The three broad categories of external devices are: Human readable (e.g., keyboard, monitor), Machine readable (e.g., disk drives, sensors), and Communication (e.g., modem, network interface card)."
        },
        "vi": {
            "question": "Trong m√°y t√≠nh, c√°c thi·∫øt b·ªã b√™n ngo√†i bao g·ªìm nh·ªØng lo·∫°i n√†o? (ch·ªçn 3 c√¢u tr·∫£ l·ªùi ƒë√∫ng)",
            "options": [
                "A. Con ng∆∞·ªùi c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (Human readable)",
                "B. Giao ti·∫øp (Communication)",
                "C. Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu (Data Conversion)",
                "D. M√°y c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (Machine readable)"
            ],
            "answer": "A. Con ng∆∞·ªùi c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (Human readable)",
            "explanation": "Ba lo·∫°i thi·∫øt b·ªã ngo·∫°i vi ch√≠nh l√†: Con ng∆∞·ªùi c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (v√≠ d·ª•: b√†n ph√≠m, m√†n h√¨nh), M√°y c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c (v√≠ d·ª•: ·ªï ƒëƒ©a, c·∫£m bi·∫øn), v√† Giao ti·∫øp (v√≠ d·ª•: modem, card m·∫°ng). (C√¢u B v√† D c≈©ng l√† ƒë√°p √°n ƒë√∫ng)."
        }
    },
    {
        "id": 175,
        "en": {
            "question": "The ____ contains logic for performing a communication function between the peripheral and the bus.",
            "options": [
                "A. I/O channel",
                "B. I/O module",
                "C. I/O processor",
                "D. I/O command"
            ],
            "answer": "B. I/O module",
            "explanation": "This is the definition of an I/O module (or controller/interface). It bridges the gap between the internal system bus and the external device."
        },
        "vi": {
            "question": "____ ch·ª©a logic ƒë·ªÉ th·ª±c hi·ªán m·ªôt ch·ª©c nƒÉng giao ti·∫øp gi·ªØa thi·∫øt b·ªã ngo·∫°i vi v√† bus.",
            "options": [
                "A. I/O channel",
                "B. I/O module",
                "C. I/O processor",
                "D. I/O command"
            ],
            "answer": "B. I/O module",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m·ªôt m√¥-ƒëun I/O (ho·∫∑c b·ªô ƒëi·ªÅu khi·ªÉn/giao di·ªán). N√≥ l√† c·∫ßu n·ªëi gi·ªØa bus h·ªá th·ªëng n·ªôi b·ªô v√† thi·∫øt b·ªã ngo·∫°i vi b√™n ngo√†i."
        }
    },
    {
        "id": 176,
        "en": {
            "question": "The most common means of computer/user interaction is a ____.",
            "options": [
                "A. keyboard/monitor",
                "B. mouse/printer",
                "C. modem/printer",
                "D. monitor/printer"
            ],
            "answer": "A. keyboard/monitor",
            "explanation": "The keyboard for input and the monitor (display) for output remain the primary and most fundamental interface for human-computer interaction."
        },
        "vi": {
            "question": "Ph∆∞∆°ng ti·ªán t∆∞∆°ng t√°c gi·ªØa m√°y t√≠nh v√† ng∆∞·ªùi d√πng ph·ªï bi·∫øn nh·∫•t l√† ____.",
            "options": [
                "A. b√†n ph√≠m/m√†n h√¨nh",
                "B. chu·ªôt/m√°y in",
                "C. modem/m√°y in",
                "D. m√†n h√¨nh/m√°y in"
            ],
            "answer": "A. b√†n ph√≠m/m√†n h√¨nh",
            "explanation": "B√†n ph√≠m ƒë·ªÉ nh·∫≠p li·ªáu v√† m√†n h√¨nh ƒë·ªÉ xu·∫•t li·ªáu v·∫´n l√† giao di·ªán ch√≠nh v√† c∆° b·∫£n nh·∫•t cho s·ª± t∆∞∆°ng t√°c gi·ªØa ng∆∞·ªùi v√† m√°y."
        }
    },
    {
        "id": 177,
        "en": {
            "question": "An I/O module that takes on most of the detailed processing, presenting a high-level interface to the processor, is usually referred to as an ____.",
            "options": [
                "A. I/O channel",
                "B. I/O command",
                "C. I/O controller",
                "D. device controller"
            ],
            "answer": "A. I/O channel",
            "explanation": "An I/O channel is a more sophisticated I/O module, essentially a dedicated processor that can execute its own programs of I/O commands, relieving the CPU of most I/O work."
        },
        "vi": {
            "question": "M·ªôt m√¥-ƒëun I/O ƒë·∫£m nh·∫≠n h·∫ßu h·∫øt qu√° tr√¨nh x·ª≠ l√Ω chi ti·∫øt, tr√¨nh b√†y m·ªôt giao di·ªán c·∫•p cao cho b·ªô x·ª≠ l√Ω, th∆∞·ªùng ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. I/O channel",
                "B. I/O command",
                "C. I/O controller",
                "D. device controller"
            ],
            "answer": "A. I/O channel",
            "explanation": "M·ªôt k√™nh I/O l√† m·ªôt m√¥-ƒëun I/O ph·ª©c t·∫°p h∆°n, v·ªÅ c∆° b·∫£n l√† m·ªôt b·ªô x·ª≠ l√Ω chuy√™n d·ª•ng c√≥ th·ªÉ th·ª±c thi c√°c ch∆∞∆°ng tr√¨nh l·ªánh I/O c·ªßa ri√™ng m√¨nh, gi·∫£m t·∫£i h·∫ßu h·∫øt c√¥ng vi·ªác I/O cho CPU."
        }
    },
    {
        "id": 178,
        "en": {
            "question": "An I/O module that is quite primitive and requires detailed control is usually referred to as an ____.",
            "options": [
                "A. I/O command",
                "B. I/O controller",
                "C. I/O channel",
                "D. I/O processor"
            ],
            "answer": "B. I/O controller",
            "explanation": "An I/O controller (or device controller) is a simpler module that handles the specifics of one or a few device types but still requires significant management from the CPU."
        },
        "vi": {
            "question": "M·ªôt m√¥-ƒëun I/O kh√° nguy√™n th·ªßy v√† y√™u c·∫ßu ƒëi·ªÅu khi·ªÉn chi ti·∫øt th∆∞·ªùng ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. I/O command",
                "B. I/O controller",
                "C. I/O channel",
                "D. I/O processor"
            ],
            "answer": "B. I/O controller",
            "explanation": "M·ªôt b·ªô ƒëi·ªÅu khi·ªÉn I/O (ho·∫∑c b·ªô ƒëi·ªÅu khi·ªÉn thi·∫øt b·ªã) l√† m·ªôt m√¥-ƒëun ƒë∆°n gi·∫£n h∆°n x·ª≠ l√Ω c√°c chi ti·∫øt c·ª• th·ªÉ c·ªßa m·ªôt ho·∫∑c m·ªôt v√†i lo·∫°i thi·∫øt b·ªã nh∆∞ng v·∫´n y√™u c·∫ßu s·ª± qu·∫£n l√Ω ƒë√°ng k·ªÉ t·ª´ CPU."
        }
    },
    {
        "id": 179,
        "en": {
            "question": "The ____ command is used to activate a peripheral and tell it what to do.",
            "options": [
                "A. control",
                "B. test",
                "C. read",
                "D. write"
            ],
            "answer": "A. control",
            "explanation": "Control commands are used to configure the device, such as setting the tape drive to rewind or setting the transmission speed of a modem."
        },
        "vi": {
            "question": "L·ªánh ____ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ k√≠ch ho·∫°t thi·∫øt b·ªã ngo·∫°i vi v√† cho n√≥ bi·∫øt ph·∫£i l√†m g√¨.",
            "options": [
                "A. control (ƒëi·ªÅu khi·ªÉn)",
                "B. test (ki·ªÉm tra)",
                "C. read (ƒë·ªçc)",
                "D. write (ghi)"
            ],
            "answer": "A. control (ƒëi·ªÅu khi·ªÉn)",
            "explanation": "C√°c l·ªánh ƒëi·ªÅu khi·ªÉn ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ c·∫•u h√¨nh thi·∫øt b·ªã, ch·∫≥ng h·∫°n nh∆∞ ƒë·∫∑t ·ªï bƒÉng tua l·∫°i ho·∫∑c ƒë·∫∑t t·ªëc ƒë·ªô truy·ªÅn c·ªßa modem."
        }
    },
    {
        "id": 180,
        "en": {
            "question": "____ is when the DMA module must force the processor to suspend operation.",
            "options": [
                "A. Interrupt",
                "B. Thunderbolt",
                "C. Cycle stealing",
                "D. Lock down"
            ],
            "answer": "C. Cycle stealing",
            "explanation": "In cycle stealing mode, the DMA controller gains access to the system bus to perform a transfer, forcing the CPU to pause for one or more bus cycles. It effectively 'steals' a cycle from the CPU."
        },
        "vi": {
            "question": "____ l√† khi m√¥-ƒëun DMA ph·∫£i bu·ªôc b·ªô x·ª≠ l√Ω t·∫°m d·ª´ng ho·∫°t ƒë·ªông.",
            "options": [
                "A. Interrupt",
                "B. Thunderbolt",
                "C. Cycle stealing (ƒê√°nh c·∫Øp chu k·ª≥)",
                "D. Lock down"
            ],
            "answer": "C. Cycle stealing (ƒê√°nh c·∫Øp chu k·ª≥)",
            "explanation": "Trong ch·∫ø ƒë·ªô ƒë√°nh c·∫Øp chu k·ª≥, b·ªô ƒëi·ªÅu khi·ªÉn DMA gi√†nh quy·ªÅn truy c·∫≠p v√†o bus h·ªá th·ªëng ƒë·ªÉ th·ª±c hi·ªán m·ªôt l·∫ßn truy·ªÅn, bu·ªôc CPU ph·∫£i t·∫°m d·ª´ng trong m·ªôt ho·∫∑c nhi·ªÅu chu k·ª≥ bus. N√≥ th·ª±c s·ª± 'ƒë√°nh c·∫Øp' m·ªôt chu k·ª≥ t·ª´ CPU."
        }
    },
    {
        "id": 181,
        "en": {
            "question": "A ____ controller is a high-speed serial interface that transmits data in packets.",
            "options": [
                "A. USB and FireWire",
                "B. FireWire",
                "C. SCSI",
                "D. USB"
            ],
            "answer": "A. USB and FireWire",
            "explanation": "Both USB (Universal Serial Bus) and FireWire (IEEE 1394) are high-speed serial bus standards that transfer data in packets."
        },
        "vi": {
            "question": "M·ªôt b·ªô ƒëi·ªÅu khi·ªÉn ____ l√† m·ªôt giao di·ªán n·ªëi ti·∫øp t·ªëc ƒë·ªô cao truy·ªÅn d·ªØ li·ªáu theo g√≥i.",
            "options": [
                "A. USB v√† FireWire",
                "B. FireWire",
                "C. SCSI",
                "D. USB"
            ],
            "answer": "A. USB v√† FireWire",
            "explanation": "C·∫£ USB (Universal Serial Bus) v√† FireWire (IEEE 1394) ƒë·ªÅu l√† c√°c ti√™u chu·∫©n bus n·ªëi ti·∫øp t·ªëc ƒë·ªô cao truy·ªÅn d·ªØ li·ªáu theo g√≥i."
        }
    },
    {
        "id": 182,
        "en": {
            "question": "How do USB hubs affect the performance of external devices connected to a computer?",
            "options": [
                "A. USB hubs have no impact on performance because they operate independently of the computer's main system.",
                "B. USB hubs improve the performance of external devices by increasing the power supply to each port.",
                "C. USB hubs generally reduce the performance of external devices by sharing the available data transfer rate among all connected devices.",
                "D. USB hubs can increase the bandwidth of connected devices by distributing data more evenly across multiple channels."
            ],
            "answer": "C. USB hubs generally reduce the performance of external devices by sharing the available data transfer rate among all connected devices.",
            "explanation": "A USB hub shares the bandwidth of the single upstream port it is connected to among all the devices connected to its downstream ports. Therefore, using multiple high-bandwidth devices simultaneously through a hub will result in lower performance for each."
        },
        "vi": {
            "question": "Hub USB ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t c·ªßa c√°c thi·∫øt b·ªã b√™n ngo√†i ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi m√°y t√≠nh nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. Hub USB kh√¥ng c√≥ t√°c ƒë·ªông ƒë·∫øn hi·ªáu su·∫•t v√¨ ch√∫ng ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p v·ªõi h·ªá th·ªëng ch√≠nh c·ªßa m√°y t√≠nh.",
                "B. Hub USB c·∫£i thi·ªán hi·ªáu su·∫•t c·ªßa c√°c thi·∫øt b·ªã b√™n ngo√†i b·∫±ng c√°ch tƒÉng ngu·ªìn cung c·∫•p ƒëi·ªán cho m·ªói c·ªïng.",
                "C. Hub USB th∆∞·ªùng l√†m gi·∫£m hi·ªáu su·∫•t c·ªßa c√°c thi·∫øt b·ªã b√™n ngo√†i b·∫±ng c√°ch chia s·∫ª t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu c√≥ s·∫µn tr√™n t·∫•t c·∫£ c√°c thi·∫øt b·ªã ƒë∆∞·ª£c k·∫øt n·ªëi.",
                "D. Hub USB c√≥ th·ªÉ tƒÉng bƒÉng th√¥ng c·ªßa c√°c thi·∫øt b·ªã ƒë∆∞·ª£c k·∫øt n·ªëi b·∫±ng c√°ch ph√¢n ph·ªëi d·ªØ li·ªáu ƒë·ªìng ƒë·ªÅu h∆°n tr√™n nhi·ªÅu k√™nh."
            ],
            "answer": "C. Hub USB th∆∞·ªùng l√†m gi·∫£m hi·ªáu su·∫•t c·ªßa c√°c thi·∫øt b·ªã b√™n ngo√†i b·∫±ng c√°ch chia s·∫ª t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu c√≥ s·∫µn tr√™n t·∫•t c·∫£ c√°c thi·∫øt b·ªã ƒë∆∞·ª£c k·∫øt n·ªëi.",
            "explanation": "M·ªôt hub USB chia s·∫ª bƒÉng th√¥ng c·ªßa m·ªôt c·ªïng upstream duy nh·∫•t m√† n√≥ ƒë∆∞·ª£c k·∫øt n·ªëi cho t·∫•t c·∫£ c√°c thi·∫øt b·ªã ƒë∆∞·ª£c k·∫øt n·ªëi v√†o c√°c c·ªïng downstream c·ªßa n√≥. Do ƒë√≥, vi·ªác s·ª≠ d·ª•ng nhi·ªÅu thi·∫øt b·ªã bƒÉng th√¥ng cao ƒë·ªìng th·ªùi th√¥ng qua m·ªôt hub s·∫Ω d·∫´n ƒë·∫øn hi·ªáu su·∫•t th·∫•p h∆°n cho m·ªói thi·∫øt b·ªã."
        }
    },
    {
        "id": 183,
        "en": {
            "question": "What is the main difference between USB 3.0 and USB 2.0 in terms of data transfer speed?",
            "options": [
                "A. USB 3.0 is only compatible with Windows operating systems, while USB 2.0 supports all systems.",
                "B. USB 3.0 uses a larger connector than USB 2.0, allowing for faster data transfers.",
                "C. USB 3.0 provides a higher data transfer rate, up to 5Gbps, compared to USB 2.0's 480Mbps.",
                "D. USB 3.0 has a lower data transfer rate than USB 2.0 but offers better power efficiency."
            ],
            "answer": "C. USB 3.0 provides a higher data transfer rate, up to 5Gbps, compared to USB 2.0's 480Mbps.",
            "explanation": "USB 3.0 (SuperSpeed) offers a more than 10x theoretical speed improvement over USB 2.0 (Hi-Speed) by using additional wires and a more efficient protocol."
        },
        "vi": {
            "question": "S·ª± kh√°c bi·ªát ch√≠nh gi·ªØa USB 3.0 v√† USB 2.0 v·ªÅ t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu l√† g√¨?",
            "options": [
                "A. USB 3.0 ch·ªâ t∆∞∆°ng th√≠ch v·ªõi h·ªá ƒëi·ªÅu h√†nh Windows, trong khi USB 2.0 h·ªó tr·ª£ t·∫•t c·∫£ c√°c h·ªá th·ªëng.",
                "B. USB 3.0 s·ª≠ d·ª•ng m·ªôt ƒë·∫ßu n·ªëi l·ªõn h∆°n so v·ªõi USB 2.0, cho ph√©p truy·ªÅn d·ªØ li·ªáu nhanh h∆°n.",
                "C. USB 3.0 cung c·∫•p t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu cao h∆°n, l√™n ƒë·∫øn 5Gbps, so v·ªõi 480Mbps c·ªßa USB 2.0.",
                "D. USB 3.0 c√≥ t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu th·∫•p h∆°n USB 2.0 nh∆∞ng cung c·∫•p hi·ªáu su·∫•t nƒÉng l∆∞·ª£ng t·ªët h∆°n."
            ],
            "answer": "C. USB 3.0 cung c·∫•p t·ªëc ƒë·ªô truy·ªÅn d·ªØ li·ªáu cao h∆°n, l√™n ƒë·∫øn 5Gbps, so v·ªõi 480Mbps c·ªßa USB 2.0.",
            "explanation": "USB 3.0 (SuperSpeed) cung c·∫•p m·ªôt s·ª± c·∫£i thi·ªán t·ªëc ƒë·ªô l√Ω thuy·∫øt h∆°n 10 l·∫ßn so v·ªõi USB 2.0 (Hi-Speed) b·∫±ng c√°ch s·ª≠ d·ª•ng c√°c d√¢y b·ªï sung v√† m·ªôt giao th·ª©c hi·ªáu qu·∫£ h∆°n."
        }
    },
    {
        "id": 184,
        "en": {
            "question": "What is the primary role of a Direct Memory Access (DMA) controller in the operation of an I/O module?",
            "options": [
                "A. It controls the transfer of data between external devices and the system bus by initiating and managing I/O operations directly between memory and the devices.",
                "B. It handles input/output calculations by performing computational operations and sending the results to external devices.",
                "C. It provides power and cooling resources to external devices to ensure optimal performance during data transfers.",
                "D. It organizes and stores data from I/O devices in the computer's storage memory for future use."
            ],
            "answer": "A. It controls the transfer of data between external devices and the system bus by initiating and managing I/O operations directly between memory and the devices.",
            "explanation": "A DMA controller is a specialized hardware component that can take control of the system bus to transfer data directly between an I/O device and main memory, freeing the CPU from this task."
        },
        "vi": {
            "question": "B·ªô ƒëi·ªÅu khi·ªÉn DMA (Direct Memory Access) ƒë√≥ng vai tr√≤ g√¨ trong ho·∫°t ƒë·ªông c·ªßa m·ªôt m√¥-ƒëun I/O?",
            "options": [
                "A. N√≥ ƒëi·ªÅu khi·ªÉn vi·ªác truy·ªÅn d·ªØ li·ªáu gi·ªØa c√°c thi·∫øt b·ªã b√™n ngo√†i v√† bus h·ªá th·ªëng b·∫±ng c√°ch kh·ªüi t·∫°o v√† qu·∫£n l√Ω c√°c ho·∫°t ƒë·ªông I/O tr·ª±c ti·∫øp gi·ªØa b·ªô nh·ªõ v√† c√°c thi·∫øt b·ªã.",
                "B. N√≥ x·ª≠ l√Ω c√°c t√≠nh to√°n ƒë·∫ßu v√†o/ƒë·∫ßu ra b·∫±ng c√°ch th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông t√≠nh to√°n v√† g·ª≠i k·∫øt qu·∫£ ƒë·∫øn c√°c thi·∫øt b·ªã b√™n ngo√†i.",
                "C. N√≥ c·∫•p ngu·ªìn v√† l√†m m√°t t√†i nguy√™n cho c√°c thi·∫øt b·ªã b√™n ngo√†i ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªáu su·∫•t t·ªëi ∆∞u trong qu√° tr√¨nh truy·ªÅn d·ªØ li·ªáu.",
                "D. N√≥ t·ªï ch·ª©c v√† l∆∞u tr·ªØ d·ªØ li·ªáu t·ª´ c√°c thi·∫øt b·ªã I/O trong b·ªô nh·ªõ l∆∞u tr·ªØ c·ªßa m√°y t√≠nh ƒë·ªÉ s·ª≠ d·ª•ng trong t∆∞∆°ng lai."
            ],
            "answer": "A. N√≥ ƒëi·ªÅu khi·ªÉn vi·ªác truy·ªÅn d·ªØ li·ªáu gi·ªØa c√°c thi·∫øt b·ªã b√™n ngo√†i v√† bus h·ªá th·ªëng b·∫±ng c√°ch kh·ªüi t·∫°o v√† qu·∫£n l√Ω c√°c ho·∫°t ƒë·ªông I/O tr·ª±c ti·∫øp gi·ªØa b·ªô nh·ªõ v√† c√°c thi·∫øt b·ªã.",
            "explanation": "M·ªôt b·ªô ƒëi·ªÅu khi·ªÉn DMA l√† m·ªôt th√†nh ph·∫ßn ph·∫ßn c·ª©ng chuy√™n d·ª•ng c√≥ th·ªÉ ki·ªÉm so√°t bus h·ªá th·ªëng ƒë·ªÉ truy·ªÅn d·ªØ li·ªáu tr·ª±c ti·∫øp gi·ªØa m·ªôt thi·∫øt b·ªã I/O v√† b·ªô nh·ªõ ch√≠nh, gi·∫£i ph√≥ng CPU kh·ªèi t√°c v·ª• n√†y."
        }
    },
    {
        "id": 185,
        "en": {
            "question": "How does the use of a buffer in an I/O module enhance system performance?",
            "options": [
                "A. It stores unused data from I/O operations, improving system speed by delaying data transfers.",
                "B. It allows external devices to perform calculations without interacting with the CPU, improving overall performance.",
                "C. It reduces the amount of data processed by the CPU, thus decreasing overall system efficiency.",
                "D. It allows for faster data processing by temporarily storing all incoming and outgoing data in memory before transfer."
            ],
            "answer": "D. It allows for faster data processing by temporarily storing all incoming and outgoing data in memory before transfer.",
            "explanation": "Buffering accommodates the speed differences between the fast processor/memory and the slower I/O device. It allows a large block of data to be transferred in a single operation, rather than word by word, which is much more efficient."
        },
        "vi": {
            "question": "Vi·ªác s·ª≠ d·ª•ng b·ªô ƒë·ªám trong m·ªôt m√¥-ƒëun I/O n√¢ng cao hi·ªáu su·∫•t h·ªá th·ªëng theo c√°ch n√†o?",
            "options": [
                "A. N√≥ l∆∞u tr·ªØ d·ªØ li·ªáu kh√¥ng s·ª≠ d·ª•ng t·ª´ c√°c ho·∫°t ƒë·ªông I/O, c·∫£i thi·ªán t·ªëc ƒë·ªô h·ªá th·ªëng b·∫±ng c√°ch tr√¨ ho√£n vi·ªác truy·ªÅn d·ªØ li·ªáu.",
                "B. N√≥ cho ph√©p c√°c thi·∫øt b·ªã b√™n ngo√†i th·ª±c hi·ªán c√°c t√≠nh to√°n m√† kh√¥ng c·∫ßn t∆∞∆°ng t√°c v·ªõi CPU, c·∫£i thi·ªán hi·ªáu su·∫•t t·ªïng th·ªÉ.",
                "C. N√≥ l√†m gi·∫£m l∆∞·ª£ng d·ªØ li·ªáu ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi CPU, do ƒë√≥ l√†m gi·∫£m hi·ªáu qu·∫£ h·ªá th·ªëng t·ªïng th·ªÉ.",
                "D. N√≥ cho ph√©p x·ª≠ l√Ω d·ªØ li·ªáu nhanh h∆°n b·∫±ng c√°ch l∆∞u tr·ªØ t·∫°m th·ªùi t·∫•t c·∫£ d·ªØ li·ªáu ƒë·∫øn v√† ƒëi trong b·ªô nh·ªõ tr∆∞·ªõc khi truy·ªÅn."
            ],
            "answer": "D. N√≥ cho ph√©p x·ª≠ l√Ω d·ªØ li·ªáu nhanh h∆°n b·∫±ng c√°ch l∆∞u tr·ªØ t·∫°m th·ªùi t·∫•t c·∫£ d·ªØ li·ªáu ƒë·∫øn v√† ƒëi trong b·ªô nh·ªõ tr∆∞·ªõc khi truy·ªÅn.",
            "explanation": "B·ªô ƒë·ªám gi√∫p ƒëi·ªÅu ch·ªânh s·ª± kh√°c bi·ªát v·ªÅ t·ªëc ƒë·ªô gi·ªØa b·ªô x·ª≠ l√Ω/b·ªô nh·ªõ nhanh v√† thi·∫øt b·ªã I/O ch·∫≠m h∆°n. N√≥ cho ph√©p m·ªôt kh·ªëi d·ªØ li·ªáu l·ªõn ƒë∆∞·ª£c truy·ªÅn trong m·ªôt ho·∫°t ƒë·ªông duy nh·∫•t, thay v√¨ t·ª´ng t·ª´ m·ªôt, ƒëi·ªÅu n√†y hi·ªáu qu·∫£ h∆°n nhi·ªÅu."
        }
    },
    {
        "id": 186,
        "en": {
            "question": "Why is Programmed I/O less efficient than Direct Memory Access (DMA) for large data transfers?",
            "options": [
                "A. Programmed I/O uses a separate communication channel for each device, which is less efficient than a shared DMA channel.",
                "B. Programmed I/O requires the CPU to manage every step of the data transfer, tying up the CPU, while DMA allows for direct transfer between memory and the I/O device, freeing up the CPU.",
                "C. Programmed I/O does not support high-speed data transfers, making it inefficient for large-scale operations.",
                "D. Programmed I/O automatically detects errors, while DMA does not perform error checking."
            ],
            "answer": "B. Programmed I/O requires the CPU to manage every step of the data transfer, tying up the CPU, while DMA allows for direct transfer between memory and the I/O device, freeing up the CPU.",
            "explanation": "The key inefficiency of Programmed I/O is the heavy involvement of the CPU for every single word of data. DMA offloads this entire process, allowing the CPU to perform other computations in parallel with the I/O transfer."
        },
        "vi": {
            "question": "T·∫°i sao Programmed I/O k√©m hi·ªáu qu·∫£ h∆°n Direct Memory Access (DMA) ƒë·ªëi v·ªõi vi·ªác truy·ªÅn d·ªØ li·ªáu l·ªõn?",
            "options": [
                "A. Programmed I/O s·ª≠ d·ª•ng m·ªôt k√™nh giao ti·∫øp ri√™ng cho m·ªói thi·∫øt b·ªã, ƒëi·ªÅu n√†y k√©m hi·ªáu qu·∫£ h∆°n so v·ªõi k√™nh DMA ƒë∆∞·ª£c chia s·∫ª.",
                "B. Programmed I/O y√™u c·∫ßu CPU ph·∫£i qu·∫£n l√Ω t·ª´ng b∆∞·ªõc truy·ªÅn d·ªØ li·ªáu, l√†m CPU b·ªã chi·∫øm d·ª•ng, trong khi DMA cho ph√©p truy·ªÅn tr·ª±c ti·∫øp gi·ªØa b·ªô nh·ªõ v√† thi·∫øt b·ªã I/O, gi·∫£i ph√≥ng CPU.",
                "C. Programmed I/O kh√¥ng h·ªó tr·ª£ truy·ªÅn d·ªØ li·ªáu t·ªëc ƒë·ªô cao, l√†m cho n√≥ kh√¥ng hi·ªáu qu·∫£ cho c√°c ho·∫°t ƒë·ªông quy m√¥ l·ªõn.",
                "D. Programmed I/O t·ª± ƒë·ªông ph√°t hi·ªán l·ªói, trong khi DMA kh√¥ng th·ª±c hi·ªán ki·ªÉm tra l·ªói."
            ],
            "answer": "B. Programmed I/O y√™u c·∫ßu CPU ph·∫£i qu·∫£n l√Ω t·ª´ng b∆∞·ªõc truy·ªÅn d·ªØ li·ªáu, l√†m CPU b·ªã chi·∫øm d·ª•ng, trong khi DMA cho ph√©p truy·ªÅn tr·ª±c ti·∫øp gi·ªØa b·ªô nh·ªõ v√† thi·∫øt b·ªã I/O, gi·∫£i ph√≥ng CPU.",
            "explanation": "S·ª± k√©m hi·ªáu qu·∫£ ch√≠nh c·ªßa Programmed I/O l√† s·ª± tham gia n·∫∑ng n·ªÅ c·ªßa CPU cho m·ªói t·ª´ d·ªØ li·ªáu. DMA gi·∫£m t·∫£i to√†n b·ªô qu√° tr√¨nh n√†y, cho ph√©p CPU th·ª±c hi·ªán c√°c t√≠nh to√°n kh√°c song song v·ªõi vi·ªác truy·ªÅn I/O."
        }
    },
    {
        "id": 187,
        "en": {
            "question": "How does Interrupt-Driven I/O improve system efficiency compared to Programmed I/O?",
            "options": [
                "A. It allows the CPU to continue executing other tasks without polling I/O devices, only interacting when an interrupt signal indicates the device is ready.",
                "B. It eliminates the need for an I/O controller, as the CPU handles all device communication directly.",
                "C. It requires the CPU to poll each I/O device itself, ensuring real-time data transfer.",
                "D. It avoids the use of I/O devices, relying instead on the system bus for data handling."
            ],
            "answer": "A. It allows the CPU to continue executing other tasks without polling I/O devices, only interacting when an interrupt signal indicates the device is ready.",
            "explanation": "Instead of the CPU constantly asking 'Are you done yet?' (polling), the device tells the CPU 'I'm done!' (interrupt). This allows the CPU to perform useful work in the meantime, drastically improving efficiency."
        },
        "vi": {
            "question": "Interrupt-Driven I/O c·∫£i thi·ªán hi·ªáu qu·∫£ h·ªá th·ªëng so v·ªõi Programmed I/O nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ cho ph√©p CPU ti·∫øp t·ª•c th·ª±c hi·ªán c√°c t√°c v·ª• kh√°c m√† kh√¥ng c·∫ßn ki·ªÉm tra c√°c thi·∫øt b·ªã I/O, ch·ªâ t∆∞∆°ng t√°c khi m·ªôt t√≠n hi·ªáu ng·∫Øt b√°o hi·ªáu thi·∫øt b·ªã ƒë√£ s·∫µn s√†ng.",
                "B. N√≥ lo·∫°i b·ªè nhu c·∫ßu v·ªÅ b·ªô ƒëi·ªÅu khi·ªÉn I/O, v√¨ CPU x·ª≠ l√Ω t·∫•t c·∫£ c√°c giao ti·∫øp thi·∫øt b·ªã tr·ª±c ti·∫øp.",
                "C. N√≥ y√™u c·∫ßu CPU ph·∫£i t·ª± ki·ªÉm tra t·ª´ng thi·∫øt b·ªã I/O, ƒë·∫£m b·∫£o truy·ªÅn d·ªØ li·ªáu th·ªùi gian th·ª±c.",
                "D. N√≥ tr√°nh vi·ªác s·ª≠ d·ª•ng c√°c thi·∫øt b·ªã I/O, thay v√†o ƒë√≥ ch·ªâ d·ª±a v√†o bus h·ªá th·ªëng ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu."
            ],
            "answer": "A. N√≥ cho ph√©p CPU ti·∫øp t·ª•c th·ª±c hi·ªán c√°c t√°c v·ª• kh√°c m√† kh√¥ng c·∫ßn ki·ªÉm tra c√°c thi·∫øt b·ªã I/O, ch·ªâ t∆∞∆°ng t√°c khi m·ªôt t√≠n hi·ªáu ng·∫Øt b√°o hi·ªáu thi·∫øt b·ªã ƒë√£ s·∫µn s√†ng.",
            "explanation": "Thay v√¨ CPU li√™n t·ª•c h·ªèi 'B·∫°n ƒë√£ xong ch∆∞a?' (thƒÉm d√≤), thi·∫øt b·ªã s·∫Ω b√°o cho CPU 'T√¥i ƒë√£ xong!' (ng·∫Øt). ƒêi·ªÅu n√†y cho ph√©p CPU th·ª±c hi·ªán c√¥ng vi·ªác h·ªØu √≠ch trong th·ªùi gian ch·ªù ƒë·ª£i, c·∫£i thi·ªán ƒë√°ng k·ªÉ hi·ªáu qu·∫£."
        }
    },
    {
        "id": 188,
        "en": {
            "question": "What is the primary limitation of Interrupt-Driven I/O when dealing with frequent interrupts?",
            "options": [
                "A. Frequent interrupts can lead to significant CPU overhead, as the CPU must constantly stop its current task to handle the interrupt, potentially slowing down overall performance.",
                "B. It prevents the CPU from performing multiple tasks at once, reducing the system's multitasking capabilities.",
                "C. Interrupt-Driven I/O is not supported by modern operating systems, so it is ineffective for most applications.",
                "D. It forces the CPU to check the I/O device status continuously, consuming valuable processing time."
            ],
            "answer": "A. Frequent interrupts can lead to significant CPU overhead, as the CPU must constantly stop its current task to handle the interrupt, potentially slowing down overall performance.",
            "explanation": "While better than polling, each interrupt still requires the CPU to save its context, jump to the interrupt handler, service the device, restore context, and resume. For very high-speed devices with frequent, small transfers, this overhead can become a bottleneck."
        },
        "vi": {
            "question": "H·∫°n ch·∫ø ch√≠nh c·ªßa Interrupt-Driven I/O khi x·ª≠ l√Ω c√°c ng·∫Øt th∆∞·ªùng xuy√™n l√† g√¨?",
            "options": [
                "A. C√°c ng·∫Øt th∆∞·ªùng xuy√™n c√≥ th·ªÉ d·∫´n ƒë·∫øn chi ph√≠ CPU ƒë√°ng k·ªÉ, v√¨ CPU ph·∫£i th∆∞·ªùng xuy√™n d·ª´ng t√°c v·ª• hi·ªán t·∫°i c·ªßa m√¨nh ƒë·ªÉ x·ª≠ l√Ω ng·∫Øt, c√≥ kh·∫£ nƒÉng l√†m ch·∫≠m hi·ªáu su·∫•t t·ªïng th·ªÉ.",
                "B. N√≥ ngƒÉn CPU th·ª±c hi·ªán c√°c t√°c v·ª• ƒëa nhi·ªám ƒë·ªìng th·ªùi, l√†m gi·∫£m kh·∫£ nƒÉng ƒëa nhi·ªám c·ªßa h·ªá th·ªëng.",
                "C. Interrupt-Driven I/O kh√¥ng ƒë∆∞·ª£c c√°c h·ªá ƒëi·ªÅu h√†nh hi·ªán ƒë·∫°i h·ªó tr·ª£, v√¨ v·∫≠y n√≥ kh√¥ng hi·ªáu qu·∫£ cho h·∫ßu h·∫øt c√°c ·ª©ng d·ª•ng.",
                "D. N√≥ bu·ªôc CPU ph·∫£i ki·ªÉm tra tr·∫°ng th√°i thi·∫øt b·ªã I/O li√™n t·ª•c, ti√™u t·ªën th·ªùi gian x·ª≠ l√Ω qu√Ω gi√°."
            ],
            "answer": "A. C√°c ng·∫Øt th∆∞·ªùng xuy√™n c√≥ th·ªÉ d·∫´n ƒë·∫øn chi ph√≠ CPU ƒë√°ng k·ªÉ, v√¨ CPU ph·∫£i th∆∞·ªùng xuy√™n d·ª´ng t√°c v·ª• hi·ªán t·∫°i c·ªßa m√¨nh ƒë·ªÉ x·ª≠ l√Ω ng·∫Øt, c√≥ kh·∫£ nƒÉng l√†m ch·∫≠m hi·ªáu su·∫•t t·ªïng th·ªÉ.",
            "explanation": "M·∫∑c d√π t·ªët h∆°n so v·ªõi thƒÉm d√≤, m·ªói ng·∫Øt v·∫´n y√™u c·∫ßu CPU l∆∞u ng·ªØ c·∫£nh c·ªßa n√≥, nh·∫£y ƒë·∫øn tr√¨nh x·ª≠ l√Ω ng·∫Øt, ph·ª•c v·ª• thi·∫øt b·ªã, kh√¥i ph·ª•c ng·ªØ c·∫£nh v√† ti·∫øp t·ª•c. ƒê·ªëi v·ªõi c√°c thi·∫øt b·ªã t·ªëc ƒë·ªô r·∫•t cao v·ªõi c√°c l·∫ßn truy·ªÅn nh·ªè, th∆∞·ªùng xuy√™n, chi ph√≠ n√†y c√≥ th·ªÉ tr·ªü th√†nh m·ªôt n√∫t th·∫Øt c·ªï chai."
        }
    },
    {
        "id": 189,
        "en": {
            "question": "How does an interrupt-driven I/O module improve system performance compared to polling methods?",
            "options": [
                "A. It forces the CPU to constantly interact with I/O devices for data transfer, optimizing resource usage.",
                "B. It allows the CPU to focus on other tasks while waiting for an interrupt signal from an I/O device, reducing idle time.",
                "C. It allows the CPU to perform calculations while devices handle their own data transfers.",
                "D. It continuously checks the status of external devices, ensuring real-time data processing with minimal latency."
            ],
            "answer": "B. It allows the CPU to focus on other tasks while waiting for an interrupt signal from an I/O device, reducing idle time.",
            "explanation": "This is the key benefit. Instead of the CPU being stuck in a busy-wait loop (polling), it can execute other processes. The I/O device will signal the CPU via an interrupt only when it needs attention, thus eliminating wasted CPU cycles."
        },
        "vi": {
            "question": "M·ªôt m√¥-ƒëun I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt c·∫£i thi·ªán hi·ªáu su·∫•t h·ªá th·ªëng so v·ªõi c√°c ph∆∞∆°ng ph√°p thƒÉm d√≤ (polling) nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ bu·ªôc CPU ph·∫£i li√™n t·ª•c t∆∞∆°ng t√°c v·ªõi c√°c thi·∫øt b·ªã I/O ƒë·ªÉ truy·ªÅn d·ªØ li·ªáu, t·ªëi ∆∞u h√≥a vi·ªác s·ª≠ d·ª•ng t√†i nguy√™n.",
                "B. N√≥ cho ph√©p CPU t·∫≠p trung v√†o c√°c t√°c v·ª• kh√°c trong khi ch·ªù t√≠n hi·ªáu ng·∫Øt t·ª´ m·ªôt thi·∫øt b·ªã I/O, gi·∫£m th·ªùi gian nh√†n r·ªói.",
                "C. N√≥ cho ph√©p CPU th·ª±c hi·ªán c√°c t√≠nh to√°n trong khi c√°c thi·∫øt b·ªã x·ª≠ l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu c·ªßa ri√™ng ch√∫ng.",
                "D. N√≥ li√™n t·ª•c ki·ªÉm tra tr·∫°ng th√°i c·ªßa c√°c thi·∫øt b·ªã b√™n ngo√†i, ƒë·∫£m b·∫£o x·ª≠ l√Ω d·ªØ li·ªáu th·ªùi gian th·ª±c v·ªõi ƒë·ªô tr·ªÖ t·ªëi thi·ªÉu."
            ],
            "answer": "B. N√≥ cho ph√©p CPU t·∫≠p trung v√†o c√°c t√°c v·ª• kh√°c trong khi ch·ªù t√≠n hi·ªáu ng·∫Øt t·ª´ m·ªôt thi·∫øt b·ªã I/O, gi·∫£m th·ªùi gian nh√†n r·ªói.",
            "explanation": "ƒê√¢y l√† l·ª£i √≠ch ch√≠nh. Thay v√¨ CPU b·ªã k·∫πt trong m·ªôt v√≤ng l·∫∑p ch·ªù b·∫≠n (thƒÉm d√≤), n√≥ c√≥ th·ªÉ th·ª±c thi c√°c ti·∫øn tr√¨nh kh√°c. Thi·∫øt b·ªã I/O s·∫Ω ch·ªâ b√°o cho CPU th√¥ng qua m·ªôt ng·∫Øt khi n√≥ c·∫ßn s·ª± ch√∫ √Ω, do ƒë√≥ lo·∫°i b·ªè c√°c chu k·ª≥ CPU b·ªã l√£ng ph√≠."
        }
    },
    {
        "id": 190,
        "en": {
            "question": "What benefit does using an external GPU (eGPU) with a laptop provide over the laptop's integrated graphics?",
            "options": [
                "A. It allows the laptop to run multiple operating systems by distributing processing tasks between internal and external devices.",
                "B. It improves graphics performance, enabling more intensive tasks like gaming or video editing by offloading processing to a more powerful external GPU.",
                "C. It increases the laptop's internal storage capacity by providing additional physical space for memory.",
                "D. It reduces the weight of the laptop, making it easier to carry."
            ],
            "answer": "B. It improves graphics performance, enabling more intensive tasks like gaming or video editing by offloading processing to a more powerful external GPU.",
            "explanation": "An eGPU setup connects a powerful, desktop-class graphics card to a laptop via a high-speed interface like Thunderbolt. This bypasses the often weaker integrated graphics, providing a massive boost in performance for graphically demanding applications."
        },
        "vi": {
            "question": "Khi s·ª≠ d·ª•ng m·ªôt GPU b√™n ngo√†i (eGPU) v·ªõi m·ªôt m√°y t√≠nh x√°ch tay, n√≥ mang l·∫°i l·ª£i √≠ch g√¨ so v·ªõi ƒë·ªì h·ªça t√≠ch h·ª£p c·ªßa m√°y t√≠nh x√°ch tay?",
            "options": [
                "A. N√≥ cho ph√©p m√°y t√≠nh x√°ch tay ch·∫°y nhi·ªÅu h·ªá ƒëi·ªÅu h√†nh b·∫±ng c√°ch ph√¢n ph·ªëi c√°c t√°c v·ª• x·ª≠ l√Ω gi·ªØa c√°c thi·∫øt b·ªã n·ªôi b·ªô v√† b√™n ngo√†i.",
                "B. N√≥ c·∫£i thi·ªán hi·ªáu su·∫•t ƒë·ªì h·ªça, cho ph√©p c√°c t√°c v·ª• chuy√™n s√¢u h∆°n nh∆∞ ch∆°i game ho·∫∑c ch·ªânh s·ª≠a video b·∫±ng c√°ch gi·∫£m t·∫£i x·ª≠ l√Ω cho m·ªôt GPU b√™n ngo√†i m·∫°nh m·∫Ω h∆°n.",
                "C. N√≥ tƒÉng dung l∆∞·ª£ng l∆∞u tr·ªØ n·ªôi b·ªô c·ªßa m√°y t√≠nh x√°ch tay b·∫±ng c√°ch cung c·∫•p th√™m kh√¥ng gian v·∫≠t l√Ω cho b·ªô nh·ªõ.",
                "D. N√≥ l√†m gi·∫£m tr·ªçng l∆∞·ª£ng c·ªßa m√°y t√≠nh x√°ch tay, gi√∫p vi·ªác mang theo d·ªÖ d√†ng h∆°n."
            ],
            "answer": "B. N√≥ c·∫£i thi·ªán hi·ªáu su·∫•t ƒë·ªì h·ªça, cho ph√©p c√°c t√°c v·ª• chuy√™n s√¢u h∆°n nh∆∞ ch∆°i game ho·∫∑c ch·ªânh s·ª≠a video b·∫±ng c√°ch gi·∫£m t·∫£i x·ª≠ l√Ω cho m·ªôt GPU b√™n ngo√†i m·∫°nh m·∫Ω h∆°n.",
            "explanation": "M·ªôt thi·∫øt l·∫≠p eGPU k·∫øt n·ªëi m·ªôt card ƒë·ªì h·ªça m·∫°nh m·∫Ω c·ªßa m√°y t√≠nh ƒë·ªÉ b√†n v·ªõi m·ªôt m√°y t√≠nh x√°ch tay th√¥ng qua m·ªôt giao di·ªán t·ªëc ƒë·ªô cao nh∆∞ Thunderbolt. ƒêi·ªÅu n√†y b·ªè qua ƒë·ªì h·ªça t√≠ch h·ª£p th∆∞·ªùng y·∫øu h∆°n, cung c·∫•p m·ªôt s·ª± tƒÉng c∆∞·ªùng hi·ªáu su·∫•t l·ªõn cho c√°c ·ª©ng d·ª•ng ƒë√≤i h·ªèi ƒë·ªì h·ªça cao."
        }
    },
    {
        "id": 191,
        "en": {
            "question": "How does the use of an I/O channel improve the overall performance of a computer system compared to direct CPU-based data transfers?",
            "options": [
                "A. An I/O channel reduces the need for memory in the system, as it directly accesses storage devices for data retrieval.",
                "B. An I/O channel allows for parallel processing by offloading data transfer tasks from the CPU, allowing the CPU to focus on other computations.",
                "C. An I/O channel provides a more secure data path, protecting sensitive data from being processed by the CPU.",
                "D. An I/O channel requires the CPU to control all data transfer operations, making it more efficient for high-speed processing."
            ],
            "answer": "B. An I/O channel allows for parallel processing by offloading data transfer tasks from the CPU, allowing the CPU to focus on other computations.",
            "explanation": "An I/O channel is essentially a separate, specialized processor for I/O. The CPU simply tells the channel what to do (e.g., 'read 10 blocks from disk into memory'), and the channel handles the entire operation, freeing the CPU to execute other programs."
        },
        "vi": {
            "question": "Vi·ªác s·ª≠ d·ª•ng m·ªôt k√™nh I/O c·∫£i thi·ªán hi·ªáu su·∫•t t·ªïng th·ªÉ c·ªßa m·ªôt h·ªá th·ªëng m√°y t√≠nh so v·ªõi vi·ªác truy·ªÅn d·ªØ li·ªáu d·ª±a tr√™n CPU tr·ª±c ti·∫øp nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. K√™nh I/O l√†m gi·∫£m nhu c·∫ßu v·ªÅ b·ªô nh·ªõ trong h·ªá th·ªëng, v√¨ n√≥ truy c·∫≠p tr·ª±c ti·∫øp c√°c thi·∫øt b·ªã l∆∞u tr·ªØ ƒë·ªÉ truy xu·∫•t d·ªØ li·ªáu.",
                "B. M·ªôt k√™nh I/O cho ph√©p x·ª≠ l√Ω song song b·∫±ng c√°ch gi·∫£m t·∫£i c√°c t√°c v·ª• truy·ªÅn d·ªØ li·ªáu t·ª´ CPU, cho ph√©p CPU t·∫≠p trung v√†o c√°c t√≠nh to√°n kh√°c.",
                "C. K√™nh I/O cung c·∫•p m·ªôt ƒë∆∞·ªùng truy·ªÅn d·ªØ li·ªáu an to√†n h∆°n, b·∫£o v·ªá d·ªØ li·ªáu nh·∫°y c·∫£m kh·ªèi b·ªã x·ª≠ l√Ω b·ªüi CPU.",
                "D. M·ªôt k√™nh I/O y√™u c·∫ßu CPU ph·∫£i ƒëi·ªÅu khi·ªÉn t·∫•t c·∫£ c√°c ho·∫°t ƒë·ªông truy·ªÅn d·ªØ li·ªáu, l√†m cho n√≥ hi·ªáu qu·∫£ h∆°n cho vi·ªác x·ª≠ l√Ω t·ªëc ƒë·ªô cao."
            ],
            "answer": "B. M·ªôt k√™nh I/O cho ph√©p x·ª≠ l√Ω song song b·∫±ng c√°ch gi·∫£m t·∫£i c√°c t√°c v·ª• truy·ªÅn d·ªØ li·ªáu t·ª´ CPU, cho ph√©p CPU t·∫≠p trung v√†o c√°c t√≠nh to√°n kh√°c.",
            "explanation": "M·ªôt k√™nh I/O v·ªÅ c∆° b·∫£n l√† m·ªôt b·ªô x·ª≠ l√Ω ri√™ng bi·ªát, chuy√™n d·ª•ng cho I/O. CPU ch·ªâ c·∫ßn n√≥i cho k√™nh bi·∫øt ph·∫£i l√†m g√¨ (v√≠ d·ª•: 'ƒë·ªçc 10 kh·ªëi t·ª´ ƒëƒ©a v√†o b·ªô nh·ªõ'), v√† k√™nh s·∫Ω x·ª≠ l√Ω to√†n b·ªô ho·∫°t ƒë·ªông, gi·∫£i ph√≥ng CPU ƒë·ªÉ th·ª±c thi c√°c ch∆∞∆°ng tr√¨nh kh√°c."
        }
    },
    {
        "id": 192,
        "en": {
            "question": "What is the primary benefit of using an I/O processor in complex systems with heavy data transfer needs?",
            "options": [
                "A. The I/O processor can handle data transfers independently, minimizing CPU involvement and reducing the risk of CPU bottlenecks during heavy workloads.",
                "B. The I/O processor provides enhanced security features, ensuring that data transfers cannot be intercepted by unauthorized users.",
                "C. The I/O processor increases the number of I/O devices a system can support without requiring additional memory.",
                "D. The I/O processor allows the CPU to directly access any I/O device without needing additional communication protocols."
            ],
            "answer": "A. The I/O processor can handle data transfers independently, minimizing CPU involvement and reducing the risk of CPU bottlenecks during heavy workloads.",
            "explanation": "An I/O processor (or I/O channel) is a specialized CPU for I/O. It offloads the entire I/O task from the main CPU, which is crucial for maintaining high performance in systems with many high-speed I/O devices (e.g., mainframes)."
        },
        "vi": {
            "question": "L·ª£i √≠ch ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng b·ªô x·ª≠ l√Ω I/O trong c√°c h·ªá th·ªëng ph·ª©c t·∫°p c√≥ nhu c·∫ßu truy·ªÅn d·ªØ li·ªáu n·∫∑ng l√† g√¨?",
            "options": [
                "A. B·ªô x·ª≠ l√Ω I/O c√≥ th·ªÉ x·ª≠ l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu m·ªôt c√°ch ƒë·ªôc l·∫≠p, gi·∫£m thi·ªÉu s·ª± tham gia c·ªßa CPU v√† gi·∫£m nguy c∆° t·∫Øc ngh·∫Ωn CPU trong qu√° tr√¨nh l√†m vi·ªác n·∫∑ng.",
                "B. B·ªô x·ª≠ l√Ω I/O cung c·∫•p c√°c t√≠nh nƒÉng b·∫£o m·∫≠t n√¢ng cao, ƒë·∫£m b·∫£o r·∫±ng vi·ªác truy·ªÅn d·ªØ li·ªáu kh√¥ng th·ªÉ b·ªã ch·∫∑n b·ªüi ng∆∞·ªùi d√πng tr√°i ph√©p.",
                "C. B·ªô x·ª≠ l√Ω I/O tƒÉng s·ªë l∆∞·ª£ng thi·∫øt b·ªã I/O m√† m·ªôt h·ªá th·ªëng c√≥ th·ªÉ h·ªó tr·ª£ m√† kh√¥ng c·∫ßn th√™m b·ªô nh·ªõ.",
                "D. B·ªô x·ª≠ l√Ω I/O cho ph√©p CPU truy c·∫≠p tr·ª±c ti·∫øp b·∫•t k·ª≥ thi·∫øt b·ªã I/O n√†o m√† kh√¥ng c·∫ßn c√°c giao th·ª©c truy·ªÅn th√¥ng b·ªï sung."
            ],
            "answer": "A. B·ªô x·ª≠ l√Ω I/O c√≥ th·ªÉ x·ª≠ l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu m·ªôt c√°ch ƒë·ªôc l·∫≠p, gi·∫£m thi·ªÉu s·ª± tham gia c·ªßa CPU v√† gi·∫£m nguy c∆° t·∫Øc ngh·∫Ωn CPU trong qu√° tr√¨nh l√†m vi·ªác n·∫∑ng.",
            "explanation": "M·ªôt b·ªô x·ª≠ l√Ω I/O (ho·∫∑c k√™nh I/O) l√† m·ªôt CPU chuy√™n d·ª•ng cho I/O. N√≥ gi·∫£m t·∫£i to√†n b·ªô t√°c v·ª• I/O kh·ªèi CPU ch√≠nh, ƒëi·ªÅu n√†y r·∫•t quan tr·ªçng ƒë·ªÉ duy tr√¨ hi·ªáu su·∫•t cao trong c√°c h·ªá th·ªëng c√≥ nhi·ªÅu thi·∫øt b·ªã I/O t·ªëc ƒë·ªô cao (v√≠ d·ª•: m√°y t√≠nh l·ªõn)."
        }
    },
    {
        "id": 193,
        "en": {
            "question": "In an interrupt-driven I/O system, what happens when multiple I/O devices send interrupts simultaneously?",
            "options": [
                "A. The CPU processes them in parallel, sending data to all devices at the same time.",
                "B. The system hangs until one of the devices completes its interrupt signal.",
                "C. All interrupts are ignored, and the CPU continues its normal operations until the devices are ready.",
                "D. The CPU handles the interrupts sequentially, one at a time, according to their priority level, ensuring that higher-priority devices are serviced first."
            ],
            "answer": "D. The CPU handles the interrupts sequentially, one at a time, according to their priority level, ensuring that higher-priority devices are serviced first.",
            "explanation": "CPUs have an interrupt priority mechanism. When multiple interrupts occur, the CPU will service the one with the highest priority first. Lower-priority interrupts will be queued and handled after the higher-priority one is complete."
        },
        "vi": {
            "question": "Trong h·ªá th·ªëng I/O ƒëi·ªÅu khi·ªÉn b·∫±ng ng·∫Øt, ƒëi·ªÅu g√¨ x·∫£y ra khi nhi·ªÅu thi·∫øt b·ªã I/O g·ª≠i ng·∫Øt ƒë·ªìng th·ªùi?",
            "options": [
                "A. CPU x·ª≠ l√Ω ch√∫ng song song, g·ª≠i d·ªØ li·ªáu ƒë·∫øn t·∫•t c·∫£ c√°c thi·∫øt b·ªã ƒë·ªìng th·ªùi.",
                "B. H·ªá th·ªëng b·ªã treo cho ƒë·∫øn khi m·ªôt trong c√°c thi·∫øt b·ªã ho√†n th√†nh t√≠n hi·ªáu ng·∫Øt c·ªßa n√≥.",
                "C. T·∫•t c·∫£ c√°c ng·∫Øt ƒë·ªÅu b·ªã b·ªè qua, v√† CPU ti·∫øp t·ª•c c√°c ho·∫°t ƒë·ªông th√¥ng th∆∞·ªùng c·ªßa m√¨nh cho ƒë·∫øn khi c√°c thi·∫øt b·ªã s·∫µn s√†ng.",
                "D. CPU x·ª≠ l√Ω c√°c ng·∫Øt tu·∫ßn t·ª±, t·ª´ng c√°i m·ªôt, theo m·ª©c ƒë·ªô ∆∞u ti√™n c·ªßa ch√∫ng, ƒë·∫£m b·∫£o r·∫±ng c√°c thi·∫øt b·ªã c√≥ m·ª©c ƒë·ªô ∆∞u ti√™n cao h∆°n ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc."
            ],
            "answer": "D. CPU x·ª≠ l√Ω c√°c ng·∫Øt tu·∫ßn t·ª±, t·ª´ng c√°i m·ªôt, theo m·ª©c ƒë·ªô ∆∞u ti√™n c·ªßa ch√∫ng, ƒë·∫£m b·∫£o r·∫±ng c√°c thi·∫øt b·ªã c√≥ m·ª©c ƒë·ªô ∆∞u ti√™n cao h∆°n ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc.",
            "explanation": "CPU c√≥ m·ªôt c∆° ch·∫ø ∆∞u ti√™n ng·∫Øt. Khi nhi·ªÅu ng·∫Øt x·∫£y ra, CPU s·∫Ω ph·ª•c v·ª• ng·∫Øt c√≥ ∆∞u ti√™n cao nh·∫•t tr∆∞·ªõc. C√°c ng·∫Øt c√≥ ∆∞u ti√™n th·∫•p h∆°n s·∫Ω ƒë∆∞·ª£c x·∫øp h√†ng v√† x·ª≠ l√Ω sau khi ng·∫Øt c√≥ ∆∞u ti√™n cao h∆°n ho√†n t·∫•t."
        }
    },
    {
        "id": 194,
        "en": {
            "question": "A potential drawback of Programmed I/O for data transfer in a system with multiple I/O devices is:",
            "options": [
                "A. Programmed I/O uses more system memory to manage data transfers compared to other methods.",
                "B. Programmed I/O requires additional hardware, making it more expensive than other I/O methods.",
                "C. Programmed I/O can lead to inefficient CPU usage, as it forces the CPU to waste time checking the status of multiple devices in turn.",
                "D. Programmed I/O is slower than Interrupt-Driven I/O because it bypasses the CPU entirely."
            ],
            "answer": "C. Programmed I/O can lead to inefficient CPU usage, as it forces the CPU to waste time checking the status of multiple devices in turn.",
            "explanation": "The 'busy-waiting' nature of programmed I/O is its biggest flaw. The CPU is tied up polling devices and cannot perform other computations, leading to significant inefficiency, especially with many devices."
        },
        "vi": {
            "question": "M·ªôt nh∆∞·ª£c ƒëi·ªÉm ti·ªÅm t√†ng c·ªßa Programmed I/O ƒë·ªÉ truy·ªÅn d·ªØ li·ªáu trong m·ªôt h·ªá th·ªëng c√≥ nhi·ªÅu thi·∫øt b·ªã I/O l√† g√¨?",
            "options": [
                "A. Programmed I/O s·ª≠ d·ª•ng nhi·ªÅu b·ªô nh·ªõ h·ªá th·ªëng h∆°n ƒë·ªÉ qu·∫£n l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu so v·ªõi c√°c ph∆∞∆°ng ph√°p kh√°c.",
                "B. Programmed I/O y√™u c·∫ßu ph·∫ßn c·ª©ng b·ªï sung, l√†m cho n√≥ ƒë·∫Øt h∆°n c√°c ph∆∞∆°ng ph√°p I/O kh√°c.",
                "C. Programmed I/O c√≥ th·ªÉ d·∫´n ƒë·∫øn vi·ªác s·ª≠ d·ª•ng CPU kh√¥ng hi·ªáu qu·∫£, v√¨ n√≥ bu·ªôc CPU ph·∫£i l√£ng ph√≠ th·ªùi gian ki·ªÉm tra tr·∫°ng th√°i c·ªßa nhi·ªÅu thi·∫øt b·ªã l·∫ßn l∆∞·ª£t.",
                "D. Programmed I/O ch·∫≠m h∆°n Interrupt-Driven I/O v√¨ n√≥ b·ªè qua ho√†n to√†n CPU."
            ],
            "answer": "C. Programmed I/O c√≥ th·ªÉ d·∫´n ƒë·∫øn vi·ªác s·ª≠ d·ª•ng CPU kh√¥ng hi·ªáu qu·∫£, v√¨ n√≥ bu·ªôc CPU ph·∫£i l√£ng ph√≠ th·ªùi gian ki·ªÉm tra tr·∫°ng th√°i c·ªßa nhi·ªÅu thi·∫øt b·ªã l·∫ßn l∆∞·ª£t.",
            "explanation": "B·∫£n ch·∫•t 'ch·ªù b·∫≠n' c·ªßa I/O ƒë∆∞·ª£c l·∫≠p tr√¨nh l√† thi·∫øu s√≥t l·ªõn nh·∫•t c·ªßa n√≥. CPU b·ªã r√†ng bu·ªôc b·ªüi vi·ªác thƒÉm d√≤ c√°c thi·∫øt b·ªã v√† kh√¥ng th·ªÉ th·ª±c hi·ªán c√°c t√≠nh to√°n kh√°c, d·∫´n ƒë·∫øn s·ª± k√©m hi·ªáu qu·∫£ ƒë√°ng k·ªÉ, ƒë·∫∑c bi·ªát l√† v·ªõi nhi·ªÅu thi·∫øt b·ªã."
        }
    },
    {
        "id": 195,
        "en": {
            "question": "How does Programmed I/O differ from Interrupt-Driven I/O in terms of CPU involvement?",
            "options": [
                "A. Programmed I/O requires the CPU to continuously check the status of the I/O device, while Interrupt-Driven I/O allows the CPU to perform other tasks and only interact when an interrupt occurs.",
                "B. Programmed I/O allows multiple devices to send data simultaneously without any CPU involvement.",
                "C. Programmed I/O requires less CPU involvement, as the CPU only needs to check the device status infrequently.",
                "D. Programmed I/O operates independently of the CPU and does not require its intervention for data transfers."
            ],
            "answer": "A. Programmed I/O requires the CPU to continuously check the status of the I/O device, while Interrupt-Driven I/O allows the CPU to perform other tasks and only interact when an interrupt occurs.",
            "explanation": "This is the fundamental difference. Programmed I/O is a 'pull' model where the CPU actively checks. Interrupt-driven I/O is a 'push' model where the device actively notifies the CPU."
        },
        "vi": {
            "question": "Programmed I/O kh√°c v·ªõi Interrupt-Driven I/O v·ªÅ s·ª± tham gia c·ªßa CPU nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. Programmed I/O y√™u c·∫ßu CPU ph·∫£i li√™n t·ª•c ki·ªÉm tra tr·∫°ng th√°i c·ªßa thi·∫øt b·ªã I/O, trong khi Interrupt-Driven I/O cho ph√©p CPU th·ª±c hi·ªán c√°c t√°c v·ª• kh√°c v√† ch·ªâ t∆∞∆°ng t√°c khi c√≥ ng·∫Øt x·∫£y ra.",
                "B. Programmed I/O cho ph√©p nhi·ªÅu thi·∫øt b·ªã g·ª≠i d·ªØ li·ªáu ƒë·ªìng th·ªùi m√† kh√¥ng c√≥ b·∫•t k·ª≥ s·ª± tham gia n√†o c·ªßa CPU.",
                "C. Programmed I/O y√™u c·∫ßu √≠t s·ª± tham gia c·ªßa CPU h∆°n, v√¨ CPU ch·ªâ c·∫ßn ki·ªÉm tra tr·∫°ng th√°i c·ªßa thi·∫øt b·ªã m·ªôt c√°ch kh√¥ng th∆∞·ªùng xuy√™n.",
                "D. Programmed I/O ho·∫°t ƒë·ªông ƒë·ªôc l·∫≠p v·ªõi CPU v√† kh√¥ng c·∫ßn s·ª± can thi·ªáp c·ªßa n√≥ ƒë·ªÉ truy·ªÅn d·ªØ li·ªáu."
            ],
            "answer": "A. Programmed I/O y√™u c·∫ßu CPU ph·∫£i li√™n t·ª•c ki·ªÉm tra tr·∫°ng th√°i c·ªßa thi·∫øt b·ªã I/O, trong khi Interrupt-Driven I/O cho ph√©p CPU th·ª±c hi·ªán c√°c t√°c v·ª• kh√°c v√† ch·ªâ t∆∞∆°ng t√°c khi c√≥ ng·∫Øt x·∫£y ra.",
            "explanation": "ƒê√¢y l√† s·ª± kh√°c bi·ªát c∆° b·∫£n. Programmed I/O l√† m·ªôt m√¥ h√¨nh 'k√©o' n∆°i CPU ch·ªß ƒë·ªông ki·ªÉm tra. Interrupt-driven I/O l√† m·ªôt m√¥ h√¨nh 'ƒë·∫©y' n∆°i thi·∫øt b·ªã ch·ªß ƒë·ªông th√¥ng b√°o cho CPU."
        }
    },
    {
        "id": 196,
        "en": {
            "question": "What is the primary function of an I/O processor in a system with multiple I/O devices?",
            "options": [
                "A. It manages the exchange of data between I/O devices and memory, allowing multiple devices to operate simultaneously without burdening the CPU.",
                "B. It assigns priority tasks to different I/O devices, ensuring that the CPU focuses on the most critical ones first.",
                "C. It stores all incoming and outgoing data in the system cache to optimize processing speed.",
                "D. It generates interrupts to inform the CPU about available memory for data storage."
            ],
            "answer": "A. It manages the exchange of data between I/O devices and memory, allowing multiple devices to operate simultaneously without burdening the CPU.",
            "explanation": "An I/O processor (or channel) is a specialized CPU that offloads I/O tasks from the main CPU, managing data transfers and allowing for concurrent I/O operations, which is crucial for high-performance systems."
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng ch√≠nh c·ªßa m·ªôt b·ªô x·ª≠ l√Ω I/O trong m·ªôt h·ªá th·ªëng c√≥ nhi·ªÅu thi·∫øt b·ªã I/O l√† g√¨?",
            "options": [
                "A. N√≥ qu·∫£n l√Ω vi·ªác trao ƒë·ªïi d·ªØ li·ªáu gi·ªØa c√°c thi·∫øt b·ªã I/O v√† b·ªô nh·ªõ, cho ph√©p nhi·ªÅu thi·∫øt b·ªã ho·∫°t ƒë·ªông ƒë·ªìng th·ªùi m√† kh√¥ng l√†m g√°nh n·∫∑ng cho CPU.",
                "B. N√≥ g√°n c√°c t√°c v·ª• ∆∞u ti√™n cho c√°c thi·∫øt b·ªã I/O kh√°c nhau, ƒë·∫£m b·∫£o r·∫±ng CPU t·∫≠p trung v√†o c√°c thi·∫øt b·ªã quan tr·ªçng nh·∫•t tr∆∞·ªõc ti√™n.",
                "C. N√≥ l∆∞u tr·ªØ t·∫•t c·∫£ d·ªØ li·ªáu ƒë·∫øn v√† ƒëi trong b·ªô nh·ªõ cache c·ªßa h·ªá th·ªëng ƒë·ªÉ t·ªëi ∆∞u h√≥a t·ªëc ƒë·ªô x·ª≠ l√Ω.",
                "D. N√≥ t·∫°o ra c√°c ng·∫Øt ƒë·ªÉ th√¥ng b√°o cho CPU v·ªÅ b·ªô nh·ªõ c√≥ s·∫µn ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu."
            ],
            "answer": "A. N√≥ qu·∫£n l√Ω vi·ªác trao ƒë·ªïi d·ªØ li·ªáu gi·ªØa c√°c thi·∫øt b·ªã I/O v√† b·ªô nh·ªõ, cho ph√©p nhi·ªÅu thi·∫øt b·ªã ho·∫°t ƒë·ªông ƒë·ªìng th·ªùi m√† kh√¥ng l√†m g√°nh n·∫∑ng cho CPU.",
            "explanation": "M·ªôt b·ªô x·ª≠ l√Ω I/O (ho·∫∑c k√™nh) l√† m·ªôt CPU chuy√™n d·ª•ng gi√∫p gi·∫£m t·∫£i c√°c t√°c v·ª• I/O kh·ªèi CPU ch√≠nh, qu·∫£n l√Ω vi·ªác truy·ªÅn d·ªØ li·ªáu v√† cho ph√©p c√°c ho·∫°t ƒë·ªông I/O ƒë·ªìng th·ªùi, ƒëi·ªÅu n√†y r·∫•t quan tr·ªçng ƒë·ªëi v·ªõi c√°c h·ªá th·ªëng hi·ªáu su·∫•t cao."
        }
    },
    {
        "id": 197,
        "en": {
            "question": "In the context of Programmed I/O, what is the role of the I/O port?",
            "options": [
                "A. The I/O port encrypts data before it is transferred to external devices for security purposes.",
                "B. The I/O port temporarily stores data before it is processed by the CPU.",
                "C. The I/O port processes data and sends it to the correct main memory location.",
                "D. The I/O port acts as an interface between the CPU and external devices, allowing the CPU to send and receive data directly."
            ],
            "answer": "D. The I/O port acts as an interface between the CPU and external devices, allowing the CPU to send and receive data directly.",
            "explanation": "An I/O port is an addressable location (in either a separate I/O address space or mapped into the memory address space) that the CPU uses to communicate with an I/O module's registers (e.g., status, control, data registers)."
        },
        "vi": {
            "question": "Trong b·ªëi c·∫£nh c·ªßa Programmed I/O, vai tr√≤ c·ªßa c·ªïng I/O l√† g√¨?",
            "options": [
                "A. C·ªïng I/O m√£ h√≥a d·ªØ li·ªáu tr∆∞·ªõc khi n√≥ ƒë∆∞·ª£c truy·ªÅn ƒë·∫øn c√°c thi·∫øt b·ªã b√™n ngo√†i cho m·ª•c ƒë√≠ch b·∫£o m·∫≠t.",
                "B. C·ªïng I/O l∆∞u tr·ªØ t·∫°m th·ªùi d·ªØ li·ªáu tr∆∞·ªõc khi n√≥ ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi CPU.",
                "C. C·ªïng I/O x·ª≠ l√Ω d·ªØ li·ªáu v√† g·ª≠i n√≥ ƒë·∫øn v·ªã tr√≠ b·ªô nh·ªõ ch√≠nh x√°c.",
                "D. C·ªïng I/O ho·∫°t ƒë·ªông nh∆∞ m·ªôt giao di·ªán gi·ªØa CPU v√† c√°c thi·∫øt b·ªã b√™n ngo√†i, cho ph√©p CPU g·ª≠i v√† nh·∫≠n d·ªØ li·ªáu tr·ª±c ti·∫øp."
            ],
            "answer": "D. C·ªïng I/O ho·∫°t ƒë·ªông nh∆∞ m·ªôt giao di·ªán gi·ªØa CPU v√† c√°c thi·∫øt b·ªã b√™n ngo√†i, cho ph√©p CPU g·ª≠i v√† nh·∫≠n d·ªØ li·ªáu tr·ª±c ti·∫øp.",
            "explanation": "M·ªôt c·ªïng I/O l√† m·ªôt v·ªã tr√≠ c√≥ th·ªÉ ƒë·ªãnh ƒë·ªãa ch·ªâ (trong m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ I/O ri√™ng bi·ªát ho·∫∑c ƒë∆∞·ª£c √°nh x·∫° v√†o kh√¥ng gian ƒë·ªãa ch·ªâ b·ªô nh·ªõ) m√† CPU s·ª≠ d·ª•ng ƒë·ªÉ giao ti·∫øp v·ªõi c√°c thanh ghi c·ªßa m√¥-ƒëun I/O (v√≠ d·ª•: thanh ghi tr·∫°ng th√°i, ƒëi·ªÅu khi·ªÉn, d·ªØ li·ªáu)."
        }
    },
    {
        "id": 198,
        "en": {
            "question": "The ____ is a module that contains I/O logic, a processor, and local memory.",
            "options": [
                "A. I/O Channel",
                "B. I/O Processor",
                "C. DMA Module",
                "D. I/O Controller"
            ],
            "answer": "B. I/O Processor",
            "explanation": "An I/O Processor (IOP) is the most sophisticated form of I/O module, containing its own processor and memory to execute I/O programs independently of the main CPU."
        },
        "vi": {
            "question": "____ l√† m·ªôt m√¥-ƒëun ch·ª©a logic I/O, m·ªôt b·ªô x·ª≠ l√Ω v√† b·ªô nh·ªõ c·ª•c b·ªô.",
            "options": [
                "A. K√™nh I/O (I/O Channel)",
                "B. B·ªô x·ª≠ l√Ω I/O (I/O Processor)",
                "C. M√¥-ƒëun DMA (DMA Module)",
                "D. B·ªô ƒëi·ªÅu khi·ªÉn I/O (I/O Controller)"
            ],
            "answer": "B. B·ªô x·ª≠ l√Ω I/O (I/O Processor)",
            "explanation": "M·ªôt B·ªô x·ª≠ l√Ω I/O (IOP) l√† d·∫°ng m√¥-ƒëun I/O ph·ª©c t·∫°p nh·∫•t, ch·ª©a b·ªô x·ª≠ l√Ω v√† b·ªô nh·ªõ ri√™ng ƒë·ªÉ th·ª±c thi c√°c ch∆∞∆°ng tr√¨nh I/O ƒë·ªôc l·∫≠p v·ªõi CPU ch√≠nh."
        }
    },
    {
        "id": 199,
        "en": {
            "question": "____ determines which process's pending I/O request shall be handled by an available I/O device.",
            "options": [
                "A. Medium-term scheduling",
                "B. Short-term scheduling",
                "C. I/O scheduling",
                "D. Long-term scheduling"
            ],
            "answer": "C. I/O scheduling",
            "explanation": "I/O scheduling is the decision-making process of the OS to determine the order in which to service the queue of I/O requests for a particular device, often to optimize seek time or throughput."
        },
        "vi": {
            "question": "Quy·∫øt ƒë·ªãnh v·ªÅ y√™u c·∫ßu I/O ƒëang ch·ªù x·ª≠ l√Ω c·ªßa ti·∫øn tr√¨nh n√†o s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi m·ªôt thi·∫øt b·ªã I/O c√≥ s·∫µn.",
            "options": [
                "A. L·∫≠p l·ªãch trung h·∫°n",
                "B. L·∫≠p l·ªãch ng·∫Øn h·∫°n",
                "C. L·∫≠p l·ªãch I/O",
                "D. L·∫≠p l·ªãch d√†i h·∫°n"
            ],
            "answer": "C. L·∫≠p l·ªãch I/O",
            "explanation": "L·∫≠p l·ªãch I/O l√† qu√° tr√¨nh ra quy·∫øt ƒë·ªãnh c·ªßa HƒêH ƒë·ªÉ x√°c ƒë·ªãnh th·ª© t·ª± ph·ª•c v·ª• h√†ng ƒë·ª£i c√°c y√™u c·∫ßu I/O cho m·ªôt thi·∫øt b·ªã c·ª• th·ªÉ, th∆∞·ªùng l√† ƒë·ªÉ t·ªëi ∆∞u h√≥a th·ªùi gian t√¨m ki·∫øm ho·∫∑c th√¥ng l∆∞·ª£ng."
        }
    }, // <-- ƒê·ª™NG QU√äN D·∫§U PH·∫®Y N√ÄY KHI N·ªêI V√ÄO SAU PH·∫¶N 2
    // Chuy√™n m·ª•c 8: Operating System Support (H·ªó tr·ª£ H·ªá ƒëi·ªÅu h√†nh) - 25 c√¢u
    {
        "id": 200,
        "en": {
            "question": "What is the initial state of a process when it is admitted by the high-level scheduler but is not yet ready for execution?",
            "options": [
                "A. New",
                "B. Ready",
                "C. Running",
                "D. Halted"
            ],
            "answer": "A. New",
            "explanation": "The 'New' state is the first state of a process. It has been created but has not yet been admitted to the pool of executable processes by the operating system."
        },
        "vi": {
            "question": "Tr·∫°ng th√°i ban ƒë·∫ßu c·ªßa m·ªôt ti·∫øn tr√¨nh khi n√≥ ƒë∆∞·ª£c b·ªô l·∫≠p l·ªãch c·∫•p cao ch·∫•p nh·∫≠n nh∆∞ng ch∆∞a s·∫µn s√†ng ƒë·ªÉ th·ª±c thi l√† g√¨?",
            "options": [
                "A. M·ªõi (New)",
                "B. S·∫µn s√†ng (Ready)",
                "C. ƒêang ch·∫°y (Running)",
                "D. T·∫°m d·ª´ng (Halted)"
            ],
            "answer": "A. M·ªõi (New)",
            "explanation": "Tr·∫°ng th√°i 'M·ªõi' l√† tr·∫°ng th√°i ƒë·∫ßu ti√™n c·ªßa m·ªôt ti·∫øn tr√¨nh. N√≥ ƒë√£ ƒë∆∞·ª£c t·∫°o ra nh∆∞ng ch∆∞a ƒë∆∞·ª£c h·ªá ƒëi·ªÅu h√†nh ch·∫•p nh·∫≠n v√†o nh√≥m c√°c ti·∫øn tr√¨nh c√≥ th·ªÉ th·ª±c thi."
        }
    },
    {
        "id": 201,
        "en": {
            "question": "Which state indicates that a process is currently being executed by the processor?",
            "options": [
                "A. Running",
                "B. Ready",
                "C. NewBorn",
                "D. Halted"
            ],
            "answer": "A. Running",
            "explanation": "The 'Running' state means the process's instructions are being executed by a CPU core."
        },
        "vi": {
            "question": "Tr·∫°ng th√°i n√†o cho bi·∫øt m·ªôt ti·∫øn tr√¨nh hi·ªán ƒëang ƒë∆∞·ª£c b·ªô x·ª≠ l√Ω th·ª±c thi?",
            "options": [
                "A. ƒêang ch·∫°y (Running)",
                "B. S·∫µn s√†ng (Ready)",
                "C. M·ªõi sinh (NewBorn)",
                "D. T·∫°m d·ª´ng (Halted)"
            ],
            "answer": "A. ƒêang ch·∫°y (Running)",
            "explanation": "Tr·∫°ng th√°i 'ƒêang ch·∫°y' c√≥ nghƒ©a l√† c√°c l·ªánh c·ªßa ti·∫øn tr√¨nh ƒëang ƒë∆∞·ª£c m·ªôt l√µi CPU th·ª±c thi."
        }
    },
    {
        "id": 202,
        "en": {
            "question": "Which of the following statements is incorrect about the Translation Look-aside Buffer (TLB)?",
            "options": [
                "A. The use of a TLB eliminates the need to keep a page table in memory.",
                "B. The TLB maintains only a subset of the entries stored in the full memory-based page table.",
                "C. When a TLB miss occurs, the system needs to access the page table.",
                "D. The TLB is a cache that stores recent translations of virtual memory to physical memory."
            ],
            "answer": "A. The use of a TLB eliminates the need to keep a page table in memory.",
            "explanation": "This is incorrect. The TLB is a cache for the page table. The full page table must still exist in main memory to handle TLB misses."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† kh√¥ng ch√≠nh x√°c v·ªÅ Translation Look-aside Buffer (TLB)?",
            "options": [
                "A. Vi·ªác s·ª≠ d·ª•ng TLB lo·∫°i b·ªè nhu c·∫ßu gi·ªØ m·ªôt b·∫£ng trang trong b·ªô nh·ªõ.",
                "B. TLB ch·ªâ duy tr√¨ m·ªôt t·∫≠p h·ª£p con c√°c m·ª•c ƒë∆∞·ª£c l∆∞u tr·ªØ trong b·∫£ng trang ƒë·∫ßy ƒë·ªß d·ª±a tr√™n b·ªô nh·ªõ.",
                "C. Khi c√≥ m·ªôt TLB miss, h·ªá th·ªëng c·∫ßn truy c·∫≠p b·∫£ng trang.",
                "D. TLB l√† m·ªôt b·ªô nh·ªõ cache l∆∞u tr·ªØ c√°c b·∫£n d·ªãch g·∫ßn ƒë√¢y c·ªßa b·ªô nh·ªõ ·∫£o sang b·ªô nh·ªõ v·∫≠t l√Ω."
            ],
            "answer": "A. Vi·ªác s·ª≠ d·ª•ng TLB lo·∫°i b·ªè nhu c·∫ßu gi·ªØ m·ªôt b·∫£ng trang trong b·ªô nh·ªõ.",
            "explanation": "ƒêi·ªÅu n√†y kh√¥ng ch√≠nh x√°c. TLB l√† m·ªôt b·ªô ƒë·ªám cho b·∫£ng trang. B·∫£ng trang ƒë·∫ßy ƒë·ªß v·∫´n ph·∫£i t·ªìn t·∫°i trong b·ªô nh·ªõ ch√≠nh ƒë·ªÉ x·ª≠ l√Ω c√°c l·∫ßn TLB miss."
        }
    },
    {
        "id": 203,
        "en": {
            "question": "Which method allows a programmer to view memory as consisting of multiple address spaces and is used to map variable-length logical addresses into physical memory?",
            "options": [
                "A. Paging",
                "B. Overlays",
                "C. Segmentation",
                "D. Paging with segmentation"
            ],
            "answer": "C. Segmentation",
            "explanation": "Segmentation divides memory into logical, variable-sized segments (like code, data, stack). This aligns with how a programmer views a program, unlike paging which uses fixed-size physical frames."
        },
        "vi": {
            "question": "Ph∆∞∆°ng ph√°p n√†o cho ph√©p l·∫≠p tr√¨nh vi√™n xem b·ªô nh·ªõ nh∆∞ bao g·ªìm nhi·ªÅu kh√¥ng gian ƒë·ªãa ch·ªâ v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ √°nh x·∫° c√°c ƒë·ªãa ch·ªâ logic c√≥ ƒë·ªô d√†i thay ƒë·ªïi v√†o b·ªô nh·ªõ v·∫≠t l√Ω?",
            "options": [
                "A. Ph√¢n trang (Paging)",
                "B. L·ªõp ph·ªß (Overlays)",
                "C. Ph√¢n ƒëo·∫°n (Segmentation)",
                "D. Ph√¢n trang v·ªõi ph√¢n ƒëo·∫°n (Paging with segmentation)"
            ],
            "answer": "C. Ph√¢n ƒëo·∫°n (Segmentation)",
            "explanation": "Ph√¢n ƒëo·∫°n chia b·ªô nh·ªõ th√†nh c√°c ƒëo·∫°n logic c√≥ k√≠ch th∆∞·ªõc thay ƒë·ªïi (nh∆∞ m√£, d·ªØ li·ªáu, ngƒÉn x·∫øp). ƒêi·ªÅu n√†y ph√π h·ª£p v·ªõi c√°ch l·∫≠p tr√¨nh vi√™n xem m·ªôt ch∆∞∆°ng tr√¨nh, kh√¥ng gi·ªëng nh∆∞ ph√¢n trang s·ª≠ d·ª•ng c√°c khung v·∫≠t l√Ω c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh."
        }
    },
    {
        "id": 204,
        "en": {
            "question": "What is the primary function of an Operating System (OS) in a computer system?",
            "options": [
                "A. To manage hardware resources and provide a stable environment for software applications to run.",
                "B. To store and retrieve data in external storage devices.",
                "C. To design and implement software applications that interact directly with the hardware.",
                "D. To serve as the primary communication channel between the user and the computer's hardware."
            ],
            "answer": "A. To manage hardware resources and provide a stable environment for software applications to run.",
            "explanation": "The OS acts as an intermediary, abstracting the complex hardware and managing resources like the CPU, memory, and I/O devices to ensure fair and efficient use by applications."
        },
        "vi": {
            "question": "Ch·ª©c nƒÉng ch√≠nh c·ªßa m·ªôt H·ªá ƒëi·ªÅu h√†nh (OS) trong m·ªôt h·ªá th·ªëng m√°y t√≠nh l√† g√¨?",
            "options": [
                "A. ƒê·ªÉ qu·∫£n l√Ω t√†i nguy√™n ph·∫ßn c·ª©ng v√† cung c·∫•p m·ªôt m√¥i tr∆∞·ªùng ·ªïn ƒë·ªãnh cho c√°c ·ª©ng d·ª•ng ph·∫ßn m·ªÅm ch·∫°y.",
                "B. ƒê·ªÉ l∆∞u tr·ªØ v√† truy xu·∫•t d·ªØ li·ªáu trong c√°c thi·∫øt b·ªã l∆∞u tr·ªØ b√™n ngo√†i.",
                "C. ƒê·ªÉ thi·∫øt k·∫ø v√† tri·ªÉn khai c√°c ·ª©ng d·ª•ng ph·∫ßn m·ªÅm t∆∞∆°ng t√°c tr·ª±c ti·∫øp v·ªõi ph·∫ßn c·ª©ng.",
                "D. ƒê·ªÉ ph·ª•c v·ª• nh∆∞ l√† k√™nh giao ti·∫øp ch√≠nh gi·ªØa ng∆∞·ªùi d√πng v√† ph·∫ßn c·ª©ng c·ªßa m√°y t√≠nh."
            ],
            "answer": "A. ƒê·ªÉ qu·∫£n l√Ω t√†i nguy√™n ph·∫ßn c·ª©ng v√† cung c·∫•p m·ªôt m√¥i tr∆∞·ªùng ·ªïn ƒë·ªãnh cho c√°c ·ª©ng d·ª•ng ph·∫ßn m·ªÅm ch·∫°y.",
            "explanation": "HƒêH ho·∫°t ƒë·ªông nh∆∞ m·ªôt trung gian, tr·ª´u t∆∞·ª£ng h√≥a ph·∫ßn c·ª©ng ph·ª©c t·∫°p v√† qu·∫£n l√Ω c√°c t√†i nguy√™n nh∆∞ CPU, b·ªô nh·ªõ v√† c√°c thi·∫øt b·ªã I/O ƒë·ªÉ ƒë·∫£m b·∫£o vi·ªác s·ª≠ d·ª•ng c√¥ng b·∫±ng v√† hi·ªáu qu·∫£ b·ªüi c√°c ·ª©ng d·ª•ng."
        }
    },
    {
        "id": 205,
        "en": {
            "question": "To read and write from the main memory, the ____ translates each virtual address into a physical address in main memory.",
            "options": [
                "A. MAR",
                "B. MMU",
                "C. Overlays",
                "D. TLB"
            ],
            "answer": "B. MMU",
            "explanation": "The Memory Management Unit (MMU) is the hardware component responsible for handling all memory accesses and performing the translation from virtual addresses (used by programs) to physical addresses (used by the hardware)."
        },
        "vi": {
            "question": "ƒê·ªÉ ƒë·ªçc v√† ghi t·ª´ b·ªô nh·ªõ ch√≠nh, ___ d·ªãch m·ªói ƒë·ªãa ch·ªâ ·∫£o th√†nh m·ªôt ƒë·ªãa ch·ªâ v·∫≠t l√Ω trong b·ªô nh·ªõ ch√≠nh.",
            "options": [
                "A. MAR",
                "B. MMU",
                "C. Overlays",
                "D. TLB"
            ],
            "answer": "B. MMU",
            "explanation": "ƒê∆°n v·ªã qu·∫£n l√Ω b·ªô nh·ªõ (MMU) l√† th√†nh ph·∫ßn ph·∫ßn c·ª©ng ch·ªãu tr√°ch nhi·ªám x·ª≠ l√Ω t·∫•t c·∫£ c√°c truy c·∫≠p b·ªô nh·ªõ v√† th·ª±c hi·ªán vi·ªác d·ªãch t·ª´ ƒë·ªãa ch·ªâ ·∫£o (ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi c√°c ch∆∞∆°ng tr√¨nh) sang ƒë·ªãa ch·ªâ v·∫≠t l√Ω (ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ph·∫ßn c·ª©ng)."
        }
    },
    {
        "id": 206,
        "en": {
            "question": "We have a long-term queue of process requests, which is typically stored on ____.",
            "options": [
                "A. main memory",
                "B. disk",
                "C. cache",
                "D. register"
            ],
            "answer": "B. disk",
            "explanation": "The long-term scheduler selects processes from a pool of jobs on the disk (secondary storage) and loads them into main memory to become ready processes."
        },
        "vi": {
            "question": "Ch√∫ng ta c√≥ m·ªôt h√†ng ƒë·ª£i d√†i h·∫°n c√°c y√™u c·∫ßu ti·∫øn tr√¨nh, th∆∞·ªùng ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n ___.",
            "options": [
                "A. b·ªô nh·ªõ ch√≠nh",
                "B. ƒëƒ©a",
                "C. b·ªô nh·ªõ cache",
                "D. thanh ghi"
            ],
            "answer": "B. ƒëƒ©a",
            "explanation": "B·ªô l·∫≠p l·ªãch d√†i h·∫°n ch·ªçn c√°c ti·∫øn tr√¨nh t·ª´ m·ªôt nh√≥m c√¥ng vi·ªác tr√™n ƒëƒ©a (b·ªô nh·ªõ th·ª© c·∫•p) v√† n·∫°p ch√∫ng v√†o b·ªô nh·ªõ ch√≠nh ƒë·ªÉ tr·ªü th√†nh c√°c ti·∫øn tr√¨nh s·∫µn s√†ng."
        }
    },
    {
        "id": 207,
        "en": {
            "question": "A process that is in the ____ state can transition to the ready, terminated, or waiting state.",
            "options": [
                "A. hold or running",
                "B. running",
                "C. hold",
                "D. virtual"
            ],
            "answer": "B. running",
            "explanation": "From the 'Running' state, a process can: 1) be preempted and move to 'Ready', 2) complete execution and move to 'Terminated', or 3) request I/O and move to 'Waiting' (or Blocked)."
        },
        "vi": {
            "question": "M·ªôt ti·∫øn tr√¨nh ·ªü tr·∫°ng th√°i ____ c√≥ th·ªÉ chuy·ªÉn sang tr·∫°ng th√°i s·∫µn s√†ng, k·∫øt th√∫c ho·∫∑c ch·ªù.",
            "options": [
                "A. gi·ªØ ho·∫∑c ƒëang ch·∫°y (hold or running)",
                "B. ƒëang ch·∫°y (running)",
                "C. gi·ªØ (hold)",
                "D. ·∫£o (virtual)"
            ],
            "answer": "B. ƒëang ch·∫°y (running)",
            "explanation": "T·ª´ tr·∫°ng th√°i 'ƒêang ch·∫°y', m·ªôt ti·∫øn tr√¨nh c√≥ th·ªÉ: 1) b·ªã ng·∫Øt v√† chuy·ªÉn sang 'S·∫µn s√†ng', 2) ho√†n th√†nh th·ª±c thi v√† chuy·ªÉn sang 'K·∫øt th√∫c', ho·∫∑c 3) y√™u c·∫ßu I/O v√† chuy·ªÉn sang 'Ch·ªù' (ho·∫∑c B·ªã ch·∫∑n)."
        }
    },
    {
        "id": 208,
        "en": {
            "question": "What is the primary purpose of memory management in an operating system?",
            "options": [
                "A. To allocate memory for system processes, leaving user processes to manage their own memory.",
                "B. To provide exclusive memory for high-priority tasks, ignoring lower-priority tasks.",
                "C. To ensure efficient allocation and deallocation of memory for processes, preventing fragmentation and optimizing performance.",
                "D. To maintain a constant amount of memory available for all running processes regardless of their size."
            ],
            "answer": "C. To ensure efficient allocation and deallocation of memory for processes, preventing fragmentation and optimizing performance.",
            "explanation": "Effective memory management is crucial for a multitasking OS. It involves tracking memory usage, allocating space to processes when they need it, deallocating it when they are done, and managing virtual memory to create an illusion of more memory than is physically available."
        },
        "vi": {
            "question": "M·ª•c ƒë√≠ch ch√≠nh c·ªßa vi·ªác qu·∫£n l√Ω b·ªô nh·ªõ trong m·ªôt h·ªá ƒëi·ªÅu h√†nh l√† g√¨?",
            "options": [
                "A. Ph√¢n b·ªï b·ªô nh·ªõ cho c√°c ti·∫øn tr√¨nh h·ªá th·ªëng, ƒë·ªÉ l·∫°i c√°c ti·∫øn tr√¨nh ng∆∞·ªùi d√πng t·ª± qu·∫£n l√Ω b·ªô nh·ªõ c·ªßa m√¨nh.",
                "B. Cung c·∫•p b·ªô nh·ªõ ƒë·ªôc quy·ªÅn cho c√°c t√°c v·ª• ∆∞u ti√™n cao, b·ªè qua c√°c t√°c v·ª• ∆∞u ti√™n th·∫•p h∆°n.",
                "C. ƒê·∫£m b·∫£o ph√¢n b·ªï v√† gi·∫£i ph√≥ng b·ªô nh·ªõ hi·ªáu qu·∫£ cho c√°c ti·∫øn tr√¨nh, ngƒÉn ch·∫∑n s·ª± ph√¢n m·∫£nh v√† t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t.",
                "D. Duy tr√¨ m·ªôt l∆∞·ª£ng b·ªô nh·ªõ kh√¥ng ƒë·ªïi c√≥ s·∫µn cho t·∫•t c·∫£ c√°c ti·∫øn tr√¨nh ƒëang ch·∫°y b·∫•t k·ªÉ k√≠ch th∆∞·ªõc c·ªßa ch√∫ng."
            ],
            "answer": "C. ƒê·∫£m b·∫£o ph√¢n b·ªï v√† gi·∫£i ph√≥ng b·ªô nh·ªõ hi·ªáu qu·∫£ cho c√°c ti·∫øn tr√¨nh, ngƒÉn ch·∫∑n s·ª± ph√¢n m·∫£nh v√† t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t.",
            "explanation": "Qu·∫£n l√Ω b·ªô nh·ªõ hi·ªáu qu·∫£ l√† r·∫•t quan tr·ªçng ƒë·ªëi v·ªõi m·ªôt HƒêH ƒëa nhi·ªám. N√≥ bao g·ªìm vi·ªác theo d√µi vi·ªác s·ª≠ d·ª•ng b·ªô nh·ªõ, ph√¢n b·ªï kh√¥ng gian cho c√°c ti·∫øn tr√¨nh khi ch√∫ng c·∫ßn, gi·∫£i ph√≥ng n√≥ khi ch√∫ng ho√†n th√†nh, v√† qu·∫£n l√Ω b·ªô nh·ªõ ·∫£o ƒë·ªÉ t·∫°o ra ·∫£o gi√°c c√≥ nhi·ªÅu b·ªô nh·ªõ h∆°n so v·ªõi th·ª±c t·∫ø."
        }
    },
    {
        "id": 209,
        "en": {
            "question": "What is the main advantage of segmentation over paging in memory management?",
            "options": [
                "A. Segmentation allows processes to be divided into variable-sized segments, which can better reflect logical divisions like functions or data structures.",
                "B. Segmentation always results in less memory overhead than paging.",
                "C. Segmentation eliminates the need for memory protection, making it faster and more efficient.",
                "D. Segmentation operates without a memory management unit (MMU)."
            ],
            "answer": "A. Segmentation allows processes to be divided into variable-sized segments, which can better reflect logical divisions like functions or data structures.",
            "explanation": "Segmentation provides a logical, programmer-centric view of memory (code segment, data segment, etc.), which can simplify linking and sharing and provide more granular protection. Paging is physically oriented and transparent to the programmer."
        },
        "vi": {
            "question": "L·ª£i th·∫ø ch√≠nh c·ªßa vi·ªác ph√¢n ƒëo·∫°n so v·ªõi ph√¢n trang trong qu·∫£n l√Ω b·ªô nh·ªõ l√† g√¨?",
            "options": [
                "A. Ph√¢n ƒëo·∫°n cho ph√©p c√°c ti·∫øn tr√¨nh ƒë∆∞·ª£c chia th√†nh c√°c ph√¢n ƒëo·∫°n c√≥ k√≠ch th∆∞·ªõc thay ƒë·ªïi, c√≥ th·ªÉ ph·∫£n √°nh t·ªët h∆°n c√°c b·ªô ph·∫≠n logic nh∆∞ c√°c h√†m ho·∫∑c c·∫•u tr√∫c d·ªØ li·ªáu.",
                "B. Ph√¢n ƒëo·∫°n lu√¥n d·∫´n ƒë·∫øn chi ph√≠ b·ªô nh·ªõ √≠t h∆°n so v·ªõi ph√¢n trang.",
                "C. Ph√¢n ƒëo·∫°n lo·∫°i b·ªè nhu c·∫ßu b·∫£o v·ªá b·ªô nh·ªõ, l√†m cho n√≥ nhanh h∆°n v√† hi·ªáu qu·∫£ h∆°n.",
                "D. Ph√¢n ƒëo·∫°n ho·∫°t ƒë·ªông m√† kh√¥ng c·∫ßn m·ªôt ƒë∆°n v·ªã qu·∫£n l√Ω b·ªô nh·ªõ (MMU)."
            ],
            "answer": "A. Ph√¢n ƒëo·∫°n cho ph√©p c√°c ti·∫øn tr√¨nh ƒë∆∞·ª£c chia th√†nh c√°c ph√¢n ƒëo·∫°n c√≥ k√≠ch th∆∞·ªõc thay ƒë·ªïi, c√≥ th·ªÉ ph·∫£n √°nh t·ªët h∆°n c√°c b·ªô ph·∫≠n logic nh∆∞ c√°c h√†m ho·∫∑c c·∫•u tr√∫c d·ªØ li·ªáu.",
            "explanation": "Ph√¢n ƒëo·∫°n cung c·∫•p m·ªôt c√°i nh√¨n logic, t·∫≠p trung v√†o l·∫≠p tr√¨nh vi√™n v·ªÅ b·ªô nh·ªõ (ph√¢n ƒëo·∫°n m√£, ph√¢n ƒëo·∫°n d·ªØ li·ªáu, v.v.), c√≥ th·ªÉ ƒë∆°n gi·∫£n h√≥a vi·ªác li√™n k·∫øt v√† chia s·∫ª v√† cung c·∫•p s·ª± b·∫£o v·ªá chi ti·∫øt h∆°n. Ph√¢n trang c√≥ ƒë·ªãnh h∆∞·ªõng v·∫≠t l√Ω v√† trong su·ªët ƒë·ªëi v·ªõi l·∫≠p tr√¨nh vi√™n."
        }
    },
    {
        "id": 210,
        "en": {
            "question": "How does the buddy system for memory allocation work?",
            "options": [
                "A. It assigns a fixed memory size to each process, ensuring that memory is always allocated in equal-sized blocks.",
                "B. It uses a linked list of free memory blocks to dynamically allocate and deallocate memory without any fixed size constraints.",
                "C. It divides memory into blocks of sizes that are powers of two, and merges adjacent free blocks ('buddies') when both are free, to form larger blocks.",
                "D. It reserves a specific amount of memory for each process at the start of execution, without any dynamic allocation."
            ],
            "answer": "C. It divides memory into blocks of sizes that are powers of two, and merges adjacent free blocks ('buddies') when both are free, to form larger blocks.",
            "explanation": "The buddy system is a memory allocation algorithm that efficiently allocates and deallocates blocks of memory. Its key feature is recursively splitting blocks into halves (buddies) to find a suitable size and coalescing them back together when freed to combat external fragmentation."
        },
        "vi": {
            "question": "H·ªá th·ªëng buddy ƒë·ªÉ c·∫•p ph√°t b·ªô nh·ªõ ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ g√°n m·ªôt k√≠ch th∆∞·ªõc b·ªô nh·ªõ c·ªë ƒë·ªãnh cho m·ªói ti·∫øn tr√¨nh, ƒë·∫£m b·∫£o r·∫±ng b·ªô nh·ªõ lu√¥n ƒë∆∞·ª£c c·∫•p ph√°t th√†nh c√°c kh·ªëi b·∫±ng nhau.",
                "B. N√≥ s·ª≠ d·ª•ng m·ªôt danh s√°ch li√™n k·∫øt c√°c kh·ªëi b·ªô nh·ªõ tr·ªëng ƒë·ªÉ c·∫•p ph√°t v√† gi·∫£i ph√≥ng b·ªô nh·ªõ m·ªôt c√°ch linh ho·∫°t m√† kh√¥ng c√≥ b·∫•t k·ª≥ r√†ng bu·ªôc k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh n√†o.",
                "C. N√≥ chia b·ªô nh·ªõ th√†nh c√°c kh·ªëi c√≥ k√≠ch th∆∞·ªõc l√† l≈©y th·ª´a c·ªßa hai, v√† h·ª£p nh·∫•t c√°c kh·ªëi tr·ªëng li·ªÅn k·ªÅ (\"buddies\") khi c·∫£ hai ƒë·ªÅu tr·ªëng, ƒë·ªÉ t·∫°o th√†nh c√°c kh·ªëi l·ªõn h∆°n.",
                "D. N√≥ d√†nh m·ªôt l∆∞·ª£ng b·ªô nh·ªõ c·ª• th·ªÉ cho m·ªói ti·∫øn tr√¨nh khi b·∫Øt ƒë·∫ßu th·ª±c thi, m√† kh√¥ng c√≥ b·∫•t k·ª≥ s·ª± c·∫•p ph√°t ƒë·ªông n√†o."
            ],
            "answer": "C. N√≥ chia b·ªô nh·ªõ th√†nh c√°c kh·ªëi c√≥ k√≠ch th∆∞·ªõc l√† l≈©y th·ª´a c·ªßa hai, v√† h·ª£p nh·∫•t c√°c kh·ªëi tr·ªëng li·ªÅn k·ªÅ (\"buddies\") khi c·∫£ hai ƒë·ªÅu tr·ªëng, ƒë·ªÉ t·∫°o th√†nh c√°c kh·ªëi l·ªõn h∆°n.",
            "explanation": "H·ªá th·ªëng buddy l√† m·ªôt thu·∫≠t to√°n c·∫•p ph√°t b·ªô nh·ªõ gi√∫p c·∫•p ph√°t v√† gi·∫£i ph√≥ng c√°c kh·ªëi b·ªô nh·ªõ m·ªôt c√°ch hi·ªáu qu·∫£. T√≠nh nƒÉng ch√≠nh c·ªßa n√≥ l√† chia ƒë·ªá quy c√°c kh·ªëi th√†nh m·ªôt n·ª≠a (buddies) ƒë·ªÉ t√¨m k√≠ch th∆∞·ªõc ph√π h·ª£p v√† h·ª£p nh·∫•t ch√∫ng l·∫°i v·ªõi nhau khi ƒë∆∞·ª£c gi·∫£i ph√≥ng ƒë·ªÉ ch·ªëng l·∫°i s·ª± ph√¢n m·∫£nh b√™n ngo√†i."
        }
    },
    {
        "id": 211,
        "en": {
            "question": "In the context of memory management, what problem does paging aim to solve?",
            "options": [
                "A. It increases memory access speeds by storing frequently used data in faster storage devices.",
                "B. It prevents memory from being accessed by unauthorized processes.",
                "C. It addresses the problem of inefficient CPU scheduling by prioritizing critical tasks.",
                "D. It addresses the problem of external fragmentation by dividing memory into fixed-size blocks, making allocation and deallocation easier."
            ],
            "answer": "D. It addresses the problem of external fragmentation by dividing memory into fixed-size blocks, making allocation and deallocation easier.",
            "explanation": "External fragmentation occurs when free memory is broken into small, non-contiguous pieces. Paging solves this by allowing a process's logical address space to be non-contiguous, fitting into any available physical frames of a fixed size."
        },
        "vi": {
            "question": "Trong b·ªëi c·∫£nh qu·∫£n l√Ω b·ªô nh·ªõ, ph√¢n trang nh·∫±m gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ g√¨?",
            "options": [
                "A. N√≥ tƒÉng t·ªëc ƒë·ªô truy c·∫≠p b·ªô nh·ªõ b·∫±ng c√°ch l∆∞u tr·ªØ d·ªØ li·ªáu ƒë∆∞·ª£c s·ª≠ d·ª•ng th∆∞·ªùng xuy√™n trong c√°c thi·∫øt b·ªã l∆∞u tr·ªØ nhanh h∆°n.",
                "B. N√≥ ngƒÉn ch·∫∑n b·ªô nh·ªõ b·ªã truy c·∫≠p b·ªüi c√°c ti·∫øn tr√¨nh tr√°i ph√©p.",
                "C. N√≥ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ l·∫≠p l·ªãch CPU kh√¥ng hi·ªáu qu·∫£ b·∫±ng c√°ch ∆∞u ti√™n c√°c t√°c v·ª• quan tr·ªçng.",
                "D. N√≥ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ ph√¢n m·∫£nh b·∫±ng c√°ch chia b·ªô nh·ªõ th√†nh c√°c kh·ªëi c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh, gi√∫p vi·ªác c·∫•p ph√°t v√† gi·∫£i ph√≥ng b·ªô nh·ªõ tr·ªü n√™n d·ªÖ d√†ng h∆°n."
            ],
            "answer": "D. N√≥ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ ph√¢n m·∫£nh b·∫±ng c√°ch chia b·ªô nh·ªõ th√†nh c√°c kh·ªëi c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh, gi√∫p vi·ªác c·∫•p ph√°t v√† gi·∫£i ph√≥ng b·ªô nh·ªõ tr·ªü n√™n d·ªÖ d√†ng h∆°n.",
            "explanation": "Ph√¢n m·∫£nh b√™n ngo√†i x·∫£y ra khi b·ªô nh·ªõ tr·ªëng b·ªã chia th√†nh c√°c m·∫£nh nh·ªè, kh√¥ng li·ªÅn k·ªÅ. Ph√¢n trang gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y b·∫±ng c√°ch cho ph√©p kh√¥ng gian ƒë·ªãa ch·ªâ logic c·ªßa m·ªôt ti·∫øn tr√¨nh kh√¥ng li·ªÅn k·ªÅ, ph√π h·ª£p v·ªõi b·∫•t k·ª≥ khung v·∫≠t l√Ω c√≥ k√≠ch th∆∞·ªõc c·ªë ƒë·ªãnh n√†o c√≥ s·∫µn."
        }
    },
    {
        "id": 212,
        "en": {
            "question": "What is the primary function of the kernel in an Operating System?",
            "options": [
                "A. The kernel acts as the core component that manages system resources, hardware communication, and access control for software programs.",
                "B. The kernel is used to install and manage applications on the operating system.",
                "C. The kernel is a hardware component that processes data at the speed of the CPU.",
                "D. The kernel serves as the graphical interface that allows users to interact with the computer."
            ],
            "answer": "A. The kernel acts as the core component that manages system resources, hardware communication, and access control for software programs.",
            "explanation": "The kernel is the central, most privileged part of the OS. It directly controls the hardware and provides essential services (process scheduling, memory management, I/O) upon which the rest of the OS and applications are built."
        },
        "vi": {
            "question": "M·ª•c ƒë√≠ch c·ªßa kernel trong m·ªôt H·ªá ƒëi·ªÅu h√†nh l√† g√¨?",
            "options": [
                "A. Kernel ho·∫°t ƒë·ªông nh∆∞ th√†nh ph·∫ßn c·ªët l√µi qu·∫£n l√Ω t√†i nguy√™n h·ªá th·ªëng, giao ti·∫øp ph·∫ßn c·ª©ng v√† ki·ªÉm so√°t truy c·∫≠p cho c√°c ch∆∞∆°ng tr√¨nh ph·∫ßn m·ªÅm.",
                "B. Kernel ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ c√†i ƒë·∫∑t v√† qu·∫£n l√Ω c√°c ·ª©ng d·ª•ng tr√™n h·ªá ƒëi·ªÅu h√†nh.",
                "C. Kernel l√† m·ªôt th√†nh ph·∫ßn ph·∫ßn c·ª©ng x·ª≠ l√Ω d·ªØ li·ªáu v·ªõi t·ªëc ƒë·ªô c·ªßa CPU.",
                "D. Kernel ph·ª•c v·ª• nh∆∞ giao di·ªán ƒë·ªì h·ªça cho ph√©p ng∆∞·ªùi d√πng t∆∞∆°ng t√°c v·ªõi m√°y t√≠nh."
            ],
            "answer": "A. Kernel ho·∫°t ƒë·ªông nh∆∞ th√†nh ph·∫ßn c·ªët l√µi qu·∫£n l√Ω t√†i nguy√™n h·ªá th·ªëng, giao ti·∫øp ph·∫ßn c·ª©ng v√† ki·ªÉm so√°t truy c·∫≠p cho c√°c ch∆∞∆°ng tr√¨nh ph·∫ßn m·ªÅm.",
            "explanation": "Kernel l√† ph·∫ßn trung t√¢m, c√≥ ƒë·∫∑c quy·ªÅn nh·∫•t c·ªßa HƒêH. N√≥ ƒëi·ªÅu khi·ªÉn tr·ª±c ti·∫øp ph·∫ßn c·ª©ng v√† cung c·∫•p c√°c d·ªãch v·ª• thi·∫øt y·∫øu (l·∫≠p l·ªãch ti·∫øn tr√¨nh, qu·∫£n l√Ω b·ªô nh·ªõ, I/O) m√† ph·∫ßn c√≤n l·∫°i c·ªßa HƒêH v√† c√°c ·ª©ng d·ª•ng ƒë∆∞·ª£c x√¢y d·ª±ng tr√™n ƒë√≥."
        }
    },
    {
        "id": 213,
        "en": {
            "question": "How does a multilevel feedback queue scheduling approach differ from a round-robin algorithm?",
            "options": [
                "A. It allows the CPU to switch between tasks in fixed time intervals, regardless of their priority or length.",
                "B. It prioritizes shorter processes over longer ones, without taking into account the system's overall workload.",
                "C. It assigns processes to multiple queues with different priority levels, allowing processes to move between queues based on their behavior and execution history.",
                "D. It processes all jobs in a strict order, regardless of their priority or execution time."
            ],
            "answer": "C. It assigns processes to multiple queues with different priority levels, allowing processes to move between queues based on their behavior and execution history.",
            "explanation": "This is the defining feature of multilevel feedback queues. It's an adaptive algorithm that can prioritize I/O-bound (interactive) processes by keeping them in high-priority queues, while demoting CPU-bound processes to lower-priority queues, preventing starvation and improving responsiveness."
        },
        "vi": {
            "question": "C√°ch ti·∫øp c·∫≠n l·∫≠p l·ªãch h√†ng ƒë·ª£i ph·∫£n h·ªìi ƒëa c·∫•p kh√°c v·ªõi thu·∫≠t to√°n round-robin nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ cho ph√©p CPU chuy·ªÉn ƒë·ªïi gi·ªØa c√°c t√°c v·ª• trong c√°c kho·∫£ng th·ªùi gian c·ªë ƒë·ªãnh, b·∫•t k·ªÉ m·ª©c ƒë·ªô ∆∞u ti√™n ho·∫∑c ƒë·ªô d√†i c·ªßa ch√∫ng.",
                "B. N√≥ ∆∞u ti√™n c√°c ti·∫øn tr√¨nh ng·∫Øn h∆°n c√°c ti·∫øn tr√¨nh d√†i h∆°n, m√† kh√¥ng c·∫ßn xem x√©t ƒë·∫øn kh·ªëi l∆∞·ª£ng c√¥ng vi·ªác t·ªïng th·ªÉ c·ªßa h·ªá th·ªëng.",
                "C. N√≥ g√°n c√°c ti·∫øn tr√¨nh cho nhi·ªÅu h√†ng ƒë·ª£i v·ªõi c√°c m·ª©c ƒë·ªô ∆∞u ti√™n kh√°c nhau, cho ph√©p c√°c ti·∫øn tr√¨nh di chuy·ªÉn gi·ªØa c√°c h√†ng ƒë·ª£i d·ª±a tr√™n h√†nh vi v√† l·ªãch s·ª≠ th·ª±c thi.",
                "D. N√≥ x·ª≠ l√Ω t·∫•t c·∫£ c√°c c√¥ng vi·ªác theo m·ªôt tr·∫≠t t·ª± nghi√™m ng·∫∑t, b·∫•t k·ªÉ m·ª©c ƒë·ªô ∆∞u ti√™n ho·∫∑c th·ªùi gian th·ª±c thi c·ªßa ch√∫ng."
            ],
            "answer": "C. N√≥ g√°n c√°c ti·∫øn tr√¨nh cho nhi·ªÅu h√†ng ƒë·ª£i v·ªõi c√°c m·ª©c ƒë·ªô ∆∞u ti√™n kh√°c nhau, cho ph√©p c√°c ti·∫øn tr√¨nh di chuy·ªÉn gi·ªØa c√°c h√†ng ƒë·ª£i d·ª±a tr√™n h√†nh vi v√† l·ªãch s·ª≠ th·ª±c thi.",
            "explanation": "ƒê√¢y l√† t√≠nh nƒÉng x√°c ƒë·ªãnh c·ªßa h√†ng ƒë·ª£i ph·∫£n h·ªìi ƒëa c·∫•p. N√≥ l√† m·ªôt thu·∫≠t to√°n th√≠ch ·ª©ng c√≥ th·ªÉ ∆∞u ti√™n c√°c ti·∫øn tr√¨nh b·ªã r√†ng bu·ªôc I/O (t∆∞∆°ng t√°c) b·∫±ng c√°ch gi·ªØ ch√∫ng trong c√°c h√†ng ƒë·ª£i ∆∞u ti√™n cao, trong khi h·∫° c·∫•p c√°c ti·∫øn tr√¨nh b·ªã r√†ng bu·ªôc CPU xu·ªëng c√°c h√†ng ƒë·ª£i ∆∞u ti√™n th·∫•p h∆°n, ngƒÉn ch·∫∑n s·ª± ƒë√≥i t√†i nguy√™n v√† c·∫£i thi·ªán kh·∫£ nƒÉng ƒë√°p ·ª©ng."
        }
    },
    {
        "id": 214,
        "en": {
            "question": "Which scheduling algorithm is best suited for a real-time system where tasks must meet strict timing constraints?",
            "options": [
                "A. First-Come, First-Served (FCFS).",
                "B. Shortest Job First (SJF).",
                "C. Round-robin scheduling.",
                "D. Earliest Deadline First (EDF)."
            ],
            "answer": "D. Earliest Deadline First (EDF).",
            "explanation": "EDF is a dynamic priority scheduling algorithm used in real-time operating systems. It places processes in a priority queue. Whenever a scheduling event occurs, the queue will be searched for the process closest to its deadline, which will be the next to be scheduled for execution."
        },
        "vi": {
            "question": "Thu·∫≠t to√°n l·∫≠p l·ªãch n√†o ph√π h·ª£p nh·∫•t cho m·ªôt h·ªá th·ªëng th·ªùi gian th·ª±c n∆°i c√°c t√°c v·ª• ph·∫£i ƒë√°p ·ª©ng c√°c r√†ng bu·ªôc th·ªùi gian nghi√™m ng·∫∑t?",
            "options": [
                "A. First-Come, First-Served (FCFS).",
                "B. Shortest Job First (SJF).",
                "C. Round-robin scheduling.",
                "D. Earliest Deadline First (EDF)."
            ],
            "answer": "D. Earliest Deadline First (EDF).",
            "explanation": "EDF l√† m·ªôt thu·∫≠t to√°n l·∫≠p l·ªãch ∆∞u ti√™n ƒë·ªông ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h·ªá ƒëi·ªÅu h√†nh th·ªùi gian th·ª±c. N√≥ ƒë·∫∑t c√°c ti·∫øn tr√¨nh v√†o m·ªôt h√†ng ƒë·ª£i ∆∞u ti√™n. B·∫•t c·ª© khi n√†o m·ªôt s·ª± ki·ªán l·∫≠p l·ªãch x·∫£y ra, h√†ng ƒë·ª£i s·∫Ω ƒë∆∞·ª£c t√¨m ki·∫øm ti·∫øn tr√¨nh g·∫ßn nh·∫•t v·ªõi th·ªùi h·∫°n c·ªßa n√≥, ƒë√≥ s·∫Ω l√† ti·∫øn tr√¨nh ti·∫øp theo ƒë∆∞·ª£c l√™n l·ªãch ƒë·ªÉ th·ª±c thi."
        }
    },
    {
        "id": 215,
        "en": {
            "question": "A potential disadvantage of using a First-Come, First-Served (FCFS) scheduling algorithm in a system with mixed job sizes is:",
            "options": [
                "A. It leads to poor CPU utilization due to not accounting for process priorities.",
                "B. It can require complex algorithms to manage varying priorities among processes.",
                "C. It results in high context-switching overhead due to frequent task switching.",
                "D. It can lead to the 'convoy effect', where long processes delay the execution of short processes, increasing overall wait time."
            ],
            "answer": "D. It can lead to the 'convoy effect', where long processes delay the execution of short processes, increasing overall wait time.",
            "explanation": "The convoy effect is the primary drawback of FCFS. If a long, CPU-intensive job arrives first, all subsequent jobs, including short, interactive ones, must wait for it to finish, leading to poor average response time."
        },
        "vi": {
            "question": "M·ªôt nh∆∞·ª£c ƒëi·ªÉm ti·ªÅm t√†ng c·ªßa vi·ªác s·ª≠ d·ª•ng thu·∫≠t to√°n l·∫≠p l·ªãch First-Come, First-Served (FCFS) trong m·ªôt h·ªá th·ªëng c√≥ c√°c k√≠ch th∆∞·ªõc c√¥ng vi·ªác h·ªón h·ª£p l√† g√¨?",
            "options": [
                "A. N√≥ d·∫´n ƒë·∫øn vi·ªác s·ª≠ d·ª•ng CPU k√©m do kh√¥ng t√≠nh ƒë·∫øn c√°c ∆∞u ti√™n c·ªßa ti·∫øn tr√¨nh.",
                "B. N√≥ c√≥ th·ªÉ y√™u c·∫ßu c√°c thu·∫≠t to√°n ph·ª©c t·∫°p ƒë·ªÉ qu·∫£n l√Ω c√°c ∆∞u ti√™n kh√°c nhau gi·ªØa c√°c ti·∫øn tr√¨nh.",
                "C. N√≥ d·∫´n ƒë·∫øn chi ph√≠ chuy·ªÉn ƒë·ªïi ng·ªØ c·∫£nh cao do chuy·ªÉn ƒë·ªïi t√°c v·ª• th∆∞·ªùng xuy√™n.",
                "D. N√≥ c√≥ th·ªÉ d·∫´n ƒë·∫øn \"hi·ªáu ·ª©ng ƒëo√†n xe\", trong ƒë√≥ c√°c ti·∫øn tr√¨nh d√†i tr√¨ ho√£n vi·ªác th·ª±c thi c√°c ti·∫øn tr√¨nh ng·∫Øn, l√†m tƒÉng th·ªùi gian ch·ªù ƒë·ª£i t·ªïng th·ªÉ."
            ],
            "answer": "D. N√≥ c√≥ th·ªÉ d·∫´n ƒë·∫øn \"hi·ªáu ·ª©ng ƒëo√†n xe\", trong ƒë√≥ c√°c ti·∫øn tr√¨nh d√†i tr√¨ ho√£n vi·ªác th·ª±c thi c√°c ti·∫øn tr√¨nh ng·∫Øn, l√†m tƒÉng th·ªùi gian ch·ªù ƒë·ª£i t·ªïng th·ªÉ.",
            "explanation": "Hi·ªáu ·ª©ng ƒëo√†n xe l√† nh∆∞·ª£c ƒëi·ªÉm ch√≠nh c·ªßa FCFS. N·∫øu m·ªôt c√¥ng vi·ªác d√†i, s·ª≠ d·ª•ng nhi·ªÅu CPU ƒë·∫øn tr∆∞·ªõc, t·∫•t c·∫£ c√°c c√¥ng vi·ªác ti·∫øp theo, bao g·ªìm c·∫£ c√°c c√¥ng vi·ªác ng·∫Øn, t∆∞∆°ng t√°c, ph·∫£i ch·ªù n√≥ ho√†n th√†nh, d·∫´n ƒë·∫øn th·ªùi gian ph·∫£n h·ªìi trung b√¨nh k√©m."
        }
    },
    {
        "id": 216,
        "en": {
            "question": "How does an Operating System ensure efficient use of a computer's resources in a multitasking environment?",
            "options": [
                "A. By allocating a fixed amount of time for each application to run, ensuring no single task exceeds its allocated resources.",
                "B. By limiting the number of processes that can run at once to avoid overloading the CPU.",
                "C. By prioritizing only the most critical tasks and pausing all others.",
                "D. By allowing multiple processes to share CPU time through scheduling algorithms and by managing memory to prevent conflicts."
            ],
            "answer": "D. By allowing multiple processes to share CPU time through scheduling algorithms and by managing memory to prevent conflicts.",
            "explanation": "This is the core of multitasking. The OS scheduler rapidly switches between processes, giving each a slice of CPU time, creating the illusion of parallel execution. Simultaneously, its memory manager (using techniques like paging and segmentation) ensures each process has its own protected memory space."
        },
        "vi": {
            "question": "L√†m th·∫ø n√†o m·ªôt H·ªá ƒëi·ªÅu h√†nh ƒë·∫£m b·∫£o vi·ªác s·ª≠ d·ª•ng hi·ªáu qu·∫£ c√°c t√†i nguy√™n c·ªßa m√°y t√≠nh trong m·ªôt m√¥i tr∆∞·ªùng ƒëa nhi·ªám?",
            "options": [
                "A. B·∫±ng c√°ch ph√¢n b·ªï m·ªôt l∆∞·ª£ng th·ªùi gian c·ªë ƒë·ªãnh cho m·ªói ·ª©ng d·ª•ng ƒë·ªÉ ch·∫°y, ƒë·∫£m b·∫£o kh√¥ng c√≥ t√°c v·ª• n√†o v∆∞·ª£t qu√° t√†i nguy√™n ƒë∆∞·ª£c ph√¢n b·ªï.",
                "B. B·∫±ng c√°ch h·∫°n ch·∫ø s·ªë l∆∞·ª£ng ti·∫øn tr√¨nh c√≥ th·ªÉ ch·∫°y c√πng m·ªôt l√∫c ƒë·ªÉ tr√°nh l√†m qu√° t·∫£i CPU.",
                "C. B·∫±ng c√°ch ∆∞u ti√™n ch·ªâ c√°c t√°c v·ª• quan tr·ªçng nh·∫•t v√† t·∫°m d·ª´ng t·∫•t c·∫£ c√°c t√°c v·ª• kh√°c.",
                "D. B·∫±ng c√°ch cho ph√©p nhi·ªÅu ti·∫øn tr√¨nh chia s·∫ª th·ªùi gian CPU th√¥ng qua c√°c thu·∫≠t to√°n l·∫≠p l·ªãch v√† b·∫±ng c√°ch qu·∫£n l√Ω b·ªô nh·ªõ ƒë·ªÉ ngƒÉn ch·∫∑n xung ƒë·ªôt."
            ],
            "answer": "D. B·∫±ng c√°ch cho ph√©p nhi·ªÅu ti·∫øn tr√¨nh chia s·∫ª th·ªùi gian CPU th√¥ng qua c√°c thu·∫≠t to√°n l·∫≠p l·ªãch v√† b·∫±ng c√°ch qu·∫£n l√Ω b·ªô nh·ªõ ƒë·ªÉ ngƒÉn ch·∫∑n xung ƒë·ªôt.",
            "explanation": "ƒê√¢y l√† c·ªët l√µi c·ªßa ƒëa nhi·ªám. B·ªô l·∫≠p l·ªãch HƒêH chuy·ªÉn ƒë·ªïi nhanh ch√≥ng gi·ªØa c√°c ti·∫øn tr√¨nh, cho m·ªói ti·∫øn tr√¨nh m·ªôt l√°t th·ªùi gian CPU, t·∫°o ra ·∫£o gi√°c th·ª±c thi song song. ƒê·ªìng th·ªùi, tr√¨nh qu·∫£n l√Ω b·ªô nh·ªõ c·ªßa n√≥ (s·ª≠ d·ª•ng c√°c k·ªπ thu·∫≠t nh∆∞ ph√¢n trang v√† ph√¢n ƒëo·∫°n) ƒë·∫£m b·∫£o m·ªói ti·∫øn tr√¨nh c√≥ kh√¥ng gian b·ªô nh·ªõ ƒë∆∞·ª£c b·∫£o v·ªá ri√™ng."
        }
    },
    {
        "id": 217,
        "en": {
            "question": "The ____ scheduler executes relatively infrequently and makes the coarse-grained decision of whether or not to take on a new process... The ____ scheduler, also known as the dispatcher, executes most frequently and makes the fine-grained decision of which job to execute next.",
            "options": [
                "A. short-term; medium-term",
                "B. medium-term; short-term",
                "C. long-term; short-term",
                "D. long-term; medium-term"
            ],
            "answer": "C. long-term; short-term",
            "explanation": "The long-term scheduler controls the degree of multiprogramming (how many processes are in memory). The short-term scheduler (dispatcher) selects the next process to run on the CPU from the ready queue."
        },
        "vi": {
            "question": "B·ªô l·∫≠p l·ªãch ___ th·ª±c thi t∆∞∆°ng ƒë·ªëi kh√¥ng th∆∞·ªùng xuy√™n v√† ƒë∆∞a ra quy·∫øt ƒë·ªãnh c√≥ ƒë·ªô chi ti·∫øt th√¥ v·ªÅ vi·ªác c√≥ n√™n nh·∫≠n m·ªôt ti·∫øn tr√¨nh m·ªõi hay kh√¥ng... B·ªô l·∫≠p l·ªãch ___, c√≤n ƒë∆∞·ª£c g·ªçi l√† b·ªô ƒëi·ªÅu ph·ªëi, th·ª±c thi th∆∞·ªùng xuy√™n v√† ƒë∆∞a ra quy·∫øt ƒë·ªãnh c√≥ ƒë·ªô chi ti·∫øt m·ªãn v·ªÅ c√¥ng vi·ªác n√†o s·∫Ω th·ª±c thi ti·∫øp theo.",
            "options": [
                "A. ng·∫Øn h·∫°n; trung h·∫°n",
                "B. trung h·∫°n; ng·∫Øn h·∫°n",
                "C. d√†i h·∫°n; ng·∫Øn h·∫°n",
                "D. d√†i h·∫°n; trung h·∫°n"
            ],
            "answer": "C. d√†i h·∫°n; ng·∫Øn h·∫°n",
            "explanation": "B·ªô l·∫≠p l·ªãch d√†i h·∫°n ki·ªÉm so√°t m·ª©c ƒë·ªô ƒëa ch∆∞∆°ng (s·ªë l∆∞·ª£ng ti·∫øn tr√¨nh trong b·ªô nh·ªõ). B·ªô l·∫≠p l·ªãch ng·∫Øn h·∫°n (b·ªô ƒëi·ªÅu ph·ªëi) ch·ªçn ti·∫øn tr√¨nh ti·∫øp theo ƒë·ªÉ ch·∫°y tr√™n CPU t·ª´ h√†ng ƒë·ª£i s·∫µn s√†ng."
        }
    },
    // Chuy√™n m·ª•c 9: Assembly Language (H·ª£p ng·ªØ) - 5 c√¢u
    {
        "id": 218,
        "en": {
            "question": "In MASM32, what OPCODE is used to compare two values?",
            "options": [
                "A. COM",
                "B. CMP",
                "C. IF ... ELSE",
                "D. TEST"
            ],
            "answer": "B. CMP",
            "explanation": "The CMP (Compare) instruction subtracts the source operand from the destination operand (without saving the result) and sets the CPU flags (like Zero Flag, Sign Flag) based on the outcome. These flags are then used by conditional jump instructions."
        },
        "vi": {
            "question": "Trong MASM32, OPCODE n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ so s√°nh hai gi√° tr·ªã?",
            "options": [
                "A. COM",
                "B. CMP",
                "C. IF ... ELSE",
                "D. TEST"
            ],
            "answer": "B. CMP",
            "explanation": "L·ªánh CMP (So s√°nh) tr·ª´ to√°n h·∫°ng ngu·ªìn kh·ªèi to√°n h·∫°ng ƒë√≠ch (m√† kh√¥ng l∆∞u k·∫øt qu·∫£) v√† ƒë·∫∑t c√°c c·ªù CPU (nh∆∞ C·ªù Zero, C·ªù D·∫•u) d·ª±a tr√™n k·∫øt qu·∫£. C√°c c·ªù n√†y sau ƒë√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi c√°c l·ªánh nh·∫£y c√≥ ƒëi·ªÅu ki·ªán."
        }
    },
    {
        "id": 219,
        "en": {
            "question": "In MASM, how do you get numbers from the user?",
            "options": [
                "A. Raw data from the keyboard is a string. The sval(num-string) function will convert the number string to a signed number.",
                "B. Raw data from the keyboard is a string. The str(num-string) function will convert the number string to a signed number.",
                "C. Raw data from the keyboard is a string. The chr(num-string) function will convert the number string to a signed number.",
                "D. Raw data from the keyboard is a string. The chr$(num-string) function will convert the number string to an unsigned number."
            ],
            "answer": "A. Raw data from the keyboard is a string. The sval(num-string) function will convert the number string to a signed number.",
            "explanation": "Input from the console is always read as a string of characters. A library function like `sval` (string value) from a MASM library (like Irvine32) is needed to parse this string and convert it into a numerical representation in a register."
        },
        "vi": {
            "question": "Trong MASM, l√†m th·∫ø n√†o ƒë·ªÉ nh·∫≠n s·ªë t·ª´ ng∆∞·ªùi d√πng?",
            "options": [
                "A. D·ªØ li·ªáu th√¥ t·ª´ b√†n ph√≠m l√† chu·ªói. H√†m sval(num-string) s·∫Ω chuy·ªÉn ƒë·ªïi chu·ªói s·ªë th√†nh s·ªë c√≥ d·∫•u.",
                "B. D·ªØ li·ªáu th√¥ t·ª´ b√†n ph√≠m l√† chu·ªói. H√†m str(num-string) s·∫Ω chuy·ªÉn ƒë·ªïi chu·ªói s·ªë th√†nh s·ªë c√≥ d·∫•u.",
                "C. D·ªØ li·ªáu th√¥ t·ª´ b√†n ph√≠m l√† chu·ªói. H√†m chr(num-string) s·∫Ω chuy·ªÉn ƒë·ªïi chu·ªói s·ªë th√†nh s·ªë c√≥ d·∫•u.",
                "D. D·ªØ li·ªáu th√¥ t·ª´ b√†n ph√≠m l√† chu·ªói. H√†m chr$(num-string) s·∫Ω chuy·ªÉn ƒë·ªïi chu·ªói s·ªë th√†nh s·ªë kh√¥ng d·∫•u."
            ],
            "answer": "A. D·ªØ li·ªáu th√¥ t·ª´ b√†n ph√≠m l√† chu·ªói. H√†m sval(num-string) s·∫Ω chuy·ªÉn ƒë·ªïi chu·ªói s·ªë th√†nh s·ªë c√≥ d·∫•u.",
            "explanation": "ƒê·∫ßu v√†o t·ª´ b·∫£ng ƒëi·ªÅu khi·ªÉn lu√¥n ƒë∆∞·ª£c ƒë·ªçc d∆∞·ªõi d·∫°ng m·ªôt chu·ªói k√Ω t·ª±. C·∫ßn c√≥ m·ªôt h√†m th∆∞ vi·ªán nh∆∞ `sval` (gi√° tr·ªã chu·ªói) t·ª´ m·ªôt th∆∞ vi·ªán MASM (nh∆∞ Irvine32) ƒë·ªÉ ph√¢n t√≠ch chu·ªói n√†y v√† chuy·ªÉn ƒë·ªïi n√≥ th√†nh m·ªôt bi·ªÉu di·ªÖn s·ªë trong m·ªôt thanh ghi."
        }
    },
    {
        "id": 220,
        "en": {
            "question": "In MASM32, which instruction is incorrect?",
            "options": [
                "A. ADD EAX, a",
                "B. ADD EAX, EBX",
                "C. ADD a, EAX",
                "D. ADD a, b"
            ],
            "answer": "D. ADD a, b",
            "explanation": "In x86 assembly, most instructions like ADD cannot have two memory operands. At least one of the operands must be a register. 'a' and 'b' are assumed to be memory variables."
        },
        "vi": {
            "question": "Trong MASM32, l·ªánh n√†o l√† kh√¥ng ch√≠nh x√°c?",
            "options": [
                "A. ADD EAX, a",
                "B. ADD EAX, EBX",
                "C. ADD a, EAX",
                "D. ADD a, b"
            ],
            "answer": "D. ADD a, b",
            "explanation": "Trong h·ª£p ng·ªØ x86, h·∫ßu h·∫øt c√°c l·ªánh nh∆∞ ADD kh√¥ng th·ªÉ c√≥ hai to√°n h·∫°ng b·ªô nh·ªõ. √çt nh·∫•t m·ªôt trong c√°c to√°n h·∫°ng ph·∫£i l√† m·ªôt thanh ghi. 'a' v√† 'b' ƒë∆∞·ª£c gi·∫£ ƒë·ªãnh l√† c√°c bi·∫øn b·ªô nh·ªõ."
        }
    },
    {
        "id": 221,
        "en": {
            "question": "The x86 assembly instruction `jmp label` typically does what?",
            "options": [
                "A. Jumps to the memory address stored in the label.",
                "B. Jumps to the next instruction.",
                "C. Jumps to the label if a specific condition is met.",
                "D. Moves the address of the label to the EIP register."
            ],
            "answer": "D. Moves the address of the label to the EIP register.",
            "explanation": "An unconditional jump (JMP) works by changing the value of the Instruction Pointer (EIP/RIP) register to the address of the target label. This causes the CPU to fetch and execute the instruction at that new location."
        },
        "vi": {
            "question": "L·ªánh h·ª£p ng·ªØ x86 `jmp label` th∆∞·ªùng l√†m g√¨?",
            "options": [
                "A. Nh·∫£y ƒë·∫øn ƒë·ªãa ch·ªâ b·ªô nh·ªõ ƒë∆∞·ª£c l∆∞u tr·ªØ trong nh√£n.",
                "B. Nh·∫£y ƒë·∫øn l·ªánh ti·∫øp theo.",
                "C. Nh·∫£y ƒë·∫øn nh√£n n·∫øu m·ªôt ƒëi·ªÅu ki·ªán c·ª• th·ªÉ ƒë∆∞·ª£c ƒë√°p ·ª©ng.",
                "D. Di chuy·ªÉn ƒë·ªãa ch·ªâ c·ªßa nh√£n ƒë·∫øn thanh ghi EIP."
            ],
            "answer": "D. Di chuy·ªÉn ƒë·ªãa ch·ªâ c·ªßa nh√£n ƒë·∫øn thanh ghi EIP.",
            "explanation": "M·ªôt l·ªánh nh·∫£y kh√¥ng ƒëi·ªÅu ki·ªán (JMP) ho·∫°t ƒë·ªông b·∫±ng c√°ch thay ƒë·ªïi gi√° tr·ªã c·ªßa thanh ghi Con tr·ªè l·ªánh (EIP/RIP) th√†nh ƒë·ªãa ch·ªâ c·ªßa nh√£n ƒë√≠ch. ƒêi·ªÅu n√†y khi·∫øn CPU t√¨m n·∫°p v√† th·ª±c thi l·ªánh t·∫°i v·ªã tr√≠ m·ªõi ƒë√≥."
        }
    },
    {
        "id": 222,
        "en": {
            "question": "Why is the symbolic representation of machine instructions necessary?",
            "options": [
                "A. It makes machine instructions more readable and understandable for humans.",
                "B. It reduces the overall complexity of computer systems and user programs.",
                "C. It minimizes the need for memory storage for user programs.",
                "D. It allows for faster execution of high-level language instructions."
            ],
            "answer": "A. It makes machine instructions more readable and understandable for humans.",
            "explanation": "Symbolic representation (assembly language) uses mnemonics like 'ADD', 'MOV', 'JMP' instead of raw binary opcodes (e.g., 10010110), making it feasible for humans to write and debug low-level programs."
        },
        "vi": {
            "question": "T·∫°i sao vi·ªác s·ª≠ d·ª•ng bi·ªÉu di·ªÖn k√Ω hi·ªáu c·ªßa c√°c l·ªánh m√°y l·∫°i c·∫ßn thi·∫øt?",
            "options": [
                "A. N√≥ l√†m cho c√°c l·ªánh m√°y d·ªÖ ƒë·ªçc v√† d·ªÖ hi·ªÉu h∆°n ƒë·ªëi v·ªõi con ng∆∞·ªùi.",
                "B. N√≥ l√†m gi·∫£m s·ª± ph·ª©c t·∫°p t·ªïng th·ªÉ c·ªßa c√°c h·ªá th·ªëng m√°y t√≠nh v√† c√°c ch∆∞∆°ng tr√¨nh ng∆∞·ªùi d√πng.",
                "C. N√≥ gi·∫£m thi·ªÉu nhu c·∫ßu l∆∞u tr·ªØ b·ªô nh·ªõ cho c√°c ch∆∞∆°ng tr√¨nh ng∆∞·ªùi d√πng.",
                "D. N√≥ cho ph√©p th·ª±c thi nhanh h∆°n c√°c l·ªánh ng√¥n ng·ªØ c·∫•p cao."
            ],
            "answer": "A. N√≥ l√†m cho c√°c l·ªánh m√°y d·ªÖ ƒë·ªçc v√† d·ªÖ hi·ªÉu h∆°n ƒë·ªëi v·ªõi con ng∆∞·ªùi.",
            "explanation": "Bi·ªÉu di·ªÖn k√Ω hi·ªáu (h·ª£p ng·ªØ) s·ª≠ d·ª•ng c√°c g·ª£i nh·ªõ nh∆∞ 'ADD', 'MOV', 'JMP' thay v√¨ c√°c m√£ m√°y nh·ªã ph√¢n th√¥ (v√≠ d·ª•: 10010110), gi√∫p con ng∆∞·ªùi c√≥ th·ªÉ vi·∫øt v√† g·ª° l·ªói c√°c ch∆∞∆°ng tr√¨nh c·∫•p th·∫•p."
        }
    },
    // Chuy√™n m·ª•c 10: Digital Logic (Logic s·ªë) - 38 c√¢u
    {
        "id": 223,
        "en": {
            "question": "Which logic gate can be used to produce an inverted output of an input signal in digital logic?",
            "options": [
                "A. NOT gate",
                "B. OR gate",
                "C. AND gate",
                "D. XOR gate"
            ],
            "answer": "A. NOT gate",
            "explanation": "The NOT gate, or inverter, is a logic gate that implements logical negation. Its output is the inverse of its input: a HIGH input (1) results in a LOW output (0), and vice versa."
        },
        "vi": {
            "question": "C·ªïng logic n√†o c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫°o ra m·ªôt ƒë·∫ßu ra ƒë·∫£o ng∆∞·ª£c c·ªßa t√≠n hi·ªáu ƒë·∫ßu v√†o trong logic k·ªπ thu·∫≠t s·ªë?",
            "options": [
                "A. C·ªïng NOT",
                "B. C·ªïng OR",
                "C. C·ªïng AND",
                "D. C·ªïng XOR"
            ],
            "answer": "A. C·ªïng NOT",
            "explanation": "C·ªïng NOT, hay b·ªô ƒë·∫£o, l√† m·ªôt c·ªïng logic th·ª±c hi·ªán ph√©p ph·ªß ƒë·ªãnh logic. ƒê·∫ßu ra c·ªßa n√≥ l√† ƒë·∫£o ng∆∞·ª£c c·ªßa ƒë·∫ßu v√†o: ƒë·∫ßu v√†o CAO (1) d·∫´n ƒë·∫øn ƒë·∫ßu ra TH·∫§P (0), v√† ng∆∞·ª£c l·∫°i."
        }
    },
    {
        "id": 224,
        "en": {
            "question": "What is the output of the Left Shift Operator << on (00011000<<2)?",
            "options": [
                "A. 01100000",
                "B. 11000000",
                "C. 00000110",
                "D. 00000011"
            ],
            "answer": "A. 01100000",
            "explanation": "A left shift by 2 moves all bits two positions to the left, and fills the rightmost two positions with zeros. 00011000 becomes 01100000."
        },
        "vi": {
            "question": "ƒê·∫ßu ra c·ªßa to√°n t·ª≠ d·ªãch tr√°i (Left Shift Operator) << tr√™n (00011000<<2) l√† g√¨?",
            "options": [
                "A. 01100000",
                "B. 11000000",
                "C. 00000110",
                "D. 00000011"
            ],
            "answer": "A. 01100000",
            "explanation": "D·ªãch tr√°i 2 v·ªã tr√≠ s·∫Ω di chuy·ªÉn t·∫•t c·∫£ c√°c bit sang tr√°i hai v·ªã tr√≠ v√† ƒëi·ªÅn v√†o hai v·ªã tr√≠ ngo√†i c√πng b√™n ph·∫£i b·∫±ng c√°c s·ªë kh√¥ng. 00011000 tr·ªü th√†nh 01100000."
        }
    },
    {
        "id": 225,
        "en": {
            "question": "What is the output of a NOT gate when the input is 0?",
            "options": [
                "A. 0",
                "B. 1",
                "C. Indeterminate",
                "D. 2"
            ],
            "answer": "B. 1",
            "explanation": "A NOT gate inverts its input. If the input is 0 (LOW), the output will be 1 (HIGH)."
        },
        "vi": {
            "question": "ƒê·∫ßu ra c·ªßa c·ªïng NOT khi ƒë·∫ßu v√†o l√† 0 l√† g√¨?",
            "options": [
                "A. 0",
                "B. 1",
                "C. Kh√¥ng x√°c ƒë·ªãnh",
                "D. 2"
            ],
            "answer": "B. 1",
            "explanation": "C·ªïng NOT ƒë·∫£o ng∆∞·ª£c ƒë·∫ßu v√†o c·ªßa n√≥. N·∫øu ƒë·∫ßu v√†o l√† 0 (TH·∫§P), ƒë·∫ßu ra s·∫Ω l√† 1 (CAO)."
        }
    },
    {
        "id": 226,
        "en": {
            "question": "What is the result of the operation 10100101 xor 11001001?",
            "options": [
                "A. 11101101",
                "B. 10000001",
                "C. 01101100",
                "D. 10101100"
            ],
            "answer": "C. 01101100",
            "explanation": "XOR (exclusive OR) is true (1) if the inputs are different, and false (0) if they are the same.  10100101 XOR 11001001 = 01101100."
        },
        "vi": {
            "question": "K·∫øt qu·∫£ c·ªßa ph√©p to√°n 10100101 xor 11001001 l√† g√¨?",
            "options": [
                "A. 11101101",
                "B. 10000001",
                "C. 01101100",
                "D. 10101100"
            ],
            "answer": "C. 01101100",
            "explanation": "XOR (OR lo·∫°i tr·ª´) l√† ƒë√∫ng (1) n·∫øu c√°c ƒë·∫ßu v√†o kh√°c nhau, v√† sai (0) n·∫øu ch√∫ng gi·ªëng nhau. 10100101 XOR 11001001 = 01101100."
        }
    },
    {
        "id": 227,
        "en": {
            "question": "Which representation is the most efficient for performing arithmetic on signed integers?",
            "options": [
                "A. Sign-magnitude",
                "B. 2's complement",
                "C. 1's & 2's complement",
                "D. 1's complement"
            ],
            "answer": "B. 2's complement",
            "explanation": "2's complement is universally used in modern computers because it simplifies arithmetic circuits. Addition and subtraction can be performed by the same hardware, and there is only one representation for zero."
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn n√†o l√† hi·ªáu qu·∫£ nh·∫•t ƒë·ªÉ th·ª±c hi·ªán c√°c ph√©p to√°n s·ªë h·ªçc tr√™n c√°c s·ªë nguy√™n c√≥ d·∫•u?",
            "options": [
                "A. D·∫•u-ƒë·ªô l·ªõn (Sign-magnitude)",
                "B. B√π 2 (2's complement)",
                "C. B√π 1 & B√π 2 (1's & 2's complement)",
                "D. B√π 1 (1's complement)"
            ],
            "answer": "B. B√π 2 (2's complement)",
            "explanation": "B√π 2 ƒë∆∞·ª£c s·ª≠ d·ª•ng ph·ªï bi·∫øn trong c√°c m√°y t√≠nh hi·ªán ƒë·∫°i v√¨ n√≥ ƒë∆°n gi·∫£n h√≥a c√°c m·∫°ch s·ªë h·ªçc. Ph√©p c·ªông v√† tr·ª´ c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán b·ªüi c√πng m·ªôt ph·∫ßn c·ª©ng, v√† ch·ªâ c√≥ m·ªôt bi·ªÉu di·ªÖn cho s·ªë kh√¥ng."
        }
    },
    {
        "id": 228,
        "en": {
            "question": "How does Boolean algebra contribute to the design of digital circuits?",
            "options": [
                "A. It simplifies the implementation of desired functions.",
                "B. It helps in the analysis of economic data.",
                "C. It facilitates the design of analog circuits.",
                "D. It is primarily used for chemical and physical engineering."
            ],
            "answer": "A. It simplifies the implementation of desired functions.",
            "explanation": "Boolean algebra provides the mathematical foundation for digital logic. It allows designers to express a desired circuit function as a Boolean expression and then use algebraic rules to simplify that expression, resulting in a circuit with fewer gates."
        },
        "vi": {
            "question": "ƒê·∫°i s·ªë Boolean ƒë√≥ng g√≥p nh∆∞ th·∫ø n√†o v√†o vi·ªác thi·∫øt k·∫ø c√°c m·∫°ch k·ªπ thu·∫≠t s·ªë?",
            "options": [
                "A. N√≥ ƒë∆°n gi·∫£n h√≥a vi·ªác th·ª±c hi·ªán c√°c ch·ª©c nƒÉng mong mu·ªën.",
                "B. N√≥ gi√∫p trong vi·ªác ph√¢n t√≠ch d·ªØ li·ªáu kinh t·∫ø.",
                "C. N√≥ t·∫°o ƒëi·ªÅu ki·ªán cho vi·ªác thi·∫øt k·∫ø c√°c m·∫°ch t∆∞∆°ng t·ª±.",
                "D. N√≥ ch·ªß y·∫øu ƒë∆∞·ª£c s·ª≠ d·ª•ng cho k·ªπ thu·∫≠t h√≥a h·ªçc v√† k·ªπ thu·∫≠t v·∫≠t l√Ω."
            ],
            "answer": "A. N√≥ ƒë∆°n gi·∫£n h√≥a vi·ªác th·ª±c hi·ªán c√°c ch·ª©c nƒÉng mong mu·ªën.",
            "explanation": "ƒê·∫°i s·ªë Boolean cung c·∫•p n·ªÅn t·∫£ng to√°n h·ªçc cho logic s·ªë. N√≥ cho ph√©p c√°c nh√† thi·∫øt k·∫ø bi·ªÉu di·ªÖn m·ªôt ch·ª©c nƒÉng m·∫°ch mong mu·ªën d∆∞·ªõi d·∫°ng m·ªôt bi·ªÉu th·ª©c Boolean v√† sau ƒë√≥ s·ª≠ d·ª•ng c√°c quy t·∫Øc ƒë·∫°i s·ªë ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a bi·ªÉu th·ª©c ƒë√≥, d·∫´n ƒë·∫øn m·ªôt m·∫°ch c√≥ √≠t c·ªïng h∆°n."
        }
    },
    {
        "id": 229,
        "en": {
            "question": "When both inputs are 0, what is the result of the NOR gate?",
            "options": [
                "A. 0",
                "B. 1",
                "C. 2",
                "D. Undetermined"
            ],
            "answer": "B. 1",
            "explanation": "A NOR gate is an OR gate followed by a NOT gate. (0 OR 0) is 0. NOT(0) is 1. Thus, the output is 1."
        },
        "vi": {
            "question": "Khi c·∫£ hai ƒë·∫ßu v√†o ƒë·ªÅu l√† 0, k·∫øt qu·∫£ c·ªßa c·ªïng NOR l√† g√¨?",
            "options": [
                "A. 0",
                "B. 1",
                "C. 2",
                "D. Kh√¥ng x√°c ƒë·ªãnh"
            ],
            "answer": "B. 1",
            "explanation": "M·ªôt c·ªïng NOR l√† m·ªôt c·ªïng OR theo sau l√† m·ªôt c·ªïng NOT. (0 OR 0) l√† 0. NOT(0) l√† 1. Do ƒë√≥, ƒë·∫ßu ra l√† 1."
        }
    },
    {
        "id": 230,
        "en": {
            "question": "A binary representation of -15 is ____. (Using 2's complement, 8-bit)",
            "options": [
                "A. 00100000",
                "B. 10000000",
                "C. 11110001",
                "D. 01000000"
            ],
            "answer": "C. 11110001",
            "explanation": "+15 in 8-bit binary is 00001111. To get -15 in 2's complement, you invert the bits (11110000) and add 1, which results in 11110001."
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn nh·ªã ph√¢n c·ªßa -15 l√† ____. (S·ª≠ d·ª•ng b√π 2, 8-bit)",
            "options": [
                "A. 00100000",
                "B. 10000000",
                "C. 11110001",
                "D. 01000000"
            ],
            "answer": "C. 11110001",
            "explanation": "+15 trong nh·ªã ph√¢n 8-bit l√† 00001111. ƒê·ªÉ c√≥ ƒë∆∞·ª£c -15 trong b√π 2, b·∫°n ƒë·∫£o ng∆∞·ª£c c√°c bit (11110000) v√† c·ªông th√™m 1, k·∫øt qu·∫£ l√† 11110001."
        }
    },
    {
        "id": 231,
        "en": {
            "question": "The binary value of the ASCII letter 'c' is 01100011. Its decimal value is ____.",
            "options": [
                "A. 45",
                "B. 100",
                "C. 99",
                "D. 123"
            ],
            "answer": "C. 99",
            "explanation": "01100011 (binary) = 0*128 + 1*64 + 1*32 + 0*16 + 0*8 + 0*4 + 1*2 + 1*1 = 64 + 32 + 2 + 1 = 99 (decimal)."
        },
        "vi": {
            "question": "Gi√° tr·ªã nh·ªã ph√¢n c·ªßa ch·ªØ c√°i ASCII \"c\" l√† 01100011. Gi√° tr·ªã th·∫≠p ph√¢n c·ªßa n√≥ l√† ____.",
            "options": [
                "A. 45",
                "B. 100",
                "C. 99",
                "D. 123"
            ],
            "answer": "C. 99",
            "explanation": "01100011 (nh·ªã ph√¢n) = 0*128 + 1*64 + 1*32 + 0*16 + 0*8 + 0*4 + 1*2 + 1*1 = 64 + 32 + 2 + 1 = 99 (th·∫≠p ph√¢n)."
        }
    },
    {
        "id": 232,
        "en": {
            "question": "Consider the expression: 1000 0000 AND 1111 1010. What is the result of this expression?",
            "options": [
                "A. 1000 0000",
                "B. 1111 0000",
                "C. 1001 1010",
                "D. 1001 0101"
            ],
            "answer": "A. 1000 0000",
            "explanation": "The bitwise AND operation results in a 1 only if both corresponding bits are 1. Comparing bit by bit: 1&1=1, 0&1=0, 0&1=0, 0&1=0, 0&1=0, 0&0=0, 0&1=0, 0&0=0. The result is 1000 0000."
        },
        "vi": {
            "question": "Xem x√©t bi·ªÉu th·ª©c: 1000 0000 AND 1111 1010. K·∫øt qu·∫£ c·ªßa bi·ªÉu th·ª©c n√†y l√† g√¨?",
            "options": [
                "A. 1000 0000",
                "B. 1111 0000",
                "C. 1001 1010",
                "D. 1001 0101"
            ],
            "answer": "A. 1000 0000",
            "explanation": "Ph√©p to√°n AND bit ch·ªâ cho k·∫øt qu·∫£ l√† 1 n·∫øu c·∫£ hai bit t∆∞∆°ng ·ª©ng ƒë·ªÅu l√† 1. So s√°nh t·ª´ng bit: 1&1=1, 0&1=0, 0&1=0, 0&1=0, 0&1=0, 0&0=0, 0&1=0, 0&0=0. K·∫øt qu·∫£ l√† 1000 0000."
        }
    },
    {
        "id": 233,
        "en": {
            "question": "Consider an expression: NOT (A OR B). Choose the correct expression equal to the given expression.",
            "options": [
                "A. A NOR B",
                "B. A NAND B",
                "C. NOT A NOR B",
                "D. NOT A OR B"
            ],
            "answer": "A. A NOR B",
            "explanation": "The definition of the NOR operation is the negation (NOT) of an OR operation. Therefore, NOT (A OR B) is logically equivalent to A NOR B."
        },
        "vi": {
            "question": "Xem x√©t m·ªôt bi·ªÉu th·ª©c: NOT (A OR B). Ch·ªçn bi·ªÉu th·ª©c ƒë√∫ng b·∫±ng v·ªõi bi·ªÉu th·ª©c ƒë√£ cho.",
            "options": [
                "A. A NOR B",
                "B. A NAND B",
                "C. NOT A NOR B",
                "D. NOT A OR B"
            ],
            "answer": "A. A NOR B",
            "explanation": "ƒê·ªãnh nghƒ©a c·ªßa ph√©p to√°n NOR l√† ph√©p ph·ªß ƒë·ªãnh (NOT) c·ªßa m·ªôt ph√©p to√°n OR. Do ƒë√≥, NOT (A OR B) t∆∞∆°ng ƒë∆∞∆°ng logic v·ªõi A NOR B."
        }
    },
    {
        "id": 234,
        "en": {
            "question": "The ____ operation yields true (binary value 1) if and only if both of its operands are true.",
            "options": [
                "A. OR",
                "B. AND",
                "C. XOR",
                "D. NAND"
            ],
            "answer": "B. AND",
            "explanation": "This is the definition of the logical AND operation. The result is 1 only when input A is 1 AND input B is 1."
        },
        "vi": {
            "question": "Ph√©p to√°n ___ mang l·∫°i gi√° tr·ªã true (gi√° tr·ªã nh·ªã ph√¢n 1) khi v√† ch·ªâ khi c·∫£ hai to√°n h·∫°ng c·ªßa n√≥ ƒë·ªÅu l√† true.",
            "options": [
                "A. OR",
                "B. AND",
                "C. XOR",
                "D. NAND"
            ],
            "answer": "B. AND",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa ph√©p to√°n logic AND. K·∫øt qu·∫£ l√† 1 ch·ªâ khi ƒë·∫ßu v√†o A l√† 1 V√Ä ƒë·∫ßu v√†o B l√† 1."
        }
    },
    {
        "id": 235,
        "en": {
            "question": "Suppose a truth table... Which basic operator fits the above table? (Table: 1 1 -> 1; 1 0 -> 0; 0 1 -> 0; 0 0 -> 0)",
            "options": [
                "A. AND",
                "B. OR",
                "C. NAND",
                "D. NOR"
            ],
            "answer": "A. AND",
            "explanation": "The truth table shows that the output is 1 only when both inputs are 1. This is the definition of the AND operator."
        },
        "vi": {
            "question": "Gi·∫£ s·ª≠ m·ªôt b·∫£ng ch√¢n l√Ω... To√°n t·ª≠ c∆° b·∫£n n√†o ph√π h·ª£p v·ªõi b·∫£ng tr√™n? (B·∫£ng: 1 1 -> 1; 1 0 -> 0; 0 1 -> 0; 0 0 -> 0)",
            "options": [
                "A. AND",
                "B. OR",
                "C. NAND",
                "D. NOR"
            ],
            "answer": "A. AND",
            "explanation": "B·∫£ng ch√¢n l√Ω cho th·∫•y ƒë·∫ßu ra l√† 1 ch·ªâ khi c·∫£ hai ƒë·∫ßu v√†o ƒë·ªÅu l√† 1. ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa to√°n t·ª≠ AND."
        }
    },
    {
        "id": 236,
        "en": {
            "question": "Consider the expression: 1000 0000 OR 1111 1010. What is the result of this expression?",
            "options": [
                "A. 1000 0000",
                "B. 1111 1010",
                "C. 1001 1010",
                "D. 1001 0101"
            ],
            "answer": "B. 1111 1010",
            "explanation": "The bitwise OR operation results in a 1 if at least one of the corresponding bits is 1. Comparing bit by bit: 1|1=1, 0|1=1, 0|1=1, 0|1=1, 0|1=1, 0|0=0, 0|1=1, 0|0=0. The result is 1111 1010."
        },
        "vi": {
            "question": "Xem x√©t bi·ªÉu th·ª©c: 1000 0000 OR 1111 1010. K·∫øt qu·∫£ c·ªßa bi·ªÉu th·ª©c n√†y l√† g√¨?",
            "options": [
                "A. 1000 0000",
                "B. 1111 1010",
                "C. 1001 1010",
                "D. 1001 0101"
            ],
            "answer": "B. 1111 1010",
            "explanation": "Ph√©p to√°n OR bit cho k·∫øt qu·∫£ l√† 1 n·∫øu √≠t nh·∫•t m·ªôt trong c√°c bit t∆∞∆°ng ·ª©ng l√† 1. So s√°nh t·ª´ng bit: 1|1=1, 0|1=1, 0|1=1, 0|1=1, 0|1=1, 0|0=0, 0|1=1, 0|0=0. K·∫øt qu·∫£ l√† 1111 1010."
        }
    },
    {
        "id": 237,
        "en": {
            "question": "Consider the expression: NOT (1111 1010). What is the result of this expression?",
            "options": [
                "A. 0000 1010",
                "B. 0000 0101",
                "C. 1111 0101",
                "D. 1111 1010"
            ],
            "answer": "B. 0000 0101",
            "explanation": "The bitwise NOT operation inverts every bit. Each 1 becomes a 0, and each 0 becomes a 1. NOT(1111 1010) = 0000 0101."
        },
        "vi": {
            "question": "Xem x√©t bi·ªÉu th·ª©c: NOT (1111 1010). K·∫øt qu·∫£ c·ªßa bi·ªÉu th·ª©c n√†y l√† g√¨?",
            "options": [
                "A. 0000 1010",
                "B. 0000 0101",
                "C. 1111 0101",
                "D. 1111 1010"
            ],
            "answer": "B. 0000 0101",
            "explanation": "Ph√©p to√°n NOT bit ƒë·∫£o ng∆∞·ª£c m·ªçi bit. M·ªói 1 tr·ªü th√†nh 0, v√† m·ªói 0 tr·ªü th√†nh 1. NOT(1111 1010) = 0000 0101."
        }
    },
    {
        "id": 238,
        "en": {
            "question": "What is a characteristic of a sequential circuit compared to a combinational circuit?",
            "options": [
                "A. Does not use gates.",
                "B. The output depends only on the current inputs.",
                "C. The output depends on current inputs and past inputs.",
                "D. Is simpler to design and implement."
            ],
            "answer": "C. The output depends on current inputs and past inputs.",
            "explanation": "This is the key difference. Sequential circuits have memory elements (like flip-flops) that store the 'state' or history of past inputs, which influences the current output. Combinational circuits are memoryless."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† m·ªôt ƒë·∫∑c ƒëi·ªÉm c·ªßa m·∫°ch tu·∫ßn t·ª± so v·ªõi m·∫°ch t·ªï h·ª£p?",
            "options": [
                "A. Kh√¥ng s·ª≠ d·ª•ng c·ªïng.",
                "B. ƒê·∫ßu ra ch·ªâ ph·ª• thu·ªôc v√†o c√°c ƒë·∫ßu v√†o hi·ªán t·∫°i.",
                "C. ƒê·∫ßu ra ph·ª• thu·ªôc v√†o c√°c ƒë·∫ßu v√†o hi·ªán t·∫°i v√† c√°c ƒë·∫ßu v√†o trong qu√° kh·ª©.",
                "D. ƒê∆°n gi·∫£n h∆°n ƒë·ªÉ thi·∫øt k·∫ø v√† th·ª±c hi·ªán."
            ],
            "answer": "C. ƒê·∫ßu ra ph·ª• thu·ªôc v√†o c√°c ƒë·∫ßu v√†o hi·ªán t·∫°i v√† c√°c ƒë·∫ßu v√†o trong qu√° kh·ª©.",
            "explanation": "ƒê√¢y l√† s·ª± kh√°c bi·ªát ch√≠nh. M·∫°ch tu·∫ßn t·ª± c√≥ c√°c ph·∫ßn t·ª≠ nh·ªõ (nh∆∞ flip-flop) l∆∞u tr·ªØ 'tr·∫°ng th√°i' ho·∫∑c l·ªãch s·ª≠ c·ªßa c√°c ƒë·∫ßu v√†o trong qu√° kh·ª©, ƒëi·ªÅu n√†y ·∫£nh h∆∞·ªüng ƒë·∫øn ƒë·∫ßu ra hi·ªán t·∫°i. M·∫°ch t·ªï h·ª£p kh√¥ng c√≥ b·ªô nh·ªõ."
        }
    },
    {
        "id": 239,
        "en": {
            "question": "A unary operator is applied to ____ relation(s) and creates an output of ____ relation(s).",
            "options": [
                "A. one, two",
                "B. two, one",
                "C. one, one",
                "D. two, two"
            ],
            "answer": "C. one, one",
            "explanation": "A unary operator (like NOT) takes a single operand (one relation/input) and produces a single result (one relation/output)."
        },
        "vi": {
            "question": "M·ªôt to√°n t·ª≠ m·ªôt ng√¥i ƒë∆∞·ª£c √°p d·ª•ng cho ____ quan h·ªá v√† t·∫°o ra m·ªôt ƒë·∫ßu ra c·ªßa ____ quan h·ªá.",
            "options": [
                "A. m·ªôt, hai",
                "B. hai, m·ªôt",
                "C. m·ªôt, m·ªôt",
                "D. hai, hai"
            ],
            "answer": "C. m·ªôt, m·ªôt",
            "explanation": "M·ªôt to√°n t·ª≠ m·ªôt ng√¥i (nh∆∞ NOT) nh·∫≠n m·ªôt to√°n h·∫°ng duy nh·∫•t (m·ªôt quan h·ªá/ƒë·∫ßu v√†o) v√† t·∫°o ra m·ªôt k·∫øt qu·∫£ duy nh·∫•t (m·ªôt quan h·ªá/ƒë·∫ßu ra)."
        }
    },
    {
        "id": 240,
        "en": {
            "question": "If you have an integer +18 in sign-magnitude representation, which is 00010010, what is the correct choice for -18?",
            "options": [
                "A. 00010010",
                "B. 10010010",
                "C. 11110010",
                "D. 01110010"
            ],
            "answer": "B. 10010010",
            "explanation": "In sign-magnitude representation, the most significant bit (MSB) is the sign bit (0 for positive, 1 for negative), and the remaining bits represent the magnitude. To negate a number, you simply flip the sign bit. So, 00010010 becomes 10010010."
        },
        "vi": {
            "question": "N·∫øu b·∫°n c√≥ m·ªôt s·ªë nguy√™n +18 trong bi·ªÉu di·ªÖn d·∫•u-ƒë·ªô l·ªõn, l√† 00010010, l·ª±a ch·ªçn ƒë√∫ng cho -18 l√† g√¨?",
            "options": [
                "A. 00010010",
                "B. 10010010",
                "C. 11110010",
                "D. 01110010"
            ],
            "answer": "B. 10010010",
            "explanation": "Trong bi·ªÉu di·ªÖn d·∫•u-ƒë·ªô l·ªõn, bit c√≥ tr·ªçng s·ªë cao nh·∫•t (MSB) l√† bit d·∫•u (0 cho d∆∞∆°ng, 1 cho √¢m), v√† c√°c bit c√≤n l·∫°i bi·ªÉu di·ªÖn ƒë·ªô l·ªõn. ƒê·ªÉ ph·ªß ƒë·ªãnh m·ªôt s·ªë, b·∫°n ch·ªâ c·∫ßn ƒë·∫£o bit d·∫•u. V√¨ v·∫≠y, 00010010 tr·ªü th√†nh 10010010."
        }
    },
    {
        "id": 241,
        "en": {
            "question": "Represent the integer +18 (using 8-bit length) in two's complement representation.",
            "options": [
                "A. 00010010",
                "B. 10010010",
                "C. 00001101",
                "D. 10011101"
            ],
            "answer": "A. 00010010",
            "explanation": "For positive numbers, the two's complement representation is the same as the standard binary representation. 18 = 16 + 2 = 2^4 + 2^1. In 8 bits, this is 00010010."
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn m·ªôt s·ªë nguy√™n +18 (s·ª≠ d·ª•ng ƒë·ªô d√†i 8-bit) trong bi·ªÉu di·ªÖn b√π hai.",
            "options": [
                "A. 00010010",
                "B. 10010010",
                "C. 00001101",
                "D. 10011101"
            ],
            "answer": "A. 00010010",
            "explanation": "ƒê·ªëi v·ªõi c√°c s·ªë d∆∞∆°ng, bi·ªÉu di·ªÖn b√π hai gi·ªëng nh∆∞ bi·ªÉu di·ªÖn nh·ªã ph√¢n ti√™u chu·∫©n. 18 = 16 + 2 = 2^4 + 2^1. Trong 8 bit, ƒë√¢y l√† 00010010."
        }
    },
    {
        "id": 242,
        "en": {
            "question": "(R1) = 01110110, (R2) = 11011111, the result of (R1) XOR (R2) is:",
            "options": [
                "A. 11011011",
                "B. 00010110",
                "C. 10101001",
                "D. 11001101"
            ],
            "answer": "C. 10101001",
            "explanation": "Performing a bitwise XOR: 0^1=1, 1^1=0, 1^0=1, 1^1=0, 0^1=1, 1^1=0, 1^1=0, 0^1=1. Result: 10101001."
        },
        "vi": {
            "question": "(R1) = 01110110, (R2) = 11011111, k·∫øt qu·∫£ c·ªßa (R1) XOR (R2) l√†:",
            "options": [
                "A. 11011011",
                "B. 00010110",
                "C. 10101001",
                "D. 11001101"
            ],
            "answer": "C. 10101001",
            "explanation": "Th·ª±c hi·ªán ph√©p XOR t·ª´ng bit: 0^1=1, 1^1=0, 1^0=1, 1^1=0, 0^1=1, 1^1=0, 1^1=0, 0^1=1. K·∫øt qu·∫£: 10101001."
        }
    },
    {
        "id": 243,
        "en": {
            "question": "A binary representation of -7 is ____? (2's complement, 4-bit)",
            "options": [
                "A. 0111",
                "B. 1001",
                "C. 1011",
                "D. 1101"
            ],
            "answer": "B. 1001",
            "explanation": "+7 in 4-bit is 0111. Invert the bits to get 1000. Add 1 to get 1001. So, -7 is 1001."
        },
        "vi": {
            "question": "Bi·ªÉu di·ªÖn nh·ªã ph√¢n c·ªßa -7 l√† ____? (B√π 2, 4-bit)",
            "options": [
                "A. 0111",
                "B. 1001",
                "C. 1011",
                "D. 1101"
            ],
            "answer": "B. 1001",
            "explanation": "+7 trong 4-bit l√† 0111. ƒê·∫£o c√°c bit ƒë·ªÉ ƒë∆∞·ª£c 1000. C·ªông th√™m 1 ƒë·ªÉ ƒë∆∞·ª£c 1001. V·∫≠y, -7 l√† 1001."
        }
    },
    {
        "id": 244,
        "en": {
            "question": "How many possible values can we have with 8 bits?",
            "options": [
                "A. 256",
                "B. 127",
                "C. 1 byte",
                "D. 8"
            ],
            "answer": "A. 256",
            "explanation": "With n bits, you can represent 2^n distinct values. For 8 bits, this is 2^8 = 256."
        },
        "vi": {
            "question": "Ch√∫ng ta c√≥ th·ªÉ c√≥ bao nhi√™u gi√° tr·ªã kh·∫£ dƒ© v·ªõi 8 bit?",
            "options": [
                "A. 256",
                "B. 127",
                "C. 1 byte",
                "D. 8"
            ],
            "answer": "A. 256",
            "explanation": "V·ªõi n bit, b·∫°n c√≥ th·ªÉ bi·ªÉu di·ªÖn 2^n gi√° tr·ªã ri√™ng bi·ªát. ƒê·ªëi v·ªõi 8 bit, ƒë√≥ l√† 2^8 = 256."
        }
    },
    {
        "id": 245,
        "en": {
            "question": "A byte consists of ____ bits.",
            "options": [
                "A. 8",
                "B. 16",
                "C. 2",
                "D. 4"
            ],
            "answer": "A. 8",
            "explanation": "A byte is a standard unit of digital information that consists of 8 bits."
        },
        "vi": {
            "question": "M·ªôt byte bao g·ªìm ____ bit.",
            "options": [
                "A. 8",
                "B. 16",
                "C. 2",
                "D. 4"
            ],
            "answer": "A. 8",
            "explanation": "M·ªôt byte l√† m·ªôt ƒë∆°n v·ªã th√¥ng tin s·ªë ti√™u chu·∫©n bao g·ªìm 8 bit."
        }
    },
    {
        "id": 246,
        "en": {
            "question": "Claude Shannon, a research assistant in the Electrical Engineering Department at M.I.T., proposed the fundamental principles of Boolean algebra.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "George Boole developed Boolean algebra in the 19th century. Claude Shannon, in his master's thesis, showed how Boolean algebra could be used to design and simplify switching circuits."
        },
        "vi": {
            "question": "Claude Shannon, m·ªôt tr·ª£ l√Ω nghi√™n c·ª©u t·∫°i Khoa K·ªπ thu·∫≠t ƒêi·ªán c·ªßa M.I.T., ƒë√£ ƒë·ªÅ xu·∫•t c√°c nguy√™n t·∫Øc c∆° b·∫£n c·ªßa ƒë·∫°i s·ªë Boolean.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "George Boole ƒë√£ ph√°t tri·ªÉn ƒë·∫°i s·ªë Boolean v√†o th·∫ø k·ª∑ 19. Claude Shannon, trong lu·∫≠n vƒÉn th·∫°c sƒ© c·ªßa m√¨nh, ƒë√£ ch·ªâ ra c√°ch ƒë·∫°i s·ªë Boolean c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ thi·∫øt k·∫ø v√† ƒë∆°n gi·∫£n h√≥a c√°c m·∫°ch chuy·ªÉn m·∫°ch."
        }
    },
    {
        "id": 247,
        "en": {
            "question": "Any Boolean function can be implemented in electronic form as a network of gates.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "This is a fundamental concept of digital logic design. Any logical expression can be physically realized using a combination of basic logic gates like AND, OR, and NOT."
        },
        "vi": {
            "question": "B·∫•t k·ª≥ h√†m Boolean n√†o c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán ·ªü d·∫°ng ƒëi·ªán t·ª≠ nh∆∞ m·ªôt m·∫°ng l∆∞·ªõi c√°c c·ªïng.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "ƒê√¢y l√† m·ªôt kh√°i ni·ªám c∆° b·∫£n c·ªßa thi·∫øt k·∫ø logic s·ªë. B·∫•t k·ª≥ bi·ªÉu th·ª©c logic n√†o c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c hi·ªán th·ª±c h√≥a v·ªÅ m·∫∑t v·∫≠t l√Ω b·∫±ng c√°ch s·ª≠ d·ª•ng m·ªôt s·ª± k·∫øt h·ª£p c·ªßa c√°c c·ªïng logic c∆° b·∫£n nh∆∞ AND, OR v√† NOT."
        }
    },
    {
        "id": 248,
        "en": {
            "question": "The ____ operation yields true if either or both of its operands are true.",
            "options": [
                "A. NOT",
                "B. AND",
                "C. NAND",
                "D. OR"
            ],
            "answer": "D. OR",
            "explanation": "This is the definition of the inclusive OR operation. The result is 1 if input A is 1, or if input B is 1, or if both are 1."
        },
        "vi": {
            "question": "Ph√©p to√°n ____ mang l·∫°i gi√° tr·ªã true n·∫øu m·ªôt trong hai to√°n h·∫°ng c·ªßa n√≥ l√† true.",
            "options": [
                "A. NOT",
                "B. AND",
                "C. NAND",
                "D. OR"
            ],
            "answer": "D. OR",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa ph√©p to√°n OR. K·∫øt qu·∫£ l√† 1 n·∫øu ƒë·∫ßu v√†o A l√† 1, ho·∫∑c n·∫øu ƒë·∫ßu v√†o B l√† 1, ho·∫∑c n·∫øu c·∫£ hai ƒë·ªÅu l√† 1."
        }
    },
    {
        "id": 249,
        "en": {
            "question": "A ____ is an electronic circuit that produces an output signal that is a simple Boolean operation on its input signals.",
            "options": [
                "A. gate",
                "B. decoder",
                "C. counter",
                "D. flip-flop"
            ],
            "answer": "A. gate",
            "explanation": "This is the definition of a logic gate, the basic building block of digital circuits."
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt m·∫°ch ƒëi·ªán t·ª≠ t·∫°o ra m·ªôt t√≠n hi·ªáu ƒë·∫ßu ra l√† m·ªôt ph√©p to√°n Boolean ƒë∆°n gi·∫£n tr√™n c√°c t√≠n hi·ªáu ƒë·∫ßu v√†o c·ªßa n√≥.",
            "options": [
                "A. c·ªïng (gate)",
                "B. b·ªô gi·∫£i m√£ (decoder)",
                "C. b·ªô ƒë·∫øm (counter)",
                "D. flip-flop"
            ],
            "answer": "A. c·ªïng (gate)",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m·ªôt c·ªïng logic, kh·ªëi x√¢y d·ª±ng c∆° b·∫£n c·ªßa c√°c m·∫°ch k·ªπ thu·∫≠t s·ªë."
        }
    },
    {
        "id": 250,
        "en": {
            "question": "A ____ is implemented with combinational circuits.",
            "options": [
                "A. Nano memory",
                "B. Random access memory",
                "C. Read only memory",
                "D. No memory"
            ],
            "answer": "C. Read only memory",
            "explanation": "A ROM can be thought of as a large combinational circuit that takes an address as input and produces the stored data word as output. RAM, on the other hand, is a sequential circuit as it has memory elements (latches/capacitors)."
        },
        "vi": {
            "question": "____ ƒë∆∞·ª£c th·ª±c hi·ªán v·ªõi c√°c m·∫°ch t·ªï h·ª£p.",
            "options": [
                "A. Nano memory",
                "B. Random access memory",
                "C. Read only memory",
                "D. No memory"
            ],
            "answer": "C. Read only memory",
            "explanation": "M·ªôt ROM c√≥ th·ªÉ ƒë∆∞·ª£c coi l√† m·ªôt m·∫°ch t·ªï h·ª£p l·ªõn nh·∫≠n m·ªôt ƒë·ªãa ch·ªâ l√†m ƒë·∫ßu v√†o v√† t·∫°o ra t·ª´ d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ l√†m ƒë·∫ßu ra. RAM, m·∫∑t kh√°c, l√† m·ªôt m·∫°ch tu·∫ßn t·ª± v√¨ n√≥ c√≥ c√°c ph·∫ßn t·ª≠ nh·ªõ (ch·ªët/t·ª• ƒëi·ªán)."
        }
    },
    {
        "id": 251,
        "en": {
            "question": "For the SOP expression AB' + B'C, how many 0's are in the output column of the truth table?",
            "options": [
                "A. 5",
                "B. zero",
                "C. 1",
                "D. 4"
            ],
            "answer": "A. 5",
            "explanation": "The expression is true when (A=1, B=0) or (B=0, C=1). The combinations for true are: A'B'C (001), AB'C' (100), AB'C (101). There are 3 true cases out of 8 total possibilities (2^3). Therefore, there are 8 - 3 = 5 false cases (0s)."
        },
        "vi": {
            "question": "ƒê·ªëi v·ªõi bi·ªÉu th·ª©c SOP AB'+B'C, c√≥ bao nhi√™u s·ªë 0 trong c·ªôt ƒë·∫ßu ra c·ªßa b·∫£ng ch√¢n l√Ω?",
            "options": [
                "A. 5",
                "B. zero",
                "C. 1",
                "D. 4"
            ],
            "answer": "A. 5",
            "explanation": "Bi·ªÉu th·ª©c ƒë√∫ng khi (A=1, B=0) ho·∫∑c (B=0, C=1). C√°c t·ªï h·ª£p ƒë√∫ng l√†: A'B'C (001), AB'C' (100), AB'C (101). C√≥ 3 tr∆∞·ªùng h·ª£p ƒë√∫ng trong t·ªïng s·ªë 8 kh·∫£ nƒÉng (2^3). Do ƒë√≥, c√≥ 8 - 3 = 5 tr∆∞·ªùng h·ª£p sai (0)."
        }
    },
    {
        "id": 252,
        "en": {
            "question": "A binary operator is applied to ____ relation(s) and creates an output of ____ relation(s).",
            "options": [
                "A. one, two",
                "B. two, one",
                "C. one, one",
                "D. two, two"
            ],
            "answer": "B. two, one",
            "explanation": "A binary operator (like AND, OR, XOR) takes two operands (two relations/inputs) and produces a single result (one relation/output)."
        },
        "vi": {
            "question": "M·ªôt to√°n t·ª≠ nh·ªã ph√¢n ƒë∆∞·ª£c √°p d·ª•ng cho ____ quan h·ªá v√† t·∫°o ra m·ªôt ƒë·∫ßu ra c·ªßa ____ quan h·ªá.",
            "options": [
                "A. m·ªôt, hai",
                "B. hai, m·ªôt",
                "C. m·ªôt, m·ªôt",
                "D. hai, hai"
            ],
            "answer": "B. hai, m·ªôt",
            "explanation": "M·ªôt to√°n t·ª≠ nh·ªã ph√¢n (nh∆∞ AND, OR, XOR) nh·∫≠n hai to√°n h·∫°ng (hai quan h·ªá/ƒë·∫ßu v√†o) v√† t·∫°o ra m·ªôt k·∫øt qu·∫£ duy nh·∫•t (m·ªôt quan h·ªá/ƒë·∫ßu ra)."
        }
    },
    {
        "id": 253,
        "en": {
            "question": "The ____ operation yields true if one or the other of its operands are true.",
            "options": [
                "A. NOT",
                "B. AND",
                "C. NAND",
                "D. OR"
            ],
            "answer": "D. OR",
            "explanation": "The inclusive OR operation is true if A is true, or B is true, or both are true."
        },
        "vi": {
            "question": "Ph√©p to√°n ____ mang l·∫°i gi√° tr·ªã true n·∫øu m·ªôt ho·∫∑c c·∫£ hai to√°n h·∫°ng c·ªßa n√≥ l√† true.",
            "options": [
                "A. NOT",
                "B. AND",
                "C. NAND",
                "D. OR"
            ],
            "answer": "D. OR",
            "explanation": "Ph√©p to√°n OR l√† ƒë√∫ng n·∫øu A ƒë√∫ng, ho·∫∑c B ƒë√∫ng, ho·∫∑c c·∫£ hai ƒë·ªÅu ƒë√∫ng."
        }
    },
    // Chuy√™n m·ª•c 11: Instruction Sets: Characteristics (T·∫≠p l·ªánh: ƒê·∫∑c ƒëi·ªÉm) - 16 c√¢u
    {
        "id": 254,
        "en": {
            "question": "For the elements of a machine instruction, what is the meaning of the opcode?",
            "options": [
                "A. It specifies the operation to be performed.",
                "B. It specifies the data to be processed.",
                "C. It specifies memory access.",
                "D. It specifies an I/O device."
            ],
            "answer": "A. It specifies the operation to be performed.",
            "explanation": "The opcode (operation code) is the portion of a machine language instruction that specifies the action to be performed, such as ADD, LOAD, or JUMP."
        },
        "vi": {
            "question": "ƒê·ªëi v·ªõi c√°c y·∫øu t·ªë c·ªßa m·ªôt l·ªánh m√°y, m√£ l·ªánh c√≥ √Ω nghƒ©a g√¨?",
            "options": [
                "A. N√≥ ch·ªâ ƒë·ªãnh ho·∫°t ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán.",
                "B. N√≥ ch·ªâ ƒë·ªãnh d·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω.",
                "C. N√≥ ch·ªâ ƒë·ªãnh truy c·∫≠p b·ªô nh·ªõ.",
                "D. N√≥ ch·ªâ ƒë·ªãnh m·ªôt thi·∫øt b·ªã I/O."
            ],
            "answer": "A. N√≥ ch·ªâ ƒë·ªãnh ho·∫°t ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán.",
            "explanation": "M√£ l·ªánh (opcode) l√† m·ªôt ph·∫ßn c·ªßa l·ªánh ng√¥n ng·ªØ m√°y ch·ªâ ƒë·ªãnh h√†nh ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán, ch·∫≥ng h·∫°n nh∆∞ ADD, LOAD, ho·∫∑c JUMP."
        }
    },
    {
        "id": 255,
        "en": {
            "question": "Which of the following statements is NOT the most common statement in different types of statements in a high-level programming language?",
            "options": [
                "A. GOTO statement.",
                "B. IF statement.",
                "C. CLOOP statement.",
                "D. CALL procedure statement."
            ],
            "answer": "C. CLOOP statement.",
            "explanation": "IF, GOTO (or its structured equivalents like loops and branches), and procedure CALLs are fundamental. 'CLOOP' is not a standard statement type; it might be a specific implementation in a niche language but is not common."
        },
        "vi": {
            "question": "Trong c√°c lo·∫°i c√¢u l·ªánh kh√°c nhau trong m·ªôt ng√¥n ng·ªØ l·∫≠p tr√¨nh c·∫•p cao, c√¢u l·ªánh n√†o kh√¥ng ph·∫£i l√† c√¢u l·ªánh ph·ªï bi·∫øn nh·∫•t?",
            "options": [
                "A. C√¢u l·ªánh GOTO.",
                "B. C√¢u l·ªánh IF.",
                "C. C√¢u l·ªánh CLOOP.",
                "D. C√¢u l·ªánh g·ªçi th·ªß t·ª•c CALL."
            ],
            "answer": "C. C√¢u l·ªánh CLOOP.",
            "explanation": "IF, GOTO (ho·∫∑c c√°c c·∫•u tr√∫c t∆∞∆°ng ƒë∆∞∆°ng nh∆∞ v√≤ng l·∫∑p v√† r·∫Ω nh√°nh), v√† g·ªçi th·ªß t·ª•c CALL l√† c∆° b·∫£n. 'CLOOP' kh√¥ng ph·∫£i l√† m·ªôt lo·∫°i c√¢u l·ªánh ti√™u chu·∫©n; n√≥ c√≥ th·ªÉ l√† m·ªôt tri·ªÉn khai c·ª• th·ªÉ trong m·ªôt ng√¥n ng·ªØ chuy√™n bi·ªát nh∆∞ng kh√¥ng ph·ªï bi·∫øn."
        }
    },
    {
        "id": 256,
        "en": {
            "question": "Which of the following is not a common data type found in machine instruction sets?",
            "options": [
                "A. Addresses",
                "B. Numbers (Integer, Floating-point)",
                "C. Characters",
                "D. Images"
            ],
            "answer": "D. Images",
            "explanation": "Machine instructions operate on fundamental data types like numbers, characters (which are just numbers), and addresses. Complex data types like images are handled by software as collections of these fundamental types."
        },
        "vi": {
            "question": "Ki·ªÉu d·ªØ li·ªáu n√†o sau ƒë√¢y kh√¥ng ph·∫£i l√† ki·ªÉu d·ªØ li·ªáu ph·ªï bi·∫øn trong t·∫≠p l·ªánh m√°y?",
            "options": [
                "A. ƒê·ªãa ch·ªâ",
                "B. S·ªë (S·ªë nguy√™n, D·∫•u ph·∫©y ƒë·ªông)",
                "C. K√Ω t·ª±",
                "D. H√¨nh ·∫£nh"
            ],
            "answer": "D. H√¨nh ·∫£nh",
            "explanation": "L·ªánh m√°y ho·∫°t ƒë·ªông tr√™n c√°c ki·ªÉu d·ªØ li·ªáu c∆° b·∫£n nh∆∞ s·ªë, k√Ω t·ª± (c≈©ng ch·ªâ l√† s·ªë), v√† ƒë·ªãa ch·ªâ. C√°c ki·ªÉu d·ªØ li·ªáu ph·ª©c t·∫°p nh∆∞ h√¨nh ·∫£nh ƒë∆∞·ª£c ph·∫ßn m·ªÅm x·ª≠ l√Ω d∆∞·ªõi d·∫°ng t·∫≠p h·ª£p c·ªßa c√°c ki·ªÉu c∆° b·∫£n n√†y."
        }
    },
    {
        "id": 257,
        "en": {
            "question": "What kind of instruction is a 'scalar instruction'?",
            "options": [
                "A. An instruction in which all operands must be single values.",
                "B. An instruction in which all operands must be groups like arrays.",
                "C. An instruction in which all operands can be single values or groups.",
                "D. An instruction with no operands."
            ],
            "answer": "A. An instruction in which all operands must be single values.",
            "explanation": "A scalar operation works on individual data items (like a single integer or float). This is in contrast to a vector or SIMD instruction, which operates on multiple data items simultaneously."
        },
        "vi": {
            "question": "L·ªánh v√¥ h∆∞·ªõng (scalar instruction) l√† g√¨?",
            "options": [
                "A. M·ªôt l·ªánh trong ƒë√≥ t·∫•t c·∫£ c√°c to√°n h·∫°ng ph·∫£i l√† c√°c gi√° tr·ªã ƒë∆°n.",
                "B. M·ªôt l·ªánh trong ƒë√≥ t·∫•t c·∫£ c√°c to√°n h·∫°ng ph·∫£i l√† c√°c nh√≥m nh∆∞ m·∫£ng.",
                "C. M·ªôt l·ªánh trong ƒë√≥ t·∫•t c·∫£ c√°c to√°n h·∫°ng c√≥ th·ªÉ l√† c√°c gi√° tr·ªã ƒë∆°n ho·∫∑c nh√≥m.",
                "D. M·ªôt l·ªánh kh√¥ng c√≥ to√°n h·∫°ng."
            ],
            "answer": "A. M·ªôt l·ªánh trong ƒë√≥ t·∫•t c·∫£ c√°c to√°n h·∫°ng ph·∫£i l√† c√°c gi√° tr·ªã ƒë∆°n.",
            "explanation": "M·ªôt ho·∫°t ƒë·ªông v√¥ h∆∞·ªõng ho·∫°t ƒë·ªông tr√™n c√°c m·ª•c d·ªØ li·ªáu ri√™ng l·∫ª (nh∆∞ m·ªôt s·ªë nguy√™n ho·∫∑c s·ªë th·ª±c duy nh·∫•t). ƒêi·ªÅu n√†y tr√°i ng∆∞·ª£c v·ªõi m·ªôt l·ªánh vector ho·∫∑c SIMD, ho·∫°t ƒë·ªông tr√™n nhi·ªÅu m·ª•c d·ªØ li·ªáu ƒë·ªìng th·ªùi."
        }
    },
    {
        "id": 258,
        "en": {
            "question": "What is a branch instruction?",
            "options": [
                "A. Instructions used to divide a program into multiple subprograms.",
                "B. Instructions that have one of their operands as the address of the next instruction to be executed.",
                "C. Instructions used to pause a program.",
                "D. Instructions used to return to the beginning of a program."
            ],
            "answer": "B. Instructions that have one of their operands as the address of the next instruction to be executed.",
            "explanation": "A branch instruction (or jump) alters the normal sequential flow of execution by changing the program counter to a new address, which is specified as an operand in the instruction."
        },
        "vi": {
            "question": "L·ªánh r·∫Ω nh√°nh (branch instruction) l√† g√¨?",
            "options": [
                "A. C√°c l·ªánh ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ chia m·ªôt ch∆∞∆°ng tr√¨nh th√†nh nhi·ªÅu ch∆∞∆°ng tr√¨nh con.",
                "B. C√°c l·ªánh c√≥ m·ªôt trong c√°c to√°n h·∫°ng c·ªßa n√≥ l√† ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c th·ª±c thi.",
                "C. C√°c l·ªánh ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫°m d·ª´ng ch∆∞∆°ng tr√¨nh.",
                "D. C√°c l·ªánh ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ quay l·∫°i ƒë·∫ßu ch∆∞∆°ng tr√¨nh."
            ],
            "answer": "B. C√°c l·ªánh c√≥ m·ªôt trong c√°c to√°n h·∫°ng c·ªßa n√≥ l√† ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c th·ª±c thi.",
            "explanation": "M·ªôt l·ªánh r·∫Ω nh√°nh (ho·∫∑c nh·∫£y) l√†m thay ƒë·ªïi lu·ªìng th·ª±c thi tu·∫ßn t·ª± th√¥ng th∆∞·ªùng b·∫±ng c√°ch thay ƒë·ªïi b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh th√†nh m·ªôt ƒë·ªãa ch·ªâ m·ªõi, ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh nh∆∞ m·ªôt to√°n h·∫°ng trong l·ªánh."
        }
    },
    // Chuy√™n m·ª•c 12: Instruction Sets: Addressing Modes (T·∫≠p l·ªánh: C√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ) - 15 c√¢u
    {
        "id": 259,
        "en": {
            "question": "Which type of addressing is used primarily by almost all RISC instructions?",
            "options": [
                "A. Immediate addressing",
                "B. Register addressing",
                "C. Indirect addressing",
                "D. Direct addressing"
            ],
            "answer": "B. Register addressing",
            "explanation": "RISC architectures are load/store architectures, meaning that most instructions (like arithmetic and logic) operate only on data held in registers. Memory is accessed only through explicit LOAD and STORE instructions."
        },
        "vi": {
            "question": "Lo·∫°i ƒë·ªãa ch·ªâ h√≥a n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ch·ªß y·∫øu b·ªüi h·∫ßu h·∫øt t·∫•t c·∫£ c√°c l·ªánh RISC?",
            "options": [
                "A. ƒê·ªãa ch·ªâ h√≥a t·ª©c th·ªùi (Immediate addressing)",
                "B. ƒê·ªãa ch·ªâ h√≥a thanh ghi (Register addressing)",
                "C. ƒê·ªãa ch·ªâ h√≥a gi√°n ti·∫øp (Indirect addressing)",
                "D. ƒê·ªãa ch·ªâ h√≥a tr·ª±c ti·∫øp (Direct addressing)"
            ],
            "answer": "B. ƒê·ªãa ch·ªâ h√≥a thanh ghi (Register addressing)",
            "explanation": "Ki·∫øn tr√∫c RISC l√† ki·∫øn tr√∫c t·∫£i/l∆∞u, c√≥ nghƒ©a l√† h·∫ßu h·∫øt c√°c l·ªánh (nh∆∞ s·ªë h·ªçc v√† logic) ch·ªâ ho·∫°t ƒë·ªông tr√™n d·ªØ li·ªáu ƒë∆∞·ª£c gi·ªØ trong c√°c thanh ghi. B·ªô nh·ªõ ch·ªâ ƒë∆∞·ª£c truy c·∫≠p th√¥ng qua c√°c l·ªánh LOAD v√† STORE t∆∞·ªùng minh."
        }
    },
    {
        "id": 260,
        "en": {
            "question": "What is the main advantage of the indirect addressing mode?",
            "options": [
                "A. Faster access to operands.",
                "B. Ability to access a larger dataset.",
                "C. Flexibility in data location.",
                "D. Reduced instruction size."
            ],
            "answer": "B. Ability to access a larger dataset.",
            "explanation": "Indirect addressing provides a large address space. The address field in the instruction points to a memory location that contains the full address of the operand. This allows a small address field in the instruction to reference any location in a large memory."
        },
        "vi": {
            "question": "∆Øu ƒëi·ªÉm ch√≠nh c·ªßa ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a gi√°n ti·∫øp (indirect addressing mode) l√† g√¨?",
            "options": [
                "A. Truy c·∫≠p nhanh h∆°n v√†o c√°c to√°n h·∫°ng.",
                "B. Kh·∫£ nƒÉng truy c·∫≠p m·ªôt t·∫≠p d·ªØ li·ªáu l·ªõn h∆°n.",
                "C. Linh ho·∫°t v·ªÅ v·ªã tr√≠ d·ªØ li·ªáu.",
                "D. Gi·∫£m k√≠ch th∆∞·ªõc l·ªánh."
            ],
            "answer": "B. Kh·∫£ nƒÉng truy c·∫≠p m·ªôt t·∫≠p d·ªØ li·ªáu l·ªõn h∆°n.",
            "explanation": "ƒê·ªãa ch·ªâ h√≥a gi√°n ti·∫øp cung c·∫•p m·ªôt kh√¥ng gian ƒë·ªãa ch·ªâ l·ªõn. Tr∆∞·ªùng ƒë·ªãa ch·ªâ trong l·ªánh tr·ªè ƒë·∫øn m·ªôt v·ªã tr√≠ b·ªô nh·ªõ ch·ª©a ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß c·ªßa to√°n h·∫°ng. ƒêi·ªÅu n√†y cho ph√©p m·ªôt tr∆∞·ªùng ƒë·ªãa ch·ªâ nh·ªè trong l·ªánh c√≥ th·ªÉ tham chi·∫øu ƒë·∫øn b·∫•t k·ª≥ v·ªã tr√≠ n√†o trong m·ªôt b·ªô nh·ªõ l·ªõn."
        }
    },
    {
        "id": 261,
        "en": {
            "question": "Which addressing mode allows specifying a memory address directly within the instruction?",
            "options": [
                "A. Direct",
                "B. Indirect",
                "C. Register Indirect",
                "D. Displacement"
            ],
            "answer": "A. Direct",
            "explanation": "In direct addressing, the address field of the instruction contains the actual memory address of the operand. It requires only one memory reference and no special calculation."
        },
        "vi": {
            "question": "Ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a n√†o cho ph√©p ch·ªâ ƒë·ªãnh tr·ª±c ti·∫øp ƒë·ªãa ch·ªâ b·ªô nh·ªõ trong l·ªánh?",
            "options": [
                "A. Tr·ª±c ti·∫øp (Direct)",
                "B. Gi√°n ti·∫øp (Indirect)",
                "C. Gi√°n ti·∫øp qua thanh ghi (Register Indirect)",
                "D. D·ªãch chuy·ªÉn (Displacement)"
            ],
            "answer": "A. Tr·ª±c ti·∫øp (Direct)",
            "explanation": "Trong ƒë·ªãa ch·ªâ h√≥a tr·ª±c ti·∫øp, tr∆∞·ªùng ƒë·ªãa ch·ªâ c·ªßa l·ªánh ch·ª©a ƒë·ªãa ch·ªâ b·ªô nh·ªõ th·ª±c t·∫ø c·ªßa to√°n h·∫°ng. N√≥ ch·ªâ y√™u c·∫ßu m·ªôt tham chi·∫øu b·ªô nh·ªõ v√† kh√¥ng c·∫ßn t√≠nh to√°n ƒë·∫∑c bi·ªát."
        }
    },
    {
        "id": 262,
        "en": {
            "question": "Which of the following statements is true about addressing modes?",
            "options": [
                "A. They define how the operands of an instruction are specified, including immediate, register, direct, and indirect addressing modes.",
                "B. Addressing modes are irrelevant in computer architecture, and all instructions operate only on values stored in registers.",
                "C. Addressing modes are limited to immediate and direct modes; register and indirect addressing modes are not used in modern computer systems.",
                "D. All instructions in computer architecture use indirect addressing modes, making it the only relevant mode for specifying operands."
            ],
            "answer": "A. They define how the operands of an instruction are specified, including immediate, register, direct, and indirect addressing modes.",
            "explanation": "This is the correct definition. Addressing modes provide different ways for an instruction to specify the location of its operand(s), offering trade-offs between speed, address space size, and flexibility."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† ƒë√∫ng v·ªÅ c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a?",
            "options": [
                "A. Ch√∫ng x√°c ƒë·ªãnh c√°ch c√°c to√°n h·∫°ng c·ªßa m·ªôt l·ªánh ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh, bao g·ªìm c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a t·ª©c th·ªùi, thanh ghi, tr·ª±c ti·∫øp v√† gi√°n ti·∫øp.",
                "B. C√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a kh√¥ng li√™n quan trong ki·∫øn tr√∫c m√°y t√≠nh, v√† t·∫•t c·∫£ c√°c l·ªánh ch·ªâ ho·∫°t ƒë·ªông tr√™n c√°c gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ trong c√°c thanh ghi.",
                "C. C√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a ch·ªâ gi·ªõi h·∫°n ·ªü c√°c ch·∫ø ƒë·ªô t·ª©c th·ªùi v√† tr·ª±c ti·∫øp; c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a thanh ghi v√† gi√°n ti·∫øp kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h·ªá th·ªëng m√°y t√≠nh hi·ªán ƒë·∫°i.",
                "D. T·∫•t c·∫£ c√°c l·ªánh trong ki·∫øn tr√∫c m√°y t√≠nh s·ª≠ d·ª•ng c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a gi√°n ti·∫øp, l√†m cho n√≥ tr·ªü th√†nh ch·∫ø ƒë·ªô li√™n quan duy nh·∫•t ƒë·ªÉ ch·ªâ ƒë·ªãnh to√°n h·∫°ng."
            ],
            "answer": "A. Ch√∫ng x√°c ƒë·ªãnh c√°ch c√°c to√°n h·∫°ng c·ªßa m·ªôt l·ªánh ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh, bao g·ªìm c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a t·ª©c th·ªùi, thanh ghi, tr·ª±c ti·∫øp v√† gi√°n ti·∫øp.",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a ƒë√∫ng. C√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a cung c·∫•p c√°c c√°ch kh√°c nhau ƒë·ªÉ m·ªôt l·ªánh ch·ªâ ƒë·ªãnh v·ªã tr√≠ c·ªßa (c√°c) to√°n h·∫°ng c·ªßa n√≥, cung c·∫•p s·ª± ƒë√°nh ƒë·ªïi gi·ªØa t·ªëc ƒë·ªô, k√≠ch th∆∞·ªõc kh√¥ng gian ƒë·ªãa ch·ªâ v√† t√≠nh linh ho·∫°t."
        }
    },
    {
        "id": 263,
        "en": {
            "question": "The effective address of the Register indirect addressing mode is ____.",
            "options": [
                "A. EA = R",
                "B. EA = (R)",
                "C. EA = (R)+A",
                "D. EA = (R)+(A)"
            ],
            "answer": "B. EA = (R)",
            "explanation": "In register indirect addressing, the register (R) does not contain the operand itself, but rather the memory address of the operand. The parentheses (R) denote 'contents of R'."
        },
        "vi": {
            "question": "ƒê·ªãa ch·ªâ hi·ªáu d·ª•ng c·ªßa ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ gi√°n ti·∫øp thanh ghi (Register indirect addressing) l√† ___.",
            "options": [
                "A. EA = R",
                "B. EA = (R)",
                "C. EA = (R)+A",
                "D. EA = (R)+(A)"
            ],
            "answer": "B. EA = (R)",
            "explanation": "Trong ƒë·ªãa ch·ªâ h√≥a gi√°n ti·∫øp thanh ghi, thanh ghi (R) kh√¥ng ch·ª©a ch√≠nh to√°n h·∫°ng, m√† l√† ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa to√°n h·∫°ng. D·∫•u ngo·∫∑c (R) bi·ªÉu th·ªã 'n·ªôi dung c·ªßa R'."
        }
    },
    {
        "id": 264,
        "en": {
            "question": "The disadvantage of immediate addressing is that the size of the number is restricted to the size of the address field.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "In immediate addressing, the operand value is part of the instruction itself. The space available for this value is limited by the number of bits allocated in the instruction format's address field."
        },
        "vi": {
            "question": "Nh∆∞·ª£c ƒëi·ªÉm c·ªßa vi·ªác ƒë·ªãnh ƒë·ªãa ch·ªâ t·ª©c th·ªùi l√† k√≠ch th∆∞·ªõc c·ªßa s·ªë b·ªã gi·ªõi h·∫°n b·ªüi k√≠ch th∆∞·ªõc c·ªßa tr∆∞·ªùng ƒë·ªãa ch·ªâ.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Trong ƒë·ªãa ch·ªâ h√≥a t·ª©c th·ªùi, gi√° tr·ªã to√°n h·∫°ng l√† m·ªôt ph·∫ßn c·ªßa ch√≠nh l·ªánh ƒë√≥. Kh√¥ng gian c√≥ s·∫µn cho gi√° tr·ªã n√†y b·ªã gi·ªõi h·∫°n b·ªüi s·ªë l∆∞·ª£ng bit ƒë∆∞·ª£c ph√¢n b·ªï trong tr∆∞·ªùng ƒë·ªãa ch·ªâ c·ªßa ƒë·ªãnh d·∫°ng l·ªánh."
        }
    },
    {
        "id": 265,
        "en": {
            "question": "Register indirect addressing uses the same number of memory references as indirect addressing.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "Register indirect addressing uses one memory reference (to get the data). Indirect addressing uses two memory references (one to get the address, a second to get the data)."
        },
        "vi": {
            "question": "Vi·ªác ƒë·ªãnh ƒë·ªãa ch·ªâ gi√°n ti·∫øp qua thanh ghi s·ª≠ d·ª•ng c√πng s·ªë l∆∞·ª£ng tham chi·∫øu b·ªô nh·ªõ nh∆∞ vi·ªác ƒë·ªãnh ƒë·ªãa ch·ªâ gi√°n ti·∫øp.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ƒê·ªãa ch·ªâ h√≥a gi√°n ti·∫øp qua thanh ghi s·ª≠ d·ª•ng m·ªôt tham chi·∫øu b·ªô nh·ªõ (ƒë·ªÉ l·∫•y d·ªØ li·ªáu). ƒê·ªãa ch·ªâ h√≥a gi√°n ti·∫øp s·ª≠ d·ª•ng hai tham chi·∫øu b·ªô nh·ªõ (m·ªôt ƒë·ªÉ l·∫•y ƒë·ªãa ch·ªâ, m·ªôt ƒë·ªÉ l·∫•y d·ªØ li·ªáu)."
        }
    },
    {
        "id": 266,
        "en": {
            "question": "Three of the most common uses of stack addressing are relative addressing, base-register addressing, and indexing.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The question mixes up addressing modes. Relative, base-register, and indexing are forms of Displacement addressing, not Stack addressing. Stack addressing is typically implicit, operating on the top of the stack."
        },
        "vi": {
            "question": "Ba trong s·ªë c√°c c√°ch s·ª≠ d·ª•ng ph·ªï bi·∫øn nh·∫•t c·ªßa vi·ªác ƒë·ªãnh ƒë·ªãa ch·ªâ ngƒÉn x·∫øp l√† ƒë·ªãnh ƒë·ªãa ch·ªâ t∆∞∆°ng ƒë·ªëi, ƒë·ªãnh ƒë·ªãa ch·ªâ c∆° s·ªü-thanh ghi, v√† l·∫≠p ch·ªâ m·ª•c.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "C√¢u h·ªèi n√†y nh·∫ßm l·∫´n c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a. T∆∞∆°ng ƒë·ªëi, c∆° s·ªü-thanh ghi v√† l·∫≠p ch·ªâ m·ª•c l√† c√°c d·∫°ng c·ªßa ƒë·ªãa ch·ªâ h√≥a d·ªãch chuy·ªÉn (Displacement), kh√¥ng ph·∫£i ƒë·ªãa ch·ªâ h√≥a ngƒÉn x·∫øp. ƒê·ªãa ch·ªâ h√≥a ngƒÉn x·∫øp th∆∞·ªùng l√† ng·∫ßm ƒë·ªãnh, ho·∫°t ƒë·ªông tr√™n ƒë·ªânh c·ªßa ngƒÉn x·∫øp."
        }
    },
    // Chuy√™n m·ª•c 13: Processor Structure and Function (C·∫•u tr√∫c v√† Ch·ª©c nƒÉng B·ªô x·ª≠ l√Ω) - 20 c√¢u
    {
        "id": 267,
        "en": {
            "question": "The registers, ALU, and the interconnecting between them are collectively called the ____.",
            "options": [
                "A. information trail",
                "B. data",
                "C. information path",
                "D. datapath"
            ],
            "answer": "D. datapath",
            "explanation": "The datapath is the part of the CPU that performs arithmetic and logical operations and holds data. It consists of the ALU, registers, and their interconnections."
        },
        "vi": {
            "question": "C√°c thanh ghi, ALU v√† s·ª± k·∫øt n·ªëi gi·ªØa ch√∫ng ƒë∆∞·ª£c g·ªçi chung l√† ____.",
            "options": [
                "A. D·∫•u v·∫øt th√¥ng tin (Information trail)",
                "B. D·ªØ li·ªáu (data)",
                "C. ƒê∆∞·ªùng d·∫´n th√¥ng tin (information path)",
                "D. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu (datapath)"
            ],
            "answer": "D. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu (datapath)",
            "explanation": "ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu l√† m·ªôt ph·∫ßn c·ªßa CPU th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông s·ªë h·ªçc v√† logic v√† gi·ªØ d·ªØ li·ªáu. N√≥ bao g·ªìm ALU, c√°c thanh ghi, v√† c√°c k·∫øt n·ªëi gi·ªØa ch√∫ng."
        }
    },
    {
        "id": 268,
        "en": {
            "question": "Which register can be assigned to various functions by the programmer?",
            "options": [
                "A. Data registers",
                "B. General purpose registers",
                "C. Address registers",
                "D. Condition codes (flags)"
            ],
            "answer": "B. General purpose registers",
            "explanation": "General-purpose registers (GPRs) are not dedicated to a single function and can be used by the programmer for a variety of purposes, such as holding data for arithmetic operations or holding addresses."
        },
        "vi": {
            "question": "Thanh ghi n√†o c√≥ th·ªÉ ƒë∆∞·ª£c g√°n cho nhi·ªÅu ch·ª©c nƒÉng kh√°c nhau b·ªüi l·∫≠p tr√¨nh vi√™n?",
            "options": [
                "A. Thanh ghi d·ªØ li·ªáu (Data registers)",
                "B. Thanh ghi ƒëa d·ª•ng (General purpose registers)",
                "C. Thanh ghi ƒë·ªãa ch·ªâ (Address registers)",
                "D. M√£ ƒëi·ªÅu ki·ªán (c·ªù) (Condition codes (flags))"
            ],
            "answer": "B. Thanh ghi ƒëa d·ª•ng (General purpose registers)",
            "explanation": "C√°c thanh ghi ƒëa d·ª•ng (GPR) kh√¥ng d√†nh ri√™ng cho m·ªôt ch·ª©c nƒÉng duy nh·∫•t v√† c√≥ th·ªÉ ƒë∆∞·ª£c l·∫≠p tr√¨nh vi√™n s·ª≠ d·ª•ng cho nhi·ªÅu m·ª•c ƒë√≠ch kh√°c nhau, ch·∫≥ng h·∫°n nh∆∞ gi·ªØ d·ªØ li·ªáu cho c√°c ho·∫°t ƒë·ªông s·ªë h·ªçc ho·∫∑c gi·ªØ ƒë·ªãa ch·ªâ."
        }
    },
    {
        "id": 269,
        "en": {
            "question": "The register which holds the address of the next instruction to be executed is the ____.",
            "options": [
                "A. AC",
                "B. MQ",
                "C. IR",
                "D. MBR",
                "E. PC"
            ],
            "answer": "E. PC",
            "explanation": "The Program Counter (PC), also known as the Instruction Pointer (IP), always contains the memory address of the next instruction to be fetched."
        },
        "vi": {
            "question": "Thanh ghi gi·ªØ ƒë·ªãa ch·ªâ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c th·ª±c thi l√† ____.",
            "options": [
                "A. AC",
                "B. MQ",
                "C. IR",
                "D. MBR",
                "E. PC"
            ],
            "answer": "E. PC",
            "explanation": "B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC), c√≤n ƒë∆∞·ª£c g·ªçi l√† Con tr·ªè l·ªánh (IP), lu√¥n ch·ª©a ƒë·ªãa ch·ªâ b·ªô nh·ªõ c·ªßa l·ªánh ti·∫øp theo s·∫Ω ƒë∆∞·ª£c t√¨m n·∫°p."
        }
    },
    {
        "id": 270,
        "en": {
            "question": "The ____ contains the data word to be written to memory or the word most recently read.",
            "options": [
                "A. MAR",
                "B. PC",
                "C. MBR",
                "D. IR"
            ],
            "answer": "C. MBR",
            "explanation": "The Memory Buffer Register (MBR), also known as the Memory Data Register (MDR), acts as a buffer between the CPU and main memory, holding the data that is being transferred."
        },
        "vi": {
            "question": "____ ch·ª©a t·ª´ d·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c ghi v√†o b·ªô nh·ªõ ho·∫∑c t·ª´ ƒë∆∞·ª£c ƒë·ªçc g·∫ßn ƒë√¢y nh·∫•t.",
            "options": [
                "A. MAR",
                "B. PC",
                "C. MBR",
                "D. IR"
            ],
            "answer": "C. MBR",
            "explanation": "Thanh ghi b·ªô ƒë·ªám b·ªô nh·ªõ (MBR), c√≤n ƒë∆∞·ª£c g·ªçi l√† Thanh ghi d·ªØ li·ªáu b·ªô nh·ªõ (MDR), ho·∫°t ƒë·ªông nh∆∞ m·ªôt b·ªô ƒë·ªám gi·ªØa CPU v√† b·ªô nh·ªõ ch√≠nh, gi·ªØ d·ªØ li·ªáu ƒëang ƒë∆∞·ª£c truy·ªÅn."
        }
    },
    {
        "id": 271,
        "en": {
            "question": "The allocation of control information between registers and memory is not considered a key design issue.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "This is a very important design issue. The number of registers, their types (general purpose vs. special purpose), and how they are used has a significant impact on instruction set design and processor performance."
        },
        "vi": {
            "question": "S·ª± ph√¢n b·ªï th√¥ng tin ƒëi·ªÅu khi·ªÉn gi·ªØa c√°c thanh ghi v√† b·ªô nh·ªõ kh√¥ng ƒë∆∞·ª£c coi l√† m·ªôt v·∫•n ƒë·ªÅ thi·∫øt k·∫ø ch√≠nh.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "ƒê√¢y l√† m·ªôt v·∫•n ƒë·ªÅ thi·∫øt k·∫ø r·∫•t quan tr·ªçng. S·ªë l∆∞·ª£ng thanh ghi, lo·∫°i c·ªßa ch√∫ng (ƒëa d·ª•ng so v·ªõi chuy√™n d·ª•ng), v√† c√°ch ch√∫ng ƒë∆∞·ª£c s·ª≠ d·ª•ng c√≥ t√°c ƒë·ªông ƒë√°ng k·ªÉ ƒë·∫øn thi·∫øt k·∫ø t·∫≠p l·ªánh v√† hi·ªáu su·∫•t c·ªßa b·ªô x·ª≠ l√Ω."
        }
    },
    // Chuy√™n m·ª•c 14: Reduced Instruction Set Computers (RISC) - 9 c√¢u
    {
        "id": 272,
        "en": {
            "question": "What is the main benefit of using RISC over CISC?",
            "options": [
                "A. RISC has more instructions and addressing modes than CISC.",
                "B. RISC has a faster instruction execution rate and simpler instruction decoding than CISC.",
                "C. RISC has variable-length instruction formats and more direct memory access than CISC.",
                "D. RISC has more registers and pipelines than CISC."
            ],
            "answer": "B. RISC has a faster instruction execution rate and simpler instruction decoding than CISC.",
            "explanation": "The core idea of RISC is to have a small set of simple, fixed-length instructions that can each be executed in a single clock cycle. This simplifies the control unit and allows for effective pipelining, leading to faster overall execution."
        },
        "vi": {
            "question": "L·ª£i √≠ch ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng RISC so v·ªõi CISC l√† g√¨?",
            "options": [
                "A. RISC c√≥ nhi·ªÅu l·ªánh v√† ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h∆°n CISC.",
                "B. RISC c√≥ t·ªëc ƒë·ªô th·ª±c thi l·ªánh nhanh h∆°n v√† gi·∫£i m√£ l·ªánh ƒë∆°n gi·∫£n h∆°n CISC.",
                "C. RISC c√≥ c√°c ƒë·ªãnh d·∫°ng l·ªánh c√≥ ƒë·ªô d√†i thay ƒë·ªïi v√† truy c·∫≠p b·ªô nh·ªõ tr·ª±c ti·∫øp h∆°n CISC.",
                "D. RISC c√≥ nhi·ªÅu thanh ghi v√† ƒë∆∞·ªùng ·ªëng h∆°n CISC."
            ],
            "answer": "B. RISC c√≥ t·ªëc ƒë·ªô th·ª±c thi l·ªánh nhanh h∆°n v√† gi·∫£i m√£ l·ªánh ƒë∆°n gi·∫£n h∆°n CISC.",
            "explanation": "√ù t∆∞·ªüng c·ªët l√µi c·ªßa RISC l√† c√≥ m·ªôt t·∫≠p h·ª£p nh·ªè c√°c l·ªánh ƒë∆°n gi·∫£n, c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh, m·ªói l·ªánh c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c thi trong m·ªôt chu k·ª≥ xung nh·ªãp duy nh·∫•t. ƒêi·ªÅu n√†y ƒë∆°n gi·∫£n h√≥a ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn v√† cho ph√©p t·∫°o ƒë∆∞·ªùng ·ªëng hi·ªáu qu·∫£, d·∫´n ƒë·∫øn vi·ªác th·ª±c thi t·ªïng th·ªÉ nhanh h∆°n."
        }
    },
    {
        "id": 273,
        "en": {
            "question": "Which of the following statements describes a RISC (Reduced Instruction Set Computer) architecture?",
            "options": [
                "A. Many complex instructions.",
                "B. Fixed-length instructions.",
                "C. Extensive use of memory addressing modes.",
                "D. Emphasis on multitasking capabilities."
            ],
            "answer": "B. Fixed-length instructions.",
            "explanation": "A key characteristic of RISC is a small number of simple, fixed-length instructions. This simplifies the instruction decoding hardware and facilitates pipelining. Complex instructions and many memory addressing modes are hallmarks of CISC."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y m√¥ t·∫£ m·ªôt ki·∫øn tr√∫c RISC (Reduced Instruction Set Computer)?",
            "options": [
                "A. Nhi·ªÅu l·ªánh ph·ª©c t·∫°p.",
                "B. ƒê·ªô d√†i l·ªánh c·ªë ƒë·ªãnh.",
                "C. S·ª≠ d·ª•ng r·ªông r√£i c√°c ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a b·ªô nh·ªõ.",
                "D. Nh·∫•n m·∫°nh v√†o kh·∫£ nƒÉng ƒëa nhi·ªám."
            ],
            "answer": "B. ƒê·ªô d√†i l·ªánh c·ªë ƒë·ªãnh.",
            "explanation": "M·ªôt ƒë·∫∑c ƒëi·ªÉm ch√≠nh c·ªßa RISC l√† m·ªôt s·ªë l∆∞·ª£ng nh·ªè c√°c l·ªánh ƒë∆°n gi·∫£n, c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh. ƒêi·ªÅu n√†y ƒë∆°n gi·∫£n h√≥a ph·∫ßn c·ª©ng gi·∫£i m√£ l·ªánh v√† t·∫°o ƒëi·ªÅu ki·ªán cho vi·ªác t·∫°o ƒë∆∞·ªùng ·ªëng. C√°c l·ªánh ph·ª©c t·∫°p v√† nhi·ªÅu ch·∫ø ƒë·ªô ƒë·ªãa ch·ªâ h√≥a b·ªô nh·ªõ l√† ƒë·∫∑c ƒëi·ªÉm c·ªßa CISC."
        }
    },
    {
        "id": 274,
        "en": {
            "question": "With simple cycle instructions, there is little or no need for microcode.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Simple, single-cycle instructions (a hallmark of RISC) can be hardwired directly in the control unit. Microcode is a technique used to implement complex, multi-cycle instructions (a hallmark of CISC)."
        },
        "vi": {
            "question": "V·ªõi c√°c l·ªánh chu k·ª≥ ƒë∆°n gi·∫£n, c√≥ r·∫•t √≠t ho·∫∑c kh√¥ng c·∫ßn microcode.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "C√°c l·ªánh ƒë∆°n gi·∫£n, m·ªôt chu k·ª≥ (m·ªôt ƒë·∫∑c ƒëi·ªÉm c·ªßa RISC) c√≥ th·ªÉ ƒë∆∞·ª£c n·ªëi c·ª©ng tr·ª±c ti·∫øp trong ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn. Microcode l√† m·ªôt k·ªπ thu·∫≠t ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ th·ª±c hi·ªán c√°c l·ªánh ph·ª©c t·∫°p, nhi·ªÅu chu k·ª≥ (m·ªôt ƒë·∫∑c ƒëi·ªÉm c·ªßa CISC)."
        }
    },
    // Chuy√™n m·ª•c 15: Instruction-Level Parallelism (Song song m·ª©c l·ªánh) - 11 c√¢u
    {
        "id": 275,
        "en": {
            "question": "What does the term 'instruction-level parallelism' in computer architecture mean?",
            "options": [
                "A. The degree to which the instructions in a program can be executed in parallel.",
                "B. The number of processing cores in a multi-core CPU with multiple resources.",
                "C. The complexity of the instruction set architecture.",
                "D. The length of an instruction cycle with a high-level programming language."
            ],
            "answer": "A. The degree to which the instructions in a program can be executed in parallel.",
            "explanation": "Instruction-level parallelism (ILP) refers to the potential overlap in the execution of instructions. Techniques like pipelining and superscalar execution are used to exploit ILP and execute more than one instruction per clock cycle."
        },
        "vi": {
            "question": "Thu·∫≠t ng·ªØ \"song song m·ª©c l·ªánh\" (instruction-level parallelism) trong ki·∫øn tr√∫c m√°y t√≠nh c√≥ nghƒ©a l√† g√¨?",
            "options": [
                "A. M·ª©c ƒë·ªô m√† c√°c l·ªánh trong m·ªôt ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán song song.",
                "B. S·ªë l∆∞·ª£ng l√µi x·ª≠ l√Ω trong m·ªôt CPU ƒëa l√µi v·ªõi nhi·ªÅu t√†i nguy√™n.",
                "C. S·ª± ph·ª©c t·∫°p c·ªßa ki·∫øn tr√∫c t·∫≠p l·ªánh.",
                "D. ƒê·ªô d√†i c·ªßa m·ªôt chu k·ª≥ l·ªánh v·ªõi ng√¥n ng·ªØ l·∫≠p tr√¨nh c·∫•p cao."
            ],
            "answer": "A. M·ª©c ƒë·ªô m√† c√°c l·ªánh trong m·ªôt ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán song song.",
            "explanation": "Song song m·ª©c l·ªánh (ILP) ƒë·ªÅ c·∫≠p ƒë·∫øn kh·∫£ nƒÉng ch·ªìng ch√©o trong vi·ªác th·ª±c thi c√°c l·ªánh. C√°c k·ªπ thu·∫≠t nh∆∞ t·∫°o ƒë∆∞·ªùng ·ªëng (pipelining) v√† th·ª±c thi si√™u v√¥ h∆∞·ªõng (superscalar) ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ khai th√°c ILP v√† th·ª±c thi nhi·ªÅu h∆°n m·ªôt l·ªánh m·ªói chu k·ª≥ xung nh·ªãp."
        }
    },
    {
        "id": 276,
        "en": {
            "question": "In a SuperScalar computer architecture, what is the main goal of using multiple processors simultaneously?",
            "options": [
                "A. Increase the processing speed by increasing the CPU frequency.",
                "B. Improve performance by executing more than one instruction per machine cycle.",
                "C. Reduce the size of the CPU to save power.",
                "D. Enhance computing power by increasing the number of CPU cores."
            ],
            "answer": "B. Improve performance by executing more than one instruction per machine cycle.",
            "explanation": "A superscalar processor achieves instruction-level parallelism by having multiple execution units (e.g., multiple ALUs, multiple FPUs) and dispatching multiple instructions to them in a single clock cycle."
        },
        "vi": {
            "question": "Trong ki·∫øn tr√∫c m√°y t√≠nh SuperScalar, m·ª•c ti√™u ch√≠nh c·ªßa vi·ªác s·ª≠ d·ª•ng nhi·ªÅu b·ªô x·ª≠ l√Ω ƒë·ªìng th·ªùi l√† g√¨?",
            "options": [
                "A. TƒÉng t·ªëc ƒë·ªô x·ª≠ l√Ω b·∫±ng c√°ch tƒÉng t·∫ßn s·ªë CPU.",
                "B. C·∫£i thi·ªán hi·ªáu su·∫•t b·∫±ng c√°ch th·ª±c thi nhi·ªÅu h∆°n m·ªôt l·ªánh cho m·ªói chu k·ª≥ m√°y.",
                "C. Gi·∫£m k√≠ch th∆∞·ªõc c·ªßa CPU ƒë·ªÉ ti·∫øt ki·ªám nƒÉng l∆∞·ª£ng.",
                "D. N√¢ng cao s·ª©c m·∫°nh t√≠nh to√°n b·∫±ng c√°ch tƒÉng s·ªë l∆∞·ª£ng l√µi CPU."
            ],
            "answer": "B. C·∫£i thi·ªán hi·ªáu su·∫•t b·∫±ng c√°ch th·ª±c thi nhi·ªÅu h∆°n m·ªôt l·ªánh cho m·ªói chu k·ª≥ m√°y.",
            "explanation": "M·ªôt b·ªô x·ª≠ l√Ω si√™u v√¥ h∆∞·ªõng ƒë·∫°t ƒë∆∞·ª£c s·ª± song song ·ªü m·ª©c l·ªánh b·∫±ng c√°ch c√≥ nhi·ªÅu ƒë∆°n v·ªã th·ª±c thi (v√≠ d·ª•: nhi·ªÅu ALU, nhi·ªÅu FPU) v√† g·ª≠i nhi·ªÅu l·ªánh ƒë·∫øn ch√∫ng trong m·ªôt chu k·ª≥ xung nh·ªãp duy nh·∫•t."
        }
    },
    {
        "id": 277,
        "en": {
            "question": "In the context of the basic instruction cycle, when the fifth instruction is being executed, which of the following statements is true?",
            "options": [
                "A. The sixth instruction is being fetched.",
                "B. The fifth instruction is being fetched.",
                "C. The fourth instruction is being fetched.",
                "D. All instructions of the program are fetched."
            ],
            "answer": "A. The sixth instruction is being fetched.",
            "explanation": "This describes a pipelined execution. While one instruction is in its execution stage, the next instruction is typically in the decode stage, and the one after that (the sixth) is in the fetch stage."
        },
        "vi": {
            "question": "Trong b·ªëi c·∫£nh c·ªßa chu k·ª≥ l·ªánh c∆° b·∫£n, khi l·ªánh th·ª© nƒÉm ƒëang ƒë∆∞·ª£c th·ª±c thi, ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† ƒë√∫ng?",
            "options": [
                "A. L·ªánh th·ª© s√°u ƒë∆∞·ª£c t√¨m n·∫°p.",
                "B. L·ªánh th·ª© nƒÉm ƒë∆∞·ª£c t√¨m n·∫°p.",
                "C. L·ªánh th·ª© t∆∞ ƒë∆∞·ª£c t√¨m n·∫°p.",
                "D. T·∫•t c·∫£ c√°c l·ªánh c·ªßa ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c t√¨m n·∫°p."
            ],
            "answer": "A. L·ªánh th·ª© s√°u ƒë∆∞·ª£c t√¨m n·∫°p.",
            "explanation": "ƒêi·ªÅu n√†y m√¥ t·∫£ m·ªôt qu√° tr√¨nh th·ª±c thi c√≥ ƒë∆∞·ªùng ·ªëng. Trong khi m·ªôt l·ªánh ƒëang trong giai ƒëo·∫°n th·ª±c thi c·ªßa n√≥, l·ªánh ti·∫øp theo th∆∞·ªùng ƒëang trong giai ƒëo·∫°n gi·∫£i m√£, v√† l·ªánh sau ƒë√≥ n·ªØa (l·ªánh th·ª© s√°u) ƒëang trong giai ƒëo·∫°n t√¨m n·∫°p."
        }
    },
    // Chuy√™n m·ª•c 16: Parallel Processing (X·ª≠ l√Ω song song) - 5 c√¢u
    {
        "id": 278,
        "en": {
            "question": "Which of the following choices is correct for the description: 'A single processor executes a single instruction stream to operate on data stored in a single memory.'?",
            "options": [
                "A. Single instruction, single data (SISD)",
                "B. Single instruction, multiple data (SIMD)",
                "C. Multiple instruction, single data (MISD)",
                "D. Multiple instruction, multiple data (MIMD)"
            ],
            "answer": "A. Single instruction, single data (SISD)",
            "explanation": "This is the definition of a traditional, non-parallel, von Neumann architecture computer, which falls under Flynn's SISD classification."
        },
        "vi": {
            "question": "L·ª±a ch·ªçn n√†o sau ƒë√¢y l√† ƒë√∫ng cho m√¥ t·∫£: \"M·ªôt b·ªô x·ª≠ l√Ω ƒë∆°n th·ª±c thi m·ªôt lu·ªìng l·ªánh ƒë∆°n ƒë·ªÉ ho·∫°t ƒë·ªông tr√™n d·ªØ li·ªáu ƒë∆∞·ª£c l∆∞u tr·ªØ trong m·ªôt b·ªô nh·ªõ ƒë∆°n.\"?",
            "options": [
                "A. L·ªánh ƒë∆°n, d·ªØ li·ªáu ƒë∆°n (SISD)",
                "B. L·ªánh ƒë∆°n, nhi·ªÅu d·ªØ li·ªáu (SIMD)",
                "C. Nhi·ªÅu l·ªánh, d·ªØ li·ªáu ƒë∆°n (MISD)",
                "D. Nhi·ªÅu l·ªánh, nhi·ªÅu d·ªØ li·ªáu (MIMD)"
            ],
            "answer": "A. L·ªánh ƒë∆°n, d·ªØ li·ªáu ƒë∆°n (SISD)",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m·ªôt m√°y t√≠nh ki·∫øn tr√∫c von Neumann truy·ªÅn th·ªëng, kh√¥ng song song, thu·ªôc ph√¢n lo·∫°i SISD c·ªßa Flynn."
        }
    },
    {
        "id": 279,
        "en": {
            "question": "Which computational model is characterized by a large number of processors working on different parts of a single problem simultaneously?",
            "options": [
                "A. Single instruction, single data (SISD)",
                "B. Single instruction, multiple data (SIMD)",
                "C. Multiple instruction, multiple data (MIMD)",
                "D. Multiple instruction, single data (MISD)"
            ],
            "answer": "C. Multiple instruction, multiple data (MIMD)",
            "explanation": "MIMD (Multiple Instruction, Multiple Data) describes parallel computers where each processor can execute a different instruction stream on different data. This is characteristic of multicore processors and distributed systems."
        },
        "vi": {
            "question": "M√¥ h√¨nh t√≠nh to√°n n√†o ƒë∆∞·ª£c ƒë·∫∑c tr∆∞ng b·ªüi m·ªôt s·ªë l∆∞·ª£ng l·ªõn c√°c b·ªô x·ª≠ l√Ω l√†m vi·ªác tr√™n c√°c ph·∫ßn kh√°c nhau c·ªßa m·ªôt v·∫•n ƒë·ªÅ ƒë·ªìng th·ªùi?",
            "options": [
                "A. L·ªánh ƒë∆°n, d·ªØ li·ªáu ƒë∆°n (SISD)",
                "B. L·ªánh ƒë∆°n, nhi·ªÅu d·ªØ li·ªáu (SIMD)",
                "C. Nhi·ªÅu l·ªánh, nhi·ªÅu d·ªØ li·ªáu (MIMD)",
                "D. Nhi·ªÅu l·ªánh, d·ªØ li·ªáu ƒë∆°n (MISD)"
            ],
            "answer": "C. Nhi·ªÅu l·ªánh, nhi·ªÅu d·ªØ li·ªáu (MIMD)",
            "explanation": "MIMD (Nhi·ªÅu l·ªánh, Nhi·ªÅu d·ªØ li·ªáu) m√¥ t·∫£ c√°c m√°y t√≠nh song song n∆°i m·ªói b·ªô x·ª≠ l√Ω c√≥ th·ªÉ th·ª±c thi m·ªôt lu·ªìng l·ªánh kh√°c nhau tr√™n d·ªØ li·ªáu kh√°c nhau. ƒê√¢y l√† ƒë·∫∑c ƒëi·ªÉm c·ªßa c√°c b·ªô x·ª≠ l√Ω ƒëa l√µi v√† c√°c h·ªá th·ªëng ph√¢n t√°n."
        }
    },
    {
        "id": 280,
        "en": {
            "question": "How many general classifications of parallel systems were proposed by Flynn?",
            "options": [
                "A. 2",
                "B. 3",
                "C. 4",
                "D. 5"
            ],
            "answer": "C. 4",
            "explanation": "Flynn's taxonomy classifies computer architectures into four categories: SISD (Single Instruction, Single Data), SIMD (Single Instruction, Multiple Data), MISD (Multiple Instruction, Single Data), and MIMD (Multiple Instruction, Multiple Data)."
        },
        "vi": {
            "question": "C√≥ bao nhi√™u ph√¢n lo·∫°i chung c·ªßa c√°c h·ªá th·ªëng song song ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t b·ªüi Flynn?",
            "options": [
                "A. 2",
                "B. 3",
                "C. 4",
                "D. 5"
            ],
            "answer": "C. 4",
            "explanation": "Ph√¢n lo·∫°i c·ªßa Flynn chia c√°c ki·∫øn tr√∫c m√°y t√≠nh th√†nh b·ªën lo·∫°i: SISD (L·ªánh ƒë∆°n, D·ªØ li·ªáu ƒë∆°n), SIMD (L·ªánh ƒë∆°n, Nhi·ªÅu d·ªØ li·ªáu), MISD (Nhi·ªÅu l·ªánh, D·ªØ li·ªáu ƒë∆°n), v√† MIMD (Nhi·ªÅu l·ªánh, Nhi·ªÅu d·ªØ li·ªáu)."
        }
    },
    {
        "id": 281,
        "en": {
            "question": "Uniprocessors fall into the ____ category of computer systems.",
            "options": [
                "A. MISD",
                "B. SISD",
                "C. MIMD",
                "D. SIMD"
            ],
            "answer": "B. SISD",
            "explanation": "A uniprocessor (single-core CPU) executes a single stream of instructions on a single stream of data, which is the definition of SISD (Single Instruction, Single Data)."
        },
        "vi": {
            "question": "C√°c b·ªô x·ª≠ l√Ω ƒë∆°n (Uniprocessors) thu·ªôc lo·∫°i ____ c·ªßa c√°c h·ªá th·ªëng m√°y t√≠nh.",
            "options": [
                "A. MISD",
                "B. SISD",
                "C. MIMD",
                "D. SIMD"
            ],
            "answer": "B. SISD",
            "explanation": "M·ªôt b·ªô x·ª≠ l√Ω ƒë∆°n (CPU l√µi ƒë∆°n) th·ª±c thi m·ªôt lu·ªìng l·ªánh duy nh·∫•t tr√™n m·ªôt lu·ªìng d·ªØ li·ªáu duy nh·∫•t, ƒë√≥ l√† ƒë·ªãnh nghƒ©a c·ªßa SISD (L·ªánh ƒë∆°n, D·ªØ li·ªáu ƒë∆°n)."
        }
    },
    // Chuy√™n m·ª•c 17: Multicore Computers (M√°y t√≠nh ƒëa l√µi) - 6 c√¢u
    {
        "id": 282,
        "en": {
            "question": "In the context of Register Windows, how many groups of registers are there?",
            "options": [
                "A. 4",
                "B. 3",
                "C. 2",
                "D. No distinction"
            ],
            "answer": "B. 3",
            "explanation": "The register window concept (e.g., in SPARC architecture) typically divides registers into three groups for a procedure call: parameter registers (for passing arguments in), local registers (for the procedure's own use), and temporary registers (for passing arguments out to the next call)."
        },
        "vi": {
            "question": "Trong kh√°i ni·ªám C·ª≠a s·ªï Thanh ghi (Register Windows), c√≥ bao nhi√™u nh√≥m thanh ghi?",
            "options": [
                "A. 4",
                "B. 3",
                "C. 2",
                "D. Kh√¥ng c√≥ s·ª± ph√¢n bi·ªát"
            ],
            "answer": "B. 3",
            "explanation": "Kh√°i ni·ªám c·ª≠a s·ªï thanh ghi (v√≠ d·ª•, trong ki·∫øn tr√∫c SPARC) th∆∞·ªùng chia c√°c thanh ghi th√†nh ba nh√≥m cho m·ªôt l·ªùi g·ªçi th·ªß t·ª•c: thanh ghi tham s·ªë (ƒë·ªÉ truy·ªÅn ƒë·ªëi s·ªë v√†o), thanh ghi c·ª•c b·ªô (cho th·ªß t·ª•c t·ª± s·ª≠ d·ª•ng), v√† thanh ghi t·∫°m th·ªùi (ƒë·ªÉ truy·ªÅn ƒë·ªëi s·ªë ra cho l·ªùi g·ªçi ti·∫øp theo)."
        }
    },
    {
        "id": 283,
        "en": {
            "question": "What is an advantage of Non-Uniform Memory Access (NUMA) over Uniform Memory Access (UMA)?",
            "options": [
                "A. NUMA provides each processor with its own local memory, reducing memory access time.",
                "B. NUMA allows all processors to access the same memory location simultaneously.",
                "C. NUMA is easier to implement than UMA.",
                "D. NUMA provides limited memory capacity."
            ],
            "answer": "A. NUMA provides each processor with its own local memory, reducing memory access time.",
            "explanation": "In a NUMA system, memory is physically distributed. A processor can access its own local memory faster than it can access non-local memory (memory local to another processor or memory on another interconnect). This can improve performance in large multi-processor systems."
        },
        "vi": {
            "question": "M·ªôt ∆∞u ƒëi·ªÉm c·ªßa Truy c·∫≠p b·ªô nh·ªõ kh√¥ng ƒë·ªìng nh·∫•t (NUMA) so v·ªõi Truy c·∫≠p b·ªô nh·ªõ ƒë·ªìng nh·∫•t (UMA) l√† g√¨?",
            "options": [
                "A. NUMA cung c·∫•p cho m·ªói b·ªô x·ª≠ l√Ω b·ªô nh·ªõ c·ª•c b·ªô ri√™ng, gi·∫£m th·ªùi gian truy c·∫≠p b·ªô nh·ªõ.",
                "B. NUMA cho ph√©p t·∫•t c·∫£ c√°c b·ªô x·ª≠ l√Ω truy c·∫≠p c√πng m·ªôt v·ªã tr√≠ b·ªô nh·ªõ ƒë·ªìng th·ªùi.",
                "C. NUMA d·ªÖ th·ª±c hi·ªán h∆°n UMA.",
                "D. NUMA cung c·∫•p dung l∆∞·ª£ng b·ªô nh·ªõ h·∫°n ch·∫ø."
            ],
            "answer": "A. NUMA cung c·∫•p cho m·ªói b·ªô x·ª≠ l√Ω b·ªô nh·ªõ c·ª•c b·ªô ri√™ng, gi·∫£m th·ªùi gian truy c·∫≠p b·ªô nh·ªõ.",
            "explanation": "Trong m·ªôt h·ªá th·ªëng NUMA, b·ªô nh·ªõ ƒë∆∞·ª£c ph√¢n ph·ªëi v·ªÅ m·∫∑t v·∫≠t l√Ω. M·ªôt b·ªô x·ª≠ l√Ω c√≥ th·ªÉ truy c·∫≠p b·ªô nh·ªõ c·ª•c b·ªô c·ªßa ri√™ng n√≥ nhanh h∆°n so v·ªõi truy c·∫≠p b·ªô nh·ªõ kh√¥ng c·ª•c b·ªô (b·ªô nh·ªõ c·ª•c b·ªô c·ªßa m·ªôt b·ªô x·ª≠ l√Ω kh√°c ho·∫∑c b·ªô nh·ªõ tr√™n m·ªôt k·∫øt n·ªëi kh√°c). ƒêi·ªÅu n√†y c√≥ th·ªÉ c·∫£i thi·ªán hi·ªáu su·∫•t trong c√°c h·ªá th·ªëng ƒëa x·ª≠ l√Ω l·ªõn."
        }
    },
    {
        "id": 284,
        "en": {
            "question": "How does multithreading improve the performance of a processor?",
            "options": [
                "A. It increases instruction-level parallelism by issuing multiple instructions from different threads in the same cycle.",
                "B. It increases thread-level parallelism by executing multiple threads on different cores or processors.",
                "C. It increases the utilization of processor resources by hiding the latency of long-latency events such as cache misses or branch mispredictions.",
                "D. All of the above."
            ],
            "answer": "D. All of the above.",
            "explanation": "Multithreading techniques like SMT (Simultaneous Multithreading) can issue instructions from multiple threads to different execution units (A), while multicore systems execute threads on different cores (B). A key benefit of both is that when one thread stalls (e.g., on a cache miss), the processor can switch to another thread, keeping its execution units busy (C)."
        },
        "vi": {
            "question": "ƒêa lu·ªìng (multithreading) c·∫£i thi·ªán hi·ªáu su·∫•t c·ªßa m·ªôt b·ªô x·ª≠ l√Ω nh∆∞ th·∫ø n√†o?",
            "options": [
                "A. N√≥ l√†m tƒÉng t√≠nh song song ·ªü c·∫•p ƒë·ªô l·ªánh b·∫±ng c√°ch ph√°t h√†nh nhi·ªÅu l·ªánh t·ª´ c√°c lu·ªìng kh√°c nhau trong c√πng m·ªôt chu k·ª≥.",
                "B. N√≥ l√†m tƒÉng t√≠nh song song ·ªü c·∫•p ƒë·ªô lu·ªìng b·∫±ng c√°ch th·ª±c thi nhi·ªÅu lu·ªìng tr√™n c√°c l√µi ho·∫∑c b·ªô x·ª≠ l√Ω kh√°c nhau.",
                "C. N√≥ l√†m tƒÉng vi·ªác s·ª≠ d·ª•ng t√†i nguy√™n c·ªßa b·ªô x·ª≠ l√Ω b·∫±ng c√°ch che gi·∫•u ƒë·ªô tr·ªÖ c·ªßa c√°c s·ª± ki·ªán c√≥ ƒë·ªô tr·ªÖ d√†i nh∆∞ cache miss ho·∫∑c d·ª± ƒëo√°n sai nh√°nh.",
                "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n."
            ],
            "answer": "D. T·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n.",
            "explanation": "C√°c k·ªπ thu·∫≠t ƒëa lu·ªìng nh∆∞ SMT (ƒêa lu·ªìng ƒë·ªìng th·ªùi) c√≥ th·ªÉ ph√°t h√†nh c√°c l·ªánh t·ª´ nhi·ªÅu lu·ªìng ƒë·∫øn c√°c ƒë∆°n v·ªã th·ª±c thi kh√°c nhau (A), trong khi c√°c h·ªá th·ªëng ƒëa l√µi th·ª±c thi c√°c lu·ªìng tr√™n c√°c l√µi kh√°c nhau (B). M·ªôt l·ª£i √≠ch ch√≠nh c·ªßa c·∫£ hai l√† khi m·ªôt lu·ªìng b·ªã ƒë√¨nh tr·ªá (v√≠ d·ª•, do cache miss), b·ªô x·ª≠ l√Ω c√≥ th·ªÉ chuy·ªÉn sang m·ªôt lu·ªìng kh√°c, gi·ªØ cho c√°c ƒë∆°n v·ªã th·ª±c thi c·ªßa n√≥ b·∫≠n r·ªôn (C)."
        }
    },
    {
        "id": 285,
        "en": {
            "question": "'Multiple processors share a single memory or a pool of memory by a shared bus or other interconnection mechanism; a distinguishing feature is that the memory access time to any region of memory is approximately the same for each processor.' Which concept belongs to that statement?",
            "options": [
                "A. Symmetric multiprocessing (SMP)",
                "B. Non-uniform memory access (NUMA)",
                "C. Cluster",
                "D. Single instruction, multiple data (SIMD)"
            ],
            "answer": "A. Symmetric multiprocessing (SMP)",
            "explanation": "This describes a UMA (Uniform Memory Access) architecture, which is the defining characteristic of an SMP system. All processors have equal access and access times to the shared main memory."
        },
        "vi": {
            "question": "\"Nhi·ªÅu b·ªô x·ª≠ l√Ω chia s·∫ª m·ªôt b·ªô nh·ªõ duy nh·∫•t ho·∫∑c m·ªôt nh√≥m b·ªô nh·ªõ b·∫±ng m·ªôt bus chia s·∫ª ho·∫∑c c∆° ch·∫ø k·∫øt n·ªëi kh√°c; m·ªôt ƒë·∫∑c ƒëi·ªÉm ph√¢n bi·ªát l√† th·ªùi gian truy c·∫≠p b·ªô nh·ªõ ƒë·∫øn b·∫•t k·ª≥ v√πng n√†o c·ªßa b·ªô nh·ªõ l√† g·∫ßn nh∆∞ gi·ªëng nhau cho m·ªói b·ªô x·ª≠ l√Ω.\" Kh√°i ni·ªám n√†o thu·ªôc v·ªÅ c√¢u l·ªánh ƒë√≥?",
            "options": [
                "A. ƒêa x·ª≠ l√Ω ƒë·ªëi x·ª©ng (SMP)",
                "B. Truy c·∫≠p b·ªô nh·ªõ kh√¥ng ƒë·ªìng nh·∫•t (NUMA)",
                "C. C·ª•m (Cluster)",
                "D. L·ªánh ƒë∆°n, nhi·ªÅu d·ªØ li·ªáu (SIMD)"
            ],
            "answer": "A. ƒêa x·ª≠ l√Ω ƒë·ªëi x·ª©ng (SMP)",
            "explanation": "ƒêi·ªÅu n√†y m√¥ t·∫£ m·ªôt ki·∫øn tr√∫c UMA (Truy c·∫≠p b·ªô nh·ªõ ƒë·ªìng nh·∫•t), ƒë√≥ l√† ƒë·∫∑c ƒëi·ªÉm x√°c ƒë·ªãnh c·ªßa m·ªôt h·ªá th·ªëng SMP. T·∫•t c·∫£ c√°c b·ªô x·ª≠ l√Ω c√≥ quy·ªÅn truy c·∫≠p v√† th·ªùi gian truy c·∫≠p nh∆∞ nhau v√†o b·ªô nh·ªõ ch√≠nh ƒë∆∞·ª£c chia s·∫ª."
        }
    },
    // C√°c c√¢u h·ªèi c√≤n l·∫°i... (ph√¢n lo·∫°i t∆∞∆°ng t·ª±)
    {
        "id": 286,
        "en": {
            "question": "What is a characteristic of Many Integrated Core (MIC) chips?",
            "options": [
                "A. They consist only of specialized cores for specific tasks.",
                "B. They consist of homogeneous general-purpose processors on a single chip.",
                "C. They are designed to eliminate the need for GPUs in high-performance applications.",
                "D. They have limited scalability beyond four cores per chip."
            ],
            "answer": "B. They consist of homogeneous general-purpose processors on a single chip.",
            "explanation": "MIC architectures, like Intel's Xeon Phi, feature a large number of simpler, general-purpose cores on a single chip, designed for highly parallel workloads."
        },
        "vi": {
            "question": "ƒê·∫∑c ƒëi·ªÉm c·ªßa chip Many Integrated Core (MIC) l√† g√¨?",
            "options": [
                "A. Ch√∫ng ch·ªâ bao g·ªìm c√°c l√µi chuy√™n d·ª•ng cho c√°c t√°c v·ª• c·ª• th·ªÉ.",
                "B. Ch√∫ng bao g·ªìm c√°c b·ªô x·ª≠ l√Ω ƒëa nƒÉng ƒë·ªìng nh·∫•t tr√™n m·ªôt chip duy nh·∫•t.",
                "C. Ch√∫ng ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ lo·∫°i b·ªè nhu c·∫ßu v·ªÅ GPU trong c√°c ·ª©ng d·ª•ng hi·ªáu su·∫•t cao.",
                "D. Ch√∫ng c√≥ kh·∫£ nƒÉng m·ªü r·ªông h·∫°n ch·∫ø ngo√†i b·ªën l√µi m·ªói chip."
            ],
            "answer": "B. Ch√∫ng bao g·ªìm c√°c b·ªô x·ª≠ l√Ω ƒëa nƒÉng ƒë·ªìng nh·∫•t tr√™n m·ªôt chip duy nh·∫•t.",
            "explanation": "C√°c ki·∫øn tr√∫c MIC, nh∆∞ Xeon Phi c·ªßa Intel, c√≥ m·ªôt s·ªë l∆∞·ª£ng l·ªõn c√°c l√µi ƒëa nƒÉng ƒë∆°n gi·∫£n h∆°n tr√™n m·ªôt con chip duy nh·∫•t, ƒë∆∞·ª£c thi·∫øt k·∫ø cho c√°c kh·ªëi l∆∞·ª£ng c√¥ng vi·ªác song song cao."
        }
    },
    {
        "id": 287,
        "en": {
            "question": "Which architectural concept involves replicating banks of registers to facilitate sharing of pipeline resources among multiple threads?",
            "options": [
                "A. Pipelining",
                "B. Superscalar",
                "C. Simultaneous multithreading",
                "D. Superpipelining"
            ],
            "answer": "C. Simultaneous multithreading",
            "explanation": "SMT (like Intel's Hyper-Threading) adds a small amount of hardware to a superscalar core to support multiple logical processors (threads). This includes replicating the architectural register state for each thread so the core can issue instructions from multiple threads simultaneously."
        },
        "vi": {
            "question": "Kh√°i ni·ªám ki·∫øn tr√∫c n√†o li√™n quan ƒë·∫øn vi·ªác sao ch√©p c√°c d·∫£i thanh ghi ƒë·ªÉ t·∫°o ƒëi·ªÅu ki·ªán chia s·∫ª t√†i nguy√™n ƒë∆∞·ªùng ·ªëng gi·ªØa nhi·ªÅu lu·ªìng?",
            "options": [
                "A. T·∫°o ƒë∆∞·ªùng ·ªëng (Pipelining)",
                "B. Si√™u v√¥ h∆∞·ªõng (Superscalar)",
                "C. ƒêa lu·ªìng ƒë·ªìng th·ªùi (Simultaneous multithreading)",
                "D. Si√™u ƒë∆∞·ªùng ·ªëng (Superpipelining)"
            ],
            "answer": "C. ƒêa lu·ªìng ƒë·ªìng th·ªùi (Simultaneous multithreading)",
            "explanation": "SMT (nh∆∞ Hyper-Threading c·ªßa Intel) th√™m m·ªôt l∆∞·ª£ng nh·ªè ph·∫ßn c·ª©ng v√†o m·ªôt l√µi si√™u v√¥ h∆∞·ªõng ƒë·ªÉ h·ªó tr·ª£ nhi·ªÅu b·ªô x·ª≠ l√Ω logic (lu·ªìng). ƒêi·ªÅu n√†y bao g·ªìm vi·ªác sao ch√©p tr·∫°ng th√°i thanh ghi ki·∫øn tr√∫c cho m·ªói lu·ªìng ƒë·ªÉ l√µi c√≥ th·ªÉ ph√°t h√†nh c√°c l·ªánh t·ª´ nhi·ªÅu lu·ªìng ƒë·ªìng th·ªùi."
        }
    },
    // C√¢u h·ªèi t·ª´ ng√¢n h√†ng b·ªï sung
    {
        "id": 288,
        "en": {
            "question": "Registers and ALU are connected using ____.",
            "options": [
                "A. Information path",
                "B. Control path",
                "C. Process route",
                "D. Data path"
            ],
            "answer": "D. Data path",
            "explanation": "The datapath consists of the functional units of the processor, such as registers, the ALU, and the internal buses that connect them."
        },
        "vi": {
            "question": "C√°c thanh ghi v√† ALU ƒë∆∞·ª£c k·∫øt n·ªëi b·∫±ng c√°ch s·ª≠ d·ª•ng ____.",
            "options": [
                "A. ƒê∆∞·ªùng d·∫´n th√¥ng tin (Information path)",
                "B. ƒê∆∞·ªùng d·∫´n ƒëi·ªÅu khi·ªÉn (Control path)",
                "C. Tuy·∫øn x·ª≠ l√Ω (Process route)",
                "D. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu (Data path)"
            ],
            "answer": "D. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu (Data path)",
            "explanation": "ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu bao g·ªìm c√°c ƒë∆°n v·ªã ch·ª©c nƒÉng c·ªßa b·ªô x·ª≠ l√Ω, ch·∫≥ng h·∫°n nh∆∞ c√°c thanh ghi, ALU, v√† c√°c bus n·ªôi b·ªô k·∫øt n·ªëi ch√∫ng."
        }
    },
    {
        "id": 289,
        "en": {
            "question": "____ are numbers and encoded characters, which are generally used as operands.",
            "options": [
                "A. Stored values",
                "B. Information",
                "C. Output",
                "D. Data"
            ],
            "answer": "D. Data",
            "explanation": "Data is the raw material that computer programs manipulate. It can be numbers, characters, or other encoded values."
        },
        "vi": {
            "question": "____ l√† c√°c con s·ªë v√† c√°c k√Ω t·ª± ƒë∆∞·ª£c m√£ h√≥a, th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng l√†m to√°n h·∫°ng.",
            "options": [
                "A. Gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ (Stored values)",
                "B. Th√¥ng tin (Information)",
                "C. ƒê·∫ßu ra (Output)",
                "D. D·ªØ li·ªáu (Data)"
            ],
            "answer": "D. D·ªØ li·ªáu (Data)",
            "explanation": "D·ªØ li·ªáu l√† nguy√™n li·ªáu th√¥ m√† c√°c ch∆∞∆°ng tr√¨nh m√°y t√≠nh thao t√°c. N√≥ c√≥ th·ªÉ l√† c√°c con s·ªë, k√Ω t·ª±, ho·∫∑c c√°c gi√° tr·ªã ƒë∆∞·ª£c m√£ h√≥a kh√°c."
        }
    },
    {
        "id": 290,
        "en": {
            "question": "Input devices can send information to the processor when ____.",
            "options": [
                "A. The SIN status flag is set.",
                "B. None of the mentioned.",
                "C. All of them.",
                "D. As the data arrives regardless of the SIN flag."
            ],
            "answer": "A. The SIN status flag is set.",
            "explanation": "In a simple polled I/O system, a status flag like SIN (Status In) is used by the device to signal to the processor that it has new data ready to be read."
        },
        "vi": {
            "question": "C√°c thi·∫øt b·ªã ƒë·∫ßu v√†o c√≥ th·ªÉ g·ª≠i th√¥ng tin ƒë·∫øn b·ªô x·ª≠ l√Ω khi ____.",
            "options": [
                "A. C·ªù tr·∫°ng th√°i SIN ƒë∆∞·ª£c thi·∫øt l·∫≠p.",
                "B. Kh√¥ng c√≥ c√°i n√†o.",
                "C. T·∫•t c·∫£ ch√∫ng.",
                "D. Khi d·ªØ li·ªáu ƒë·∫øn b·∫•t k·ªÉ c·ªù SIN."
            ],
            "answer": "A. C·ªù tr·∫°ng th√°i SIN ƒë∆∞·ª£c thi·∫øt l·∫≠p.",
            "explanation": "Trong m·ªôt h·ªá th·ªëng I/O thƒÉm d√≤ ƒë∆°n gi·∫£n, m·ªôt c·ªù tr·∫°ng th√°i nh∆∞ SIN (Status In) ƒë∆∞·ª£c thi·∫øt b·ªã s·ª≠ d·ª•ng ƒë·ªÉ b√°o hi·ªáu cho b·ªô x·ª≠ l√Ω r·∫±ng n√≥ c√≥ d·ªØ li·ªáu m·ªõi s·∫µn s√†ng ƒë·ªÉ ƒë∆∞·ª£c ƒë·ªçc."
        }
    },
    {
        "id": 291,
        "en": {
            "question": "Which register of the processor is connected to the Memory Bus?",
            "options": [
                "A. IR",
                "B. Both PC and MAR",
                "C. MAR",
                "D. PC"
            ],
            "answer": "C. MAR",
            "explanation": "The Memory Address Register (MAR) is directly connected to the address lines of the system bus to specify the memory location for a read or write operation."
        },
        "vi": {
            "question": "Thanh ghi n√†o c·ªßa b·ªô x·ª≠ l√Ω ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi Bus b·ªô nh·ªõ?",
            "options": [
                "A. IR",
                "B. C·∫£ PC v√† MAR",
                "C. MAR",
                "D. PC"
            ],
            "answer": "C. MAR",
            "explanation": "Thanh ghi ƒë·ªãa ch·ªâ b·ªô nh·ªõ (MAR) ƒë∆∞·ª£c k·∫øt n·ªëi tr·ª±c ti·∫øp v·ªõi c√°c ƒë∆∞·ªùng ƒë·ªãa ch·ªâ c·ªßa bus h·ªá th·ªëng ƒë·ªÉ ch·ªâ ƒë·ªãnh v·ªã tr√≠ b·ªô nh·ªõ cho m·ªôt ho·∫°t ƒë·ªông ƒë·ªçc ho·∫∑c ghi."
        }
    },
    {
        "id": 292,
        "en": {
            "question": "ISP stands for ____.",
            "options": [
                "A. Information Standard Processing",
                "B. Interchange Standard Protocol",
                "C. Interrupt Service Procedure",
                "D. Instruction Set Processor"
            ],
            "answer": "C. Interrupt Service Procedure",
            "explanation": "ISP, more commonly known as ISR (Interrupt Service Routine), is the procedure or routine that the processor executes in response to an interrupt."
        },
        "vi": {
            "question": "ISP l√† vi·∫øt t·∫Øt c·ªßa ____.",
            "options": [
                "A. Information Standard Processing",
                "B. Interchange Standard Protocol",
                "C. Interrupt Service Procedure (Th·ªß t·ª•c ph·ª•c v·ª• ng·∫Øt)",
                "D. Instruction Set Processor"
            ],
            "answer": "C. Interrupt Service Procedure (Th·ªß t·ª•c ph·ª•c v·ª• ng·∫Øt)",
            "explanation": "ISP, th∆∞·ªùng ƒë∆∞·ª£c bi·∫øt ƒë·∫øn nhi·ªÅu h∆°n v·ªõi t√™n ISR (Interrupt Service Routine), l√† th·ªß t·ª•c ho·∫∑c quy tr√¨nh m√† b·ªô x·ª≠ l√Ω th·ª±c thi ƒë·ªÉ ƒë√°p ·ª©ng m·ªôt ng·∫Øt."
        }
    },
    {
        "id": 293,
        "en": {
            "question": "____ are used to choose between incrementing the PC or performing ALU operations.",
            "options": [
                "A. Control unit",
                "B. Multiplexer",
                "C. None of the mentioned.",
                "D. Conditional codes"
            ],
            "answer": "B. Multiplexer",
            "explanation": "A multiplexer (MUX) is a digital switch. The control unit would send a signal to a MUX to select which input (e.g., the output of an incrementer for the PC, or the output of the ALU) should be routed to a specific destination."
        },
        "vi": {
            "question": "____ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ l·ª±a ch·ªçn gi·ªØa vi·ªác tƒÉng PC ho·∫∑c th·ª±c hi·ªán c√°c ho·∫°t ƒë·ªông ALU.",
            "options": [
                "A. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn (Control unit)",
                "B. B·ªô ƒëa h·ª£p (Multiplexer)",
                "C. Kh√¥ng c√≥ c√°i n√†o.",
                "D. M√£ ƒëi·ªÅu ki·ªán (Conditional codes)"
            ],
            "answer": "B. B·ªô ƒëa h·ª£p (Multiplexer)",
            "explanation": "M·ªôt b·ªô ƒëa h·ª£p (MUX) l√† m·ªôt c√¥ng t·∫Øc k·ªπ thu·∫≠t s·ªë. ƒê∆°n v·ªã ƒëi·ªÅu khi·ªÉn s·∫Ω g·ª≠i m·ªôt t√≠n hi·ªáu ƒë·∫øn m·ªôt MUX ƒë·ªÉ ch·ªçn ƒë·∫ßu v√†o n√†o (v√≠ d·ª•: ƒë·∫ßu ra c·ªßa m·ªôt b·ªô tƒÉng cho PC, ho·∫∑c ƒë·∫ßu ra c·ªßa ALU) n√™n ƒë∆∞·ª£c ƒë·ªãnh tuy·∫øn ƒë·∫øn m·ªôt ƒë√≠ch c·ª• th·ªÉ."
        }
    },
    {
        "id": 294,
        "en": {
            "question": "The registers, ALU, and the interconnecting between them are collectively called the ____.",
            "options": [
                "A. information trail",
                "B. data",
                "C. datapath",
                "D. process route"
            ],
            "answer": "C. datapath",
            "explanation": "This is a repeat of a previous question. The datapath includes the ALU, registers, and internal buses."
        },
        "vi": {
            "question": "C√°c thanh ghi, ALU v√† s·ª± k·∫øt n·ªëi gi·ªØa ch√∫ng ƒë∆∞·ª£c g·ªçi chung l√† ____.",
            "options": [
                "A. D·∫•u v·∫øt th√¥ng tin (information trail)",
                "B. D·ªØ li·ªáu (data)",
                "C. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu (datapath)",
                "D. Tuy·∫øn x·ª≠ l√Ω (process route)"
            ],
            "answer": "C. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu (datapath)",
            "explanation": "ƒê√¢y l√† c√¢u h·ªèi l·∫∑p l·∫°i. ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu bao g·ªìm ALU, c√°c thanh ghi, v√† c√°c bus n·ªôi b·ªô."
        }
    },
    {
        "id": 295,
        "en": {
            "question": "____ is not one of the four basic functions of a computer.",
            "options": [
                "A. Data movement",
                "B. Data storage",
                "C. I/O processing",
                "D. Data processing"
            ],
            "answer": "C. I/O processing",
            "explanation": "The four functions are Data Processing, Data Storage, Data Movement, and Control. I/O processing is a specific type of data movement and control."
        },
        "vi": {
            "question": "____ kh√¥ng ph·∫£i l√† m·ªôt trong b·ªën ch·ª©c nƒÉng c∆° b·∫£n c·ªßa m√°y t√≠nh.",
            "options": [
                "A. Di chuy·ªÉn d·ªØ li·ªáu (Data movement)",
                "B. L∆∞u tr·ªØ d·ªØ li·ªáu (Data storage)",
                "C. X·ª≠ l√Ω I/O (I/O processing)",
                "D. X·ª≠ l√Ω d·ªØ li·ªáu (Data processing)"
            ],
            "answer": "C. X·ª≠ l√Ω I/O (I/O processing)",
            "explanation": "B·ªën ch·ª©c nƒÉng l√† X·ª≠ l√Ω d·ªØ li·ªáu, L∆∞u tr·ªØ d·ªØ li·ªáu, Di chuy·ªÉn d·ªØ li·ªáu v√† ƒêi·ªÅu khi·ªÉn. X·ª≠ l√Ω I/O l√† m·ªôt lo·∫°i c·ª• th·ªÉ c·ªßa di chuy·ªÉn d·ªØ li·ªáu v√† ƒëi·ªÅu khi·ªÉn."
        }
    },
    {
        "id": 296,
        "en": {
            "question": "CPU stores its computations in ____.",
            "options": [
                "A. External Data Bus",
                "B. Binary",
                "C. Registers",
                "D. Processor"
            ],
            "answer": "C. Registers",
            "explanation": "Registers are the fastest form of memory, located directly within the CPU, used to hold data, instructions, and intermediate results of computations."
        },
        "vi": {
            "question": "CPU l∆∞u tr·ªØ c√°c t√≠nh to√°n c·ªßa n√≥ ·ªü ƒë√¢u?",
            "options": [
                "A. Bus d·ªØ li·ªáu ngo√†i (External Data Bus)",
                "B. Nh·ªã ph√¢n (Binary)",
                "C. Thanh ghi (Registers)",
                "D. B·ªô x·ª≠ l√Ω (Processor)"
            ],
            "answer": "C. Thanh ghi (Registers)",
            "explanation": "C√°c thanh ghi l√† d·∫°ng b·ªô nh·ªõ nhanh nh·∫•t, n·∫±m tr·ª±c ti·∫øp b√™n trong CPU, ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ gi·ªØ d·ªØ li·ªáu, l·ªánh v√† c√°c k·∫øt qu·∫£ t√≠nh to√°n trung gian."
        }
    },
    {
        "id": 297,
        "en": {
            "question": "Which memory device is usually made of semiconductors?",
            "options": [
                "A. DVD",
                "B. CDROM",
                "C. Floppy disk",
                "D. RAM"
            ],
            "answer": "D. RAM",
            "explanation": "RAM (Random Access Memory), both SRAM and DRAM, is a type of semiconductor memory, built from transistors on an integrated circuit."
        },
        "vi": {
            "question": "Thi·∫øt b·ªã b·ªô nh·ªõ n√†o th∆∞·ªùng ƒë∆∞·ª£c l√†m b·∫±ng ch·∫•t b√°n d·∫´n?",
            "options": [
                "A. DVD",
                "B. CDROM",
                "C. ƒêƒ©a m·ªÅm (Floppy disk)",
                "D. RAM"
            ],
            "answer": "D. RAM",
            "explanation": "RAM (B·ªô nh·ªõ truy c·∫≠p ng·∫´u nhi√™n), c·∫£ SRAM v√† DRAM, l√† m·ªôt lo·∫°i b·ªô nh·ªõ b√°n d·∫´n, ƒë∆∞·ª£c x√¢y d·ª±ng t·ª´ c√°c b√≥ng b√°n d·∫´n tr√™n m·ªôt m·∫°ch t√≠ch h·ª£p."
        }
    },
    {
        "id": 298,
        "en": {
            "question": "A control bus with 8 wires can define ____ operations.",
            "options": [
                "A. 512",
                "B. 16",
                "C. 8",
                "D. 256"
            ],
            "answer": "D. 256",
            "explanation": "With n wires (bits), you can represent 2^n unique combinations. So, 8 wires can define 2^8 = 256 different operations or signals."
        },
        "vi": {
            "question": "M·ªôt bus ƒëi·ªÅu khi·ªÉn v·ªõi 8 d√¢y c√≥ th·ªÉ x√°c ƒë·ªãnh ____ ho·∫°t ƒë·ªông.",
            "options": [
                "A. 512",
                "B. 16",
                "C. 8",
                "D. 256"
            ],
            "answer": "D. 256",
            "explanation": "V·ªõi n d√¢y (bit), b·∫°n c√≥ th·ªÉ bi·ªÉu di·ªÖn 2^n t·ªï h·ª£p duy nh·∫•t. V√¨ v·∫≠y, 8 d√¢y c√≥ th·ªÉ x√°c ƒë·ªãnh 2^8 = 256 ho·∫°t ƒë·ªông ho·∫∑c t√≠n hi·ªáu kh√°c nhau."
        }
    },
    {
        "id": 299,
        "en": {
            "question": "A control unit with 5 wires can define up to ____ operations.",
            "options": [
                "A. 16",
                "B. 10",
                "C. 32",
                "D. 5"
            ],
            "answer": "C. 32",
            "explanation": "With n wires (bits), you can represent 2^n unique combinations. So, 5 wires can define 2^5 = 32 different operations or signals."
        },
        "vi": {
            "question": "M·ªôt ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn v·ªõi 5 d√¢y c√≥ th·ªÉ x√°c ƒë·ªãnh l√™n ƒë·∫øn ____ ho·∫°t ƒë·ªông.",
            "options": [
                "A. 16",
                "B. 10",
                "C. 32",
                "D. 5"
            ],
            "answer": "C. 32",
            "explanation": "V·ªõi n d√¢y (bit), b·∫°n c√≥ th·ªÉ bi·ªÉu di·ªÖn 2^n t·ªï h·ª£p duy nh·∫•t. V√¨ v·∫≠y, 5 d√¢y c√≥ th·ªÉ x√°c ƒë·ªãnh 2^5 = 32 ho·∫°t ƒë·ªông ho·∫∑c t√≠n hi·ªáu kh√°c nhau."
        }
    },
    {
        "id": 300,
        "en": {
            "question": "A program becomes a ____ when it is selected by the operating system and brought into the hold state.",
            "options": [
                "A. deadlock",
                "B. partition",
                "C. process",
                "D. job"
            ],
            "answer": "C. process",
            "explanation": "A process is a program in execution. The transition from a static program on disk (a job) to an active entity managed by the OS marks its creation as a process."
        },
        "vi": {
            "question": "M·ªôt ch∆∞∆°ng tr√¨nh tr·ªü th√†nh m·ªôt ____ khi n√≥ ƒë∆∞·ª£c ch·ªçn b·ªüi h·ªá ƒëi·ªÅu h√†nh v√† ƒë∆∞a v√†o tr·∫°ng th√°i gi·ªØ (hold state).",
            "options": [
                "A. deadlock",
                "B. partition",
                "C. process",
                "D. job"
            ],
            "answer": "C. process",
            "explanation": "M·ªôt ti·∫øn tr√¨nh l√† m·ªôt ch∆∞∆°ng tr√¨nh ƒëang th·ª±c thi. S·ª± chuy·ªÉn ƒë·ªïi t·ª´ m·ªôt ch∆∞∆°ng tr√¨nh tƒ©nh tr√™n ƒëƒ©a (m·ªôt c√¥ng vi·ªác) sang m·ªôt th·ª±c th·ªÉ ho·∫°t ƒë·ªông ƒë∆∞·ª£c qu·∫£n l√Ω b·ªüi HƒêH ƒë√°nh d·∫•u s·ª± t·∫°o ra c·ªßa n√≥ nh∆∞ m·ªôt ti·∫øn tr√¨nh."
        }
    },
    {
        "id": 301,
        "en": {
            "question": "A register in the CPU can hold ____.",
            "options": [
                "A. only data",
                "B. only program counter values",
                "C. only instructions",
                "D. data, instruction, or program counter values"
            ],
            "answer": "D. data, instruction, or program counter values",
            "explanation": "Different registers have different purposes. Data registers hold data, the instruction register (IR) holds instructions, and the program counter (PC) holds an address (which is a form of data)."
        },
        "vi": {
            "question": "M·ªôt thanh ghi trong CPU c√≥ th·ªÉ ch·ª©a ____.",
            "options": [
                "A. ch·ªâ d·ªØ li·ªáu (only data)",
                "B. ch·ªâ gi√° tr·ªã b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (only program counter values)",
                "C. ch·ªâ l·ªánh (only instructions)",
                "D. d·ªØ li·ªáu, l·ªánh, ho·∫∑c gi√° tr·ªã b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (data, instruction, or program counter values)"
            ],
            "answer": "D. d·ªØ li·ªáu, l·ªánh, ho·∫∑c gi√° tr·ªã b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (data, instruction, or program counter values)",
            "explanation": "C√°c thanh ghi kh√°c nhau c√≥ c√°c m·ª•c ƒë√≠ch kh√°c nhau. Thanh ghi d·ªØ li·ªáu gi·ªØ d·ªØ li·ªáu, thanh ghi l·ªánh (IR) gi·ªØ l·ªánh, v√† b·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh (PC) gi·ªØ m·ªôt ƒë·ªãa ch·ªâ (l√† m·ªôt d·∫°ng d·ªØ li·ªáu)."
        }
    },
    {
        "id": 302,
        "en": {
            "question": "A Turing machine has the following components: ____.",
            "options": [
                "A. disk, memory, and controller",
                "B. tape, memory, and head",
                "C. disk, controller, and head",
                "D. tape, controller, and head"
            ],
            "answer": "D. tape, controller, and head",
            "explanation": "A Turing machine is a theoretical model of computation consisting of an infinitely long tape divided into cells, a read/write head that can move along the tape, and a control unit that dictates actions based on its current state and the symbol read."
        },
        "vi": {
            "question": "M·ªôt m√°y Turing c√≥ c√°c th√†nh ph·∫ßn sau: ____.",
            "options": [
                "A. ƒëƒ©a, b·ªô nh·ªõ, v√† b·ªô ƒëi·ªÅu khi·ªÉn",
                "B. bƒÉng, b·ªô nh·ªõ, v√† ƒë·∫ßu ƒë·ªçc/ghi",
                "C. ƒëƒ©a, b·ªô ƒëi·ªÅu khi·ªÉn, v√† ƒë·∫ßu ƒë·ªçc/ghi",
                "D. bƒÉng, b·ªô ƒëi·ªÅu khi·ªÉn, v√† ƒë·∫ßu ƒë·ªçc/ghi"
            ],
            "answer": "D. bƒÉng, b·ªô ƒëi·ªÅu khi·ªÉn, v√† ƒë·∫ßu ƒë·ªçc/ghi",
            "explanation": "M·ªôt m√°y Turing l√† m·ªôt m√¥ h√¨nh t√≠nh to√°n l√Ω thuy·∫øt bao g·ªìm m·ªôt cu·ªôn bƒÉng d√†i v√¥ h·∫°n ƒë∆∞·ª£c chia th√†nh c√°c √¥, m·ªôt ƒë·∫ßu ƒë·ªçc/ghi c√≥ th·ªÉ di chuy·ªÉn d·ªçc theo bƒÉng, v√† m·ªôt ƒë∆°n v·ªã ƒëi·ªÅu khi·ªÉn ch·ªâ ƒë·∫°o c√°c h√†nh ƒë·ªông d·ª±a tr√™n tr·∫°ng th√°i hi·ªán t·∫°i c·ªßa n√≥ v√† k√Ω hi·ªáu ƒë√£ ƒë·ªçc."
        }
    },
    {
        "id": 303,
        "en": {
            "question": "A word can be ____ bits.",
            "options": [
                "A. 8, or 16, or 32",
                "B. only 16",
                "C. only 8",
                "D. only 32"
            ],
            "answer": "A. 8, or 16, or 32",
            "explanation": "The size of a 'word' is architecture-dependent. It refers to the natural unit of data used by a particular processor design. It could be 8 bits (on very old microcontrollers), 16, 32, or 64 bits (common today)."
        },
        "vi": {
            "question": "M·ªôt t·ª´ (word) c√≥ th·ªÉ l√† ____ bit.",
            "options": [
                "A. 8, ho·∫∑c 16, ho·∫∑c 32",
                "B. ch·ªâ 16",
                "C. ch·ªâ 8",
                "D. ch·ªâ 32"
            ],
            "answer": "A. 8, ho·∫∑c 16, ho·∫∑c 32",
            "explanation": "K√≠ch th∆∞·ªõc c·ªßa m·ªôt 't·ª´' ph·ª• thu·ªôc v√†o ki·∫øn tr√∫c. N√≥ ƒë·ªÅ c·∫≠p ƒë·∫øn ƒë∆°n v·ªã d·ªØ li·ªáu t·ª± nhi√™n ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi m·ªôt thi·∫øt k·∫ø b·ªô x·ª≠ l√Ω c·ª• th·ªÉ. N√≥ c√≥ th·ªÉ l√† 8 bit (tr√™n c√°c b·ªô vi ƒëi·ªÅu khi·ªÉn r·∫•t c≈©), 16, 32, ho·∫∑c 64 bit (ph·ªï bi·∫øn ng√†y nay)."
        }
    },
    {
        "id": 304,
        "en": {
            "question": "According to the von Neumann model, ____ is/are stored in memory.",
            "options": [
                "A. data and program",
                "B. neither data nor program",
                "C. only program",
                "D. only data"
            ],
            "answer": "A. data and program",
            "explanation": "The key concept of the von Neumann architecture is the stored-program computer, where both the instructions (the program) and the data it operates on reside in the same main memory."
        },
        "vi": {
            "question": "Theo m√¥ h√¨nh von Neumann, ____ ƒë∆∞·ª£c l∆∞u tr·ªØ trong b·ªô nh·ªõ.",
            "options": [
                "A. d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh",
                "B. kh√¥ng ph·∫£i d·ªØ li·ªáu c≈©ng kh√¥ng ph·∫£i ch∆∞∆°ng tr√¨nh",
                "C. ch·ªâ ch∆∞∆°ng tr√¨nh",
                "D. ch·ªâ d·ªØ li·ªáu"
            ],
            "answer": "A. d·ªØ li·ªáu v√† ch∆∞∆°ng tr√¨nh",
            "explanation": "Kh√°i ni·ªám ch√≠nh c·ªßa ki·∫øn tr√∫c von Neumann l√† m√°y t√≠nh ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c l∆∞u tr·ªØ, n∆°i c·∫£ c√°c l·ªánh (ch∆∞∆°ng tr√¨nh) v√† d·ªØ li·ªáu m√† n√≥ ho·∫°t ƒë·ªông tr√™n ƒë·ªÅu n·∫±m trong c√πng m·ªôt b·ªô nh·ªõ ch√≠nh."
        }
    },
    {
        "id": 305,
        "en": {
            "question": "A stack is a ____ structure.",
            "options": [
                "A. DIFO (Double-In First-Out)",
                "B. LIFO (Last-In First-Out)",
                "C. SIFO (Sequential-In First-Out)",
                "D. FIFO (First-In First-Out)"
            ],
            "answer": "B. LIFO (Last-In First-Out)",
            "explanation": "A stack follows the LIFO principle. The last item pushed onto the stack is the first item to be popped off."
        },
        "vi": {
            "question": "M·ªôt ngƒÉn x·∫øp (stack) l√† m·ªôt c·∫•u tr√∫c ____.",
            "options": [
                "A. DIFO (Double-In First-Out)",
                "B. LIFO (Last-In First-Out)",
                "C. SIFO (Sequential-In First-Out)",
                "D. FIFO (First-In First-Out)"
            ],
            "answer": "B. LIFO (Last-In First-Out)",
            "explanation": "M·ªôt ngƒÉn x·∫øp tu√¢n theo nguy√™n t·∫Øc LIFO. M·ª•c cu·ªëi c√πng ƒë∆∞·ª£c ƒë·∫©y v√†o ngƒÉn x·∫øp l√† m·ª•c ƒë·∫ßu ti√™n ƒë∆∞·ª£c l·∫•y ra."
        }
    },
    {
        "id": 306,
        "en": {
            "question": "A step-by-step solution to a problem is called ____.",
            "options": [
                "A. an operating system",
                "B. hardware",
                "C. an algorithm",
                "D. a computer language"
            ],
            "answer": "C. an algorithm",
            "explanation": "An algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation."
        },
        "vi": {
            "question": "M·ªôt gi·∫£i ph√°p t·ª´ng b∆∞·ªõc cho m·ªôt v·∫•n ƒë·ªÅ ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. m·ªôt h·ªá ƒëi·ªÅu h√†nh",
                "B. ph·∫ßn c·ª©ng",
                "C. m·ªôt thu·∫≠t to√°n",
                "D. m·ªôt ng√¥n ng·ªØ m√°y t√≠nh"
            ],
            "answer": "C. m·ªôt thu·∫≠t to√°n",
            "explanation": "M·ªôt thu·∫≠t to√°n l√† m·ªôt chu·ªói h·ªØu h·∫°n c√°c l·ªánh ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a r√µ r√†ng, c√≥ th·ªÉ th·ª±c hi·ªán ƒë∆∞·ª£c b·∫±ng m√°y t√≠nh, th∆∞·ªùng ƒë·ªÉ gi·∫£i quy·∫øt m·ªôt l·ªõp c√°c v·∫•n ƒë·ªÅ ho·∫∑c ƒë·ªÉ th·ª±c hi·ªán m·ªôt t√≠nh to√°n."
        }
    },
    {
        "id": 307,
        "en": {
            "question": "A string of one hundred 0s is replaced by two markers, a 0, and the number 100. This is ____.",
            "options": [
                "A. Morse encoding",
                "B. Huffman encoding",
                "C. run-length encoding",
                "D. Lempel Ziv encoding"
            ],
            "answer": "C. run-length encoding",
            "explanation": "Run-length encoding (RLE) is a simple form of data compression in which runs of data (sequences in which the same data value occurs in many consecutive data elements) are stored as a single data value and count, rather than as the original run."
        },
        "vi": {
            "question": "M·ªôt chu·ªói m·ªôt trƒÉm s·ªë 0 ƒë∆∞·ª£c thay th·∫ø b·∫±ng hai ƒëi·ªÉm ƒë√°nh d·∫•u, m·ªôt s·ªë 0, v√† s·ªë 100. ƒê√¢y l√† ____.",
            "options": [
                "A. M√£ h√≥a Morse",
                "B. M√£ h√≥a Huffman",
                "C. M√£ h√≥a ƒë·ªô d√†i ch·∫°y (run-length encoding)",
                "D. M√£ h√≥a Lempel Ziv"
            ],
            "answer": "C. M√£ h√≥a ƒë·ªô d√†i ch·∫°y (run-length encoding)",
            "explanation": "M√£ h√≥a ƒë·ªô d√†i ch·∫°y (RLE) l√† m·ªôt d·∫°ng n√©n d·ªØ li·ªáu ƒë∆°n gi·∫£n trong ƒë√≥ c√°c chu·ªói d·ªØ li·ªáu (c√°c chu·ªói trong ƒë√≥ c√πng m·ªôt gi√° tr·ªã d·ªØ li·ªáu xu·∫•t hi·ªán trong nhi·ªÅu ph·∫ßn t·ª≠ d·ªØ li·ªáu li√™n ti·∫øp) ƒë∆∞·ª£c l∆∞u tr·ªØ d∆∞·ªõi d·∫°ng m·ªôt gi√° tr·ªã d·ªØ li·ªáu duy nh·∫•t v√† s·ªë ƒë·∫øm, thay v√¨ l√† chu·ªói ban ƒë·∫ßu."
        }
    },
    {
        "id": 308,
        "en": {
            "question": "A data structure can be ____.",
            "options": [
                "A. only an array",
                "B. only a linked list",
                "C. an array, a record, or a linked list",
                "D. only a record"
            ],
            "answer": "C. an array, a record, or a linked list",
            "explanation": "A data structure is a way of organizing and storing data. Arrays, records (structs), linked lists, stacks, queues, trees, etc., are all examples of data structures."
        },
        "vi": {
            "question": "M·ªôt c·∫•u tr√∫c d·ªØ li·ªáu c√≥ th·ªÉ l√† ____.",
            "options": [
                "A. ch·ªâ m·ªôt m·∫£ng",
                "B. ch·ªâ m·ªôt danh s√°ch li√™n k·∫øt",
                "C. m·ªôt m·∫£ng, m·ªôt b·∫£n ghi, ho·∫∑c m·ªôt danh s√°ch li√™n k·∫øt",
                "D. ch·ªâ m·ªôt b·∫£n ghi"
            ],
            "answer": "C. m·ªôt m·∫£ng, m·ªôt b·∫£n ghi, ho·∫∑c m·ªôt danh s√°ch li√™n k·∫øt",
            "explanation": "M·ªôt c·∫•u tr√∫c d·ªØ li·ªáu l√† m·ªôt c√°ch t·ªï ch·ª©c v√† l∆∞u tr·ªØ d·ªØ li·ªáu. M·∫£ng, b·∫£n ghi (structs), danh s√°ch li√™n k·∫øt, ngƒÉn x·∫øp, h√†ng ƒë·ª£i, c√¢y, v.v., ƒë·ªÅu l√† c√°c v√≠ d·ª• v·ªÅ c·∫•u tr√∫c d·ªØ li·ªáu."
        }
    },
    {
        "id": 309,
        "en": {
            "question": "A floating-point value after normalization is (1.0101) * 2^4. What is the value of the exponent in Excess-127 representation?",
            "options": [
                "A. 4",
                "B. 131",
                "C. -4",
                "D. 123"
            ],
            "answer": "B. 131",
            "explanation": "In IEEE 754 single-precision floating-point format, the exponent is stored in Excess-127 format. The value is calculated by adding the bias (127) to the actual exponent. So, Stored Exponent = Actual Exponent + Bias = 4 + 127 = 131."
        },
        "vi": {
            "question": "M·ªôt gi√° tr·ªã d·∫•u ph·∫©y ƒë·ªông sau khi chu·∫©n h√≥a l√† (1.0101) * 2^4. Gi√° tr·ªã c·ªßa ph·∫ßn s·ªë m≈© trong bi·ªÉu di·ªÖn Excess-127 l√† bao nhi√™u?",
            "options": [
                "A. 4",
                "B. 131",
                "C. -4",
                "D. 123"
            ],
            "answer": "B. 131",
            "explanation": "Trong ƒë·ªãnh d·∫°ng d·∫•u ph·∫©y ƒë·ªông ƒë∆°n ch√≠nh x√°c IEEE 754, s·ªë m≈© ƒë∆∞·ª£c l∆∞u tr·ªØ ·ªü ƒë·ªãnh d·∫°ng Excess-127. Gi√° tr·ªã ƒë∆∞·ª£c t√≠nh b·∫±ng c√°ch c·ªông ƒë·ªô l·ªách (127) v√†o s·ªë m≈© th·ª±c t·∫ø. V√¨ v·∫≠y, S·ªë m≈© ƒë∆∞·ª£c l∆∞u tr·ªØ = S·ªë m≈© th·ª±c t·∫ø + ƒê·ªô l·ªách = 4 + 127 = 131."
        }
    },
    {
        "id": 310,
        "en": {
            "question": "Extremely fast, small RAM's are called as ____?",
            "options": [
                "A. Cache",
                "B. Heaps",
                "C. Stack",
                "D. Registers"
            ],
            "answer": "D. Registers",
            "explanation": "Registers are the absolute fastest memory in a computer, located directly inside the CPU core. Cache is the next fastest level."
        },
        "vi": {
            "question": "C√°c RAM c·ª±c nhanh, nh·ªè ƒë∆∞·ª£c g·ªçi l√† ____?",
            "options": [
                "A. Cache",
                "B. Heaps",
                "C. Stack",
                "D. Thanh ghi (Registers)"
            ],
            "answer": "D. Thanh ghi (Registers)",
            "explanation": "C√°c thanh ghi l√† b·ªô nh·ªõ nhanh nh·∫•t tuy·ªát ƒë·ªëi trong m·ªôt m√°y t√≠nh, n·∫±m tr·ª±c ti·∫øp b√™n trong l√µi CPU. Cache l√† c·∫•p ƒë·ªô nhanh ti·∫øp theo."
        }
    },
    {
        "id": 311,
        "en": {
            "question": "Which architecture is memory saving?",
            "options": [
                "A. None of the mentioned",
                "B. Von Neumann",
                "C. Harvard",
                "D. Harvard & Von Neumann"
            ],
            "answer": "B. Von Neumann",
            "explanation": "The Von Neumann architecture uses a single, unified memory for both instructions and data, which can be more memory-efficient compared to the Harvard architecture's separate memory spaces."
        },
        "vi": {
            "question": "Ki·∫øn tr√∫c n√†o ti·∫øt ki·ªám b·ªô nh·ªõ?",
            "options": [
                "A. Kh√¥ng c√≥ c√°i n√†o",
                "B. Von Neumann",
                "C. Harvard",
                "D. Harvard & Von Neumann"
            ],
            "answer": "B. Von Neumann",
            "explanation": "Ki·∫øn tr√∫c Von Neumann s·ª≠ d·ª•ng m·ªôt b·ªô nh·ªõ duy nh·∫•t, h·ª£p nh·∫•t cho c·∫£ l·ªánh v√† d·ªØ li·ªáu, c√≥ th·ªÉ hi·ªáu qu·∫£ h∆°n v·ªÅ b·ªô nh·ªõ so v·ªõi c√°c kh√¥ng gian b·ªô nh·ªõ ri√™ng bi·ªát c·ªßa ki·∫øn tr√∫c Harvard."
        }
    },
    {
        "id": 312,
        "en": {
            "question": "During the execution of the instructions, a copy of the instructions is placed in the ____.",
            "options": [
                "A. HDD",
                "B. Registers",
                "C. RAM",
                "D. Cache"
            ],
            "answer": "D. Cache",
            "explanation": "To speed up execution, both instructions and data are copied from the slower main memory (RAM) into the much faster cache memory for the CPU to access."
        },
        "vi": {
            "question": "Trong qu√° tr√¨nh th·ª±c thi c√°c l·ªánh, m·ªôt b·∫£n sao c·ªßa c√°c l·ªánh ƒë∆∞·ª£c ƒë·∫∑t trong ____.",
            "options": [
                "A. HDD",
                "B. Thanh ghi",
                "C. RAM",
                "D. Cache"
            ],
            "answer": "D. Cache",
            "explanation": "ƒê·ªÉ tƒÉng t·ªëc ƒë·ªô th·ª±c thi, c·∫£ l·ªánh v√† d·ªØ li·ªáu ƒë·ªÅu ƒë∆∞·ª£c sao ch√©p t·ª´ b·ªô nh·ªõ ch√≠nh ch·∫≠m h∆°n (RAM) v√†o b·ªô nh·ªõ cache nhanh h∆°n nhi·ªÅu ƒë·ªÉ CPU truy c·∫≠p."
        }
    },
    {
        "id": 313,
        "en": {
            "question": "A process in the ready state goes to the running state when ____.",
            "options": [
                "A. it gets access to the CPU.",
                "B. it finishes running.",
                "C. it requests I/O.",
                "D. it enters memory."
            ],
            "answer": "A. it gets access to the CPU.",
            "explanation": "The transition from 'Ready' to 'Running' occurs when the OS scheduler (dispatcher) selects that process from the ready queue and assigns a CPU core to it."
        },
        "vi": {
            "question": "M·ªôt ti·∫øn tr√¨nh ·ªü tr·∫°ng th√°i s·∫µn s√†ng chuy·ªÉn sang tr·∫°ng th√°i ƒëang ch·∫°y khi ____.",
            "options": [
                "A. n√≥ ƒë∆∞·ª£c truy c·∫≠p v√†o CPU.",
                "B. n√≥ k·∫øt th√∫c vi·ªác ch·∫°y.",
                "C. n√≥ y√™u c·∫ßu I/O.",
                "D. n√≥ v√†o b·ªô nh·ªõ."
            ],
            "answer": "A. n√≥ ƒë∆∞·ª£c truy c·∫≠p v√†o CPU.",
            "explanation": "S·ª± chuy·ªÉn ƒë·ªïi t·ª´ 'S·∫µn s√†ng' sang 'ƒêang ch·∫°y' x·∫£y ra khi b·ªô l·∫≠p l·ªãch HƒêH (b·ªô ƒëi·ªÅu ph·ªëi) ch·ªçn ti·∫øn tr√¨nh ƒë√≥ t·ª´ h√†ng ƒë·ª£i s·∫µn s√†ng v√† g√°n m·ªôt l√µi CPU cho n√≥."
        }
    },
    {
        "id": 314,
        "en": {
            "question": "The System Bus is made up of ____.",
            "options": [
                "A. Address Bus",
                "B. Control Bus, Data Bus and Address Bus",
                "C. Control Bus",
                "D. Data Bus"
            ],
            "answer": "B. Control Bus, Data Bus and Address Bus",
            "explanation": "The system bus is a combination of three separate buses: the Address Bus (carries memory addresses), the Data Bus (carries the actual data), and the Control Bus (carries control and timing signals)."
        },
        "vi": {
            "question": "Bus H·ªá th·ªëng ƒë∆∞·ª£c t·∫°o th√†nh t·ª´ ____.",
            "options": [
                "A. Bus ƒë·ªãa ch·ªâ",
                "B. Bus ƒëi·ªÅu khi·ªÉn, Bus d·ªØ li·ªáu v√† Bus ƒë·ªãa ch·ªâ",
                "C. Bus ƒëi·ªÅu khi·ªÉn",
                "D. Bus d·ªØ li·ªáu"
            ],
            "answer": "B. Bus ƒëi·ªÅu khi·ªÉn, Bus d·ªØ li·ªáu v√† Bus ƒë·ªãa ch·ªâ",
            "explanation": "Bus h·ªá th·ªëng l√† s·ª± k·∫øt h·ª£p c·ªßa ba bus ri√™ng bi·ªát: Bus ƒë·ªãa ch·ªâ (mang ƒë·ªãa ch·ªâ b·ªô nh·ªõ), Bus d·ªØ li·ªáu (mang d·ªØ li·ªáu th·ª±c t·∫ø), v√† Bus ƒëi·ªÅu khi·ªÉn (mang t√≠n hi·ªáu ƒëi·ªÅu khi·ªÉn v√† ƒë·ªãnh th·ªùi)."
        }
    },
    {
        "id": 315,
        "en": {
            "question": "A(n) ____ is generated by some condition that occurs as a result of an instruction execution.",
            "options": [
                "A. timer interrupt",
                "B. I/O interrupt",
                "C. program interrupt",
                "D. hardware failure interrupt"
            ],
            "answer": "C. program interrupt",
            "explanation": "Program interrupts, also known as traps or exceptions, are synchronous interrupts caused by the program itself, such as division by zero, invalid memory access, or an illegal instruction."
        },
        "vi": {
            "question": "M·ªôt(n) ____ ƒë∆∞·ª£c t·∫°o ra b·ªüi m·ªôt s·ªë ƒëi·ªÅu ki·ªán x·∫£y ra do k·∫øt qu·∫£ c·ªßa vi·ªác th·ª±c thi m·ªôt l·ªánh.",
            "options": [
                "A. ng·∫Øt h·∫πn gi·ªù",
                "B. ng·∫Øt I/O",
                "C. ng·∫Øt ch∆∞∆°ng tr√¨nh",
                "D. ng·∫Øt l·ªói ph·∫ßn c·ª©ng"
            ],
            "answer": "C. ng·∫Øt ch∆∞∆°ng tr√¨nh",
            "explanation": "C√°c ng·∫Øt ch∆∞∆°ng tr√¨nh, c√≤n ƒë∆∞·ª£c g·ªçi l√† b·∫´y ho·∫∑c ngo·∫°i l·ªá, l√† c√°c ng·∫Øt ƒë·ªìng b·ªô do ch√≠nh ch∆∞∆°ng tr√¨nh g√¢y ra, ch·∫≥ng h·∫°n nh∆∞ chia cho kh√¥ng, truy c·∫≠p b·ªô nh·ªõ kh√¥ng h·ª£p l·ªá ho·∫∑c m·ªôt l·ªánh b·∫•t h·ª£p ph√°p."
        }
    },
    {
        "id": 316,
        "en": {
            "question": "A(n) ____ is generated by a failure such as power failure or memory parity error.",
            "options": [
                "A. program interrupt",
                "B. I/O interrupt",
                "C. hardware failure interrupt",
                "D. timer interrupt"
            ],
            "answer": "C. hardware failure interrupt",
            "explanation": "These are asynchronous interrupts triggered by hardware problems, indicating a critical system error that needs immediate attention."
        },
        "vi": {
            "question": "M·ªôt (n) ____ ƒë∆∞·ª£c t·∫°o ra b·ªüi m·ªôt l·ªói nh∆∞ m·∫•t ƒëi·ªán ho·∫∑c l·ªói ch·∫µn l·∫ª b·ªô nh·ªõ.",
            "options": [
                "A. ng·∫Øt ch∆∞∆°ng tr√¨nh (program interrupt)",
                "B. ng·∫Øt I/O (I/O interrupt)",
                "C. ng·∫Øt l·ªói ph·∫ßn c·ª©ng (hardware failure interrupt)",
                "D. ng·∫Øt h·∫πn gi·ªù (timer interrupt)"
            ],
            "answer": "C. ng·∫Øt l·ªói ph·∫ßn c·ª©ng (hardware failure interrupt)",
            "explanation": "ƒê√¢y l√† c√°c ng·∫Øt kh√¥ng ƒë·ªìng b·ªô ƒë∆∞·ª£c k√≠ch ho·∫°t b·ªüi c√°c s·ª± c·ªë ph·∫ßn c·ª©ng, cho th·∫•y m·ªôt l·ªói h·ªá th·ªëng nghi√™m tr·ªçng c·∫ßn ƒë∆∞·ª£c ch√∫ √Ω ngay l·∫≠p t·ª©c."
        }
    },
    {
        "id": 317,
        "en": {
            "question": "Swapping is an I/O operation.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Swapping involves moving a process (or parts of a process) between main memory and secondary storage (disk), which is fundamentally an I/O operation."
        },
        "vi": {
            "question": "Ho√°n ƒë·ªïi (Swapping) l√† m·ªôt ho·∫°t ƒë·ªông I/O.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Ho√°n ƒë·ªïi li√™n quan ƒë·∫øn vi·ªác di chuy·ªÉn m·ªôt ti·∫øn tr√¨nh (ho·∫∑c c√°c ph·∫ßn c·ªßa m·ªôt ti·∫øn tr√¨nh) gi·ªØa b·ªô nh·ªõ ch√≠nh v√† b·ªô nh·ªõ th·ª© c·∫•p (ƒëƒ©a), v·ªÅ c∆° b·∫£n l√† m·ªôt ho·∫°t ƒë·ªông I/O."
        }
    },
    {
        "id": 318,
        "en": {
            "question": "With demand paging it is necessary to load an entire process into main memory.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The main benefit of demand paging is that it is NOT necessary to load the entire process. Pages are only loaded from disk into memory when they are actually needed (demanded), saving memory and speeding up program startup."
        },
        "vi": {
            "question": "V·ªõi ph√¢n trang theo y√™u c·∫ßu, c·∫ßn ph·∫£i t·∫£i to√†n b·ªô ti·∫øn tr√¨nh v√†o b·ªô nh·ªõ ch√≠nh.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "L·ª£i √≠ch ch√≠nh c·ªßa ph√¢n trang theo y√™u c·∫ßu l√† KH√îNG c·∫ßn ph·∫£i t·∫£i to√†n b·ªô ti·∫øn tr√¨nh. C√°c trang ch·ªâ ƒë∆∞·ª£c t·∫£i t·ª´ ƒëƒ©a v√†o b·ªô nh·ªõ khi ch√∫ng th·ª±c s·ª± c·∫ßn thi·∫øt (ƒë∆∞·ª£c y√™u c·∫ßu), gi√∫p ti·∫øt ki·ªám b·ªô nh·ªõ v√† tƒÉng t·ªëc ƒë·ªô kh·ªüi ƒë·ªông ch∆∞∆°ng tr√¨nh."
        }
    },
    {
        "id": 319,
        "en": {
            "question": "____ is when the processor spends most of its time swapping pages rather than executing instructions.",
            "options": [
                "A. Swapping",
                "B. Thrashing",
                "C. Paging",
                "D. Multitasking"
            ],
            "answer": "B. Thrashing",
            "explanation": "Thrashing is a condition of excessive paging activity. It occurs when a system doesn't have enough memory to hold the working set of all active processes, leading to constant page faults and a severe drop in performance."
        },
        "vi": {
            "question": "____ l√† khi b·ªô x·ª≠ l√Ω d√†nh ph·∫ßn l·ªõn th·ªùi gian ƒë·ªÉ ho√°n ƒë·ªïi c√°c trang thay v√¨ th·ª±c thi c√°c l·ªánh.",
            "options": [
                "A. Ho√°n ƒë·ªïi (Swapping)",
                "B. Trashing",
                "C. Ph√¢n trang (Paging)",
                "D. ƒêa nhi·ªám (Multitasking)"
            ],
            "answer": "B. Trashing",
            "explanation": "Trashing l√† t√¨nh tr·∫°ng ho·∫°t ƒë·ªông ph√¢n trang qu√° m·ª©c. N√≥ x·∫£y ra khi m·ªôt h·ªá th·ªëng kh√¥ng c√≥ ƒë·ªß b·ªô nh·ªõ ƒë·ªÉ gi·ªØ t·∫≠p h·ª£p l√†m vi·ªác c·ªßa t·∫•t c·∫£ c√°c ti·∫øn tr√¨nh ƒëang ho·∫°t ƒë·ªông, d·∫´n ƒë·∫øn c√°c l·ªói trang li√™n t·ª•c v√† s·ª± s·ª•t gi·∫£m hi·ªáu su·∫•t nghi√™m tr·ªçng."
        }
    },
    {
        "id": 320,
        "en": {
            "question": "The OS maintains a ____ for each process that shows the frame location for each page of the process.",
            "options": [
                "A. kernel",
                "B. page table",
                "C. TLB",
                "D. logical address"
            ],
            "answer": "B. page table",
            "explanation": "A page table is the data structure used by the virtual memory system to store the mapping between virtual addresses and physical addresses."
        },
        "vi": {
            "question": "HƒêH duy tr√¨ m·ªôt ____ cho m·ªói ti·∫øn tr√¨nh cho bi·∫øt v·ªã tr√≠ khung cho m·ªói trang c·ªßa ti·∫øn tr√¨nh.",
            "options": [
                "A. kernel",
                "B. page table (b·∫£ng trang)",
                "C. TLB",
                "D. logical address (ƒë·ªãa ch·ªâ logic)"
            ],
            "answer": "B. page table (b·∫£ng trang)",
            "explanation": "M·ªôt b·∫£ng trang l√† c·∫•u tr√∫c d·ªØ li·ªáu ƒë∆∞·ª£c h·ªá th·ªëng b·ªô nh·ªõ ·∫£o s·ª≠ d·ª•ng ƒë·ªÉ l∆∞u tr·ªØ √°nh x·∫° gi·ªØa c√°c ƒë·ªãa ch·ªâ ·∫£o v√† ƒë·ªãa ch·ªâ v·∫≠t l√Ω."
        }
    },
    {
        "id": 321,
        "en": {
            "question": "The hexadecimal symbol 6 is ____ in binary.",
            "options": [
                "A. 0110",
                "B. 0101",
                "C. 0100",
                "D. 0011"
            ],
            "answer": "A. 0110",
            "explanation": "In binary, 6 is represented as 4 + 2, which is 0110."
        },
        "vi": {
            "question": "K√Ω hi·ªáu th·∫≠p l·ª•c ph√¢n 6 l√† ____ trong h·ªá nh·ªã ph√¢n.",
            "options": [
                "A. 0110",
                "B. 0101",
                "C. 0100",
                "D. 0011"
            ],
            "answer": "A. 0110",
            "explanation": "Trong h·ªá nh·ªã ph√¢n, 6 ƒë∆∞·ª£c bi·ªÉu di·ªÖn l√† 4 + 2, t·ª©c l√† 0110."
        }
    },
    {
        "id": 322,
        "en": {
            "question": "The decimal number 10 is ____ in binary.",
            "options": [
                "A. 1010",
                "B. 1110",
                "C. 0101",
                "D. 0011"
            ],
            "answer": "A. 1010",
            "explanation": "In binary, 10 is represented as 8 + 2, which is 1010."
        },
        "vi": {
            "question": "S·ªë th·∫≠p ph√¢n 10 l√† ____ trong h·ªá nh·ªã ph√¢n.",
            "options": [
                "A. 1010",
                "B. 1110",
                "C. 0101",
                "D. 0011"
            ],
            "answer": "A. 1010",
            "explanation": "Trong h·ªá nh·ªã ph√¢n, 10 ƒë∆∞·ª£c bi·ªÉu di·ªÖn l√† 8 + 2, t·ª©c l√† 1010."
        }
    },
    {
        "id": 323,
        "en": {
            "question": "The ____ operation yields true if and only if both of its operands have the same value.",
            "options": [
                "A. AND",
                "B. NOT",
                "C. OR",
                "D. Equivalence (XNOR)"
            ],
            "answer": "D. Equivalence (XNOR)",
            "explanation": "The Equivalence or XNOR (Exclusive NOR) gate produces a true (1) output when both inputs are the same (0,0 or 1,1)."
        },
        "vi": {
            "question": "Ph√©p to√°n ____ mang l·∫°i gi√° tr·ªã true khi v√† ch·ªâ khi c·∫£ hai to√°n h·∫°ng c·ªßa n√≥ c√≥ c√πng gi√° tr·ªã.",
            "options": [
                "A. AND",
                "B. NOT",
                "C. OR",
                "D. T∆∞∆°ng ƒë∆∞∆°ng (XNOR)"
            ],
            "answer": "D. T∆∞∆°ng ƒë∆∞∆°ng (XNOR)",
            "explanation": "C·ªïng T∆∞∆°ng ƒë∆∞∆°ng ho·∫∑c XNOR (Exclusive NOR) t·∫°o ra m·ªôt ƒë·∫ßu ra ƒë√∫ng (1) khi c·∫£ hai ƒë·∫ßu v√†o gi·ªëng nhau (0,0 ho·∫∑c 1,1)."
        }
    },
    {
        "id": 324,
        "en": {
            "question": "A ____ is an electronic circuit that produces an output signal that is a simple Boolean operation on its input signals.",
            "options": [
                "A. gate",
                "B. decoder",
                "C. counter",
                "D. flip-flop"
            ],
            "answer": "A. gate",
            "explanation": "This is the definition of a logic gate, the fundamental building block of all digital logic circuits."
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt m·∫°ch ƒëi·ªán t·ª≠ t·∫°o ra m·ªôt t√≠n hi·ªáu ƒë·∫ßu ra l√† m·ªôt ph√©p to√°n Boolean ƒë∆°n gi·∫£n tr√™n c√°c t√≠n hi·ªáu ƒë·∫ßu v√†o c·ªßa n√≥.",
            "options": [
                "A. c·ªïng (gate)",
                "B. b·ªô gi·∫£i m√£ (decoder)",
                "C. b·ªô ƒë·∫øm (counter)",
                "D. flip-flop"
            ],
            "answer": "A. c·ªïng (gate)",
            "explanation": "ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa m·ªôt c·ªïng logic, kh·ªëi x√¢y d·ª±ng c∆° b·∫£n c·ªßa t·∫•t c·∫£ c√°c m·∫°ch logic s·ªë."
        }
    },
    {
        "id": 325,
        "en": {
            "question": "The ____ accepts and/or transfers information serially.",
            "options": [
                "A. S-R latch",
                "B. shift register",
                "C. FPGA",
                "D. parallel register"
            ],
            "answer": "B. shift register",
            "explanation": "A shift register is a cascade of flip-flops, sharing the same clock, in which the output of each flip-flop is connected to the 'data' input of the next flip-flop in the chain, resulting in a circuit that shifts its stored bit pattern by one position for each clock pulse."
        },
        "vi": {
            "question": "____ ch·∫•p nh·∫≠n v√†/ho·∫∑c truy·ªÅn th√¥ng tin n·ªëi ti·∫øp.",
            "options": [
                "A. S-R latch",
                "B. shift register (thanh ghi d·ªãch)",
                "C. FPGA",
                "D. parallel register (thanh ghi song song)"
            ],
            "answer": "B. shift register (thanh ghi d·ªãch)",
            "explanation": "M·ªôt thanh ghi d·ªãch l√† m·ªôt chu·ªói c√°c flip-flop, chia s·∫ª c√πng m·ªôt xung nh·ªãp, trong ƒë√≥ ƒë·∫ßu ra c·ªßa m·ªói flip-flop ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi ƒë·∫ßu v√†o 'd·ªØ li·ªáu' c·ªßa flip-flop ti·∫øp theo trong chu·ªói, t·∫°o ra m·ªôt m·∫°ch d·ªãch chuy·ªÉn m·∫´u bit ƒë∆∞·ª£c l∆∞u tr·ªØ c·ªßa n√≥ ƒëi m·ªôt v·ªã tr√≠ cho m·ªói xung nh·ªãp."
        }
    },
    {
        "id": 326,
        "en": {
            "question": "The ____ specifies the operation to be performed.",
            "options": [
                "A. source operand reference",
                "B. opcode",
                "C. next instruction reference",
                "D. processor register"
            ],
            "answer": "B. opcode",
            "explanation": "The opcode (operation code) is the part of a machine language instruction that specifies the action to be taken."
        },
        "vi": {
            "question": "____ ch·ªâ ƒë·ªãnh ho·∫°t ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán.",
            "options": [
                "A. tham chi·∫øu to√°n h·∫°ng ngu·ªìn",
                "B. opcode",
                "C. tham chi·∫øu l·ªánh ti·∫øp theo",
                "D. thanh ghi b·ªô x·ª≠ l√Ω"
            ],
            "answer": "B. opcode",
            "explanation": "M√£ l·ªánh (opcode) l√† m·ªôt ph·∫ßn c·ªßa l·ªánh ng√¥n ng·ªØ m√°y ch·ªâ ƒë·ªãnh h√†nh ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán."
        }
    },
    {
        "id": 327,
        "en": {
            "question": "Which of the following is true?",
            "options": [
                "A. a procedure can be called from more than one location",
                "B. a procedure call can appear in a procedure",
                "C. each procedure call is matched by a return in the called program",
                "D. all of the above"
            ],
            "answer": "D. all of the above",
            "explanation": "These are all fundamental properties of procedures (or functions/subroutines) in programming. They are reusable blocks of code that can be called from multiple places, can call other procedures (including themselves recursively), and are expected to return control to the caller."
        },
        "vi": {
            "question": "Ph√°t bi·ªÉu n√†o sau ƒë√¢y l√† ƒë√∫ng?",
            "options": [
                "A. m·ªôt th·ªß t·ª•c c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi t·ª´ nhi·ªÅu h∆°n m·ªôt v·ªã tr√≠",
                "B. m·ªôt l·ªánh g·ªçi th·ªß t·ª•c c√≥ th·ªÉ xu·∫•t hi·ªán trong m·ªôt th·ªß t·ª•c",
                "C. m·ªói l·ªánh g·ªçi th·ªß t·ª•c ƒë∆∞·ª£c kh·ªõp v·ªõi m·ªôt l·ªánh tr·ªü v·ªÅ trong ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c g·ªçi",
                "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n"
            ],
            "answer": "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n",
            "explanation": "ƒê√¢y ƒë·ªÅu l√† c√°c thu·ªôc t√≠nh c∆° b·∫£n c·ªßa c√°c th·ªß t·ª•c (ho·∫∑c h√†m/ch∆∞∆°ng tr√¨nh con) trong l·∫≠p tr√¨nh. Ch√∫ng l√† c√°c kh·ªëi m√£ c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi t·ª´ nhi·ªÅu n∆°i, c√≥ th·ªÉ g·ªçi c√°c th·ªß t·ª•c kh√°c (bao g·ªìm c·∫£ ch√≠nh ch√∫ng m·ªôt c√°ch ƒë·ªá quy), v√† ƒë∆∞·ª£c mong ƒë·ª£i s·∫Ω tr·∫£ l·∫°i quy·ªÅn ƒëi·ªÅu khi·ªÉn cho ng∆∞·ªùi g·ªçi."
        }
    },
    {
        "id": 328,
        "en": {
            "question": "The entire set of parameters, including return address, that is stored for a procedure invocation is referred to as a ____.",
            "options": [
                "A. branch",
                "B. stack frame",
                "C. pop",
                "D. push"
            ],
            "answer": "B. stack frame",
            "explanation": "A stack frame (or activation record) is a block of memory on the call stack that contains the local variables, function parameters, and the return address for a single invocation of a procedure."
        },
        "vi": {
            "question": "To√†n b·ªô t·∫≠p h·ª£p c√°c tham s·ªë, bao g·ªìm ƒë·ªãa ch·ªâ tr·∫£ v·ªÅ, ƒë∆∞·ª£c l∆∞u tr·ªØ cho m·ªôt l·ªùi g·ªçi th·ªß t·ª•c ƒë∆∞·ª£c g·ªçi l√† m·ªôt ____.",
            "options": [
                "A. branch",
                "B. stack frame",
                "C. pop",
                "D. push"
            ],
            "answer": "B. stack frame",
            "explanation": "M·ªôt khung ngƒÉn x·∫øp (ho·∫∑c b·∫£n ghi k√≠ch ho·∫°t) l√† m·ªôt kh·ªëi b·ªô nh·ªõ tr√™n ngƒÉn x·∫øp cu·ªôc g·ªçi ch·ª©a c√°c bi·∫øn c·ª•c b·ªô, tham s·ªë h√†m, v√† ƒë·ªãa ch·ªâ tr·∫£ v·ªÅ cho m·ªôt l·∫ßn g·ªçi duy nh·∫•t c·ªßa m·ªôt th·ªß t·ª•c."
        }
    },
    {
        "id": 329,
        "en": {
            "question": "____ are bits set by the processor hardware as the result of operations.",
            "options": [
                "A. Condition codes",
                "B. Data registers",
                "C. Address registers",
                "D. Control and status registers"
            ],
            "answer": "A. Condition codes",
            "explanation": "Condition codes, also known as flags, are a set of bits in a status register (like the EFLAGS register in x86) that are set or cleared by the ALU based on the result of an operation (e.g., Zero Flag, Carry Flag, Sign Flag)."
        },
        "vi": {
            "question": "____ l√† c√°c bit ƒë∆∞·ª£c thi·∫øt l·∫≠p b·ªüi ph·∫ßn c·ª©ng b·ªô x·ª≠ l√Ω do k·∫øt qu·∫£ c·ªßa c√°c ho·∫°t ƒë·ªông.",
            "options": [
                "A. M√£ ƒëi·ªÅu ki·ªán",
                "B. Thanh ghi d·ªØ li·ªáu",
                "C. Thanh ghi ƒë·ªãa ch·ªâ",
                "D. Thanh ghi ƒëi·ªÅu khi·ªÉn v√† tr·∫°ng th√°i"
            ],
            "answer": "A. M√£ ƒëi·ªÅu ki·ªán",
            "explanation": "C√°c m√£ ƒëi·ªÅu ki·ªán, c√≤n ƒë∆∞·ª£c g·ªçi l√† c√°c c·ªù, l√† m·ªôt t·∫≠p h·ª£p c√°c bit trong m·ªôt thanh ghi tr·∫°ng th√°i (nh∆∞ thanh ghi EFLAGS trong x86) ƒë∆∞·ª£c thi·∫øt l·∫≠p ho·∫∑c x√≥a b·ªüi ALU d·ª±a tr√™n k·∫øt qu·∫£ c·ªßa m·ªôt ho·∫°t ƒë·ªông (v√≠ d·ª•: C·ªù Zero, C·ªù Nh·ªõ, C·ªù D·∫•u)."
        }
    },
    {
        "id": 330,
        "en": {
            "question": "A ____ is a small, very-high-speed memory maintained by the instruction fetch stage of the pipeline and containing the n most recently fetched instructions.",
            "options": [
                "A. multiprocessor",
                "B. branch instruction",
                "C. loop buffer",
                "D. branch prediction"
            ],
            "answer": "C. loop buffer",
            "explanation": "A loop buffer is a small, fast memory used by the instruction fetch unit. If a branch is taken back to a recent instruction, the instruction can be fetched from the high-speed loop buffer instead of the slower cache or main memory."
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt b·ªô nh·ªõ nh·ªè, t·ªëc ƒë·ªô r·∫•t cao ƒë∆∞·ª£c duy tr√¨ b·ªüi giai ƒëo·∫°n t√¨m n·∫°p l·ªánh c·ªßa ƒë∆∞·ªùng ·ªëng v√† ch·ª©a n l·ªánh ƒë∆∞·ª£c t√¨m n·∫°p g·∫ßn ƒë√¢y nh·∫•t.",
            "options": [
                "A. b·ªô ƒëa x·ª≠ l√Ω",
                "B. l·ªánh r·∫Ω nh√°nh",
                "C. b·ªô ƒë·ªám v√≤ng l·∫∑p (loop buffer)",
                "D. d·ª± ƒëo√°n nh√°nh"
            ],
            "answer": "C. b·ªô ƒë·ªám v√≤ng l·∫∑p (loop buffer)",
            "explanation": "M·ªôt b·ªô ƒë·ªám v√≤ng l·∫∑p l√† m·ªôt b·ªô nh·ªõ nh·ªè, nhanh ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ƒë∆°n v·ªã t√¨m n·∫°p l·ªánh. N·∫øu m·ªôt nh√°nh ƒë∆∞·ª£c th·ª±c hi·ªán tr·ªü l·∫°i m·ªôt l·ªánh g·∫ßn ƒë√¢y, l·ªánh ƒë√≥ c√≥ th·ªÉ ƒë∆∞·ª£c t√¨m n·∫°p t·ª´ b·ªô ƒë·ªám v√≤ng l·∫∑p t·ªëc ƒë·ªô cao thay v√¨ t·ª´ b·ªô nh·ªõ cache ho·∫∑c b·ªô nh·ªõ ch√≠nh ch·∫≠m h∆°n."
        }
    },
    {
        "id": 331,
        "en": {
            "question": "A ____ is a small cache memory associated with the instruction fetch stage of the pipeline.",
            "options": [
                "A. dynamic branch",
                "B. loop table",
                "C. branch history table",
                "D. flag"
            ],
            "answer": "C. branch history table",
            "explanation": "A Branch History Table (BHT), or Branch Prediction Buffer, is a cache that stores the recent outcomes (taken or not taken) of conditional branches to help the processor predict the future outcome of the same branch."
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt b·ªô nh·ªõ cache nh·ªè li√™n quan ƒë·∫øn giai ƒëo·∫°n t√¨m n·∫°p l·ªánh c·ªßa ƒë∆∞·ªùng ·ªëng.",
            "options": [
                "A. dynamic branch",
                "B. loop table",
                "C. branch history table",
                "D. flag"
            ],
            "answer": "C. branch history table",
            "explanation": "M·ªôt B·∫£ng L·ªãch s·ª≠ R·∫Ω nh√°nh (BHT), ho·∫∑c B·ªô ƒë·ªám D·ª± ƒëo√°n R·∫Ω nh√°nh, l√† m·ªôt b·ªô ƒë·ªám l∆∞u tr·ªØ c√°c k·∫øt qu·∫£ g·∫ßn ƒë√¢y (th·ª±c hi·ªán hay kh√¥ng th·ª±c hi·ªán) c·ªßa c√°c nh√°nh c√≥ ƒëi·ªÅu ki·ªán ƒë·ªÉ gi√∫p b·ªô x·ª≠ l√Ω d·ª± ƒëo√°n k·∫øt qu·∫£ trong t∆∞∆°ng lai c·ªßa c√πng m·ªôt nh√°nh."
        }
    },
    {
        "id": 332,
        "en": {
            "question": "A ____ instruction can be used to account for data and branch delays.",
            "options": [
                "A. SUB",
                "B. NOOP",
                "C. JUMP",
                "D. all of the above"
            ],
            "answer": "B. NOOP",
            "explanation": "A NOOP (or NOP - No Operation) instruction is an instruction that does nothing. It is used by compilers or programmers to fill delay slots in a pipeline, ensuring that dependencies are resolved before the next real instruction executes."
        },
        "vi": {
            "question": "M·ªôt l·ªánh ____ c√≥ th·ªÉ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t√≠nh ƒë·∫øn c√°c ƒë·ªô tr·ªÖ d·ªØ li·ªáu v√† nh√°nh.",
            "options": [
                "A. SUB",
                "B. NOOP",
                "C. JUMP",
                "D. t·∫•t c·∫£ c√°c ph∆∞∆°ng √°n tr√™n"
            ],
            "answer": "B. NOOP",
            "explanation": "M·ªôt l·ªánh NOOP (ho·∫∑c NOP - Kh√¥ng ho·∫°t ƒë·ªông) l√† m·ªôt l·ªánh kh√¥ng l√†m g√¨ c·∫£. N√≥ ƒë∆∞·ª£c c√°c tr√¨nh bi√™n d·ªãch ho·∫∑c l·∫≠p tr√¨nh vi√™n s·ª≠ d·ª•ng ƒë·ªÉ l·∫•p ƒë·∫ßy c√°c khe tr·ªÖ trong m·ªôt ƒë∆∞·ªùng ·ªëng, ƒë·∫£m b·∫£o r·∫±ng c√°c ph·ª• thu·ªôc ƒë∆∞·ª£c gi·∫£i quy·∫øt tr∆∞·ªõc khi l·ªánh th·ª±c s·ª± ti·∫øp theo ƒë∆∞·ª£c th·ª±c thi."
        }
    },
    {
        "id": 333,
        "en": {
            "question": "The instruction location immediately following a delayed branch is called the ____.",
            "options": [
                "A. delay load",
                "B. delay file",
                "C. delay slot",
                "D. delay register"
            ],
            "answer": "C. delay slot",
            "explanation": "In some RISC architectures with delayed branches, the instruction immediately following the branch instruction is always executed, regardless of whether the branch is taken. This location is called the delay slot, and compilers try to fill it with a useful instruction."
        },
        "vi": {
            "question": "V·ªã tr√≠ l·ªánh ngay sau m·ªôt nh√°nh tr·ªÖ ƒë∆∞·ª£c g·ªçi l√† ____.",
            "options": [
                "A. delay load",
                "B. delay file",
                "C. delay slot",
                "D. delay register"
            ],
            "answer": "C. delay slot",
            "explanation": "Trong m·ªôt s·ªë ki·∫øn tr√∫c RISC c√≥ c√°c nh√°nh tr·ªÖ, l·ªánh ngay sau l·ªánh r·∫Ω nh√°nh lu√¥n ƒë∆∞·ª£c th·ª±c thi, b·∫•t k·ªÉ nh√°nh c√≥ ƒë∆∞·ª£c th·ª±c hi·ªán hay kh√¥ng. V·ªã tr√≠ n√†y ƒë∆∞·ª£c g·ªçi l√† khe tr·ªÖ, v√† c√°c tr√¨nh bi√™n d·ªãch c·ªë g·∫Øng l·∫•p ƒë·∫ßy n√≥ b·∫±ng m·ªôt l·ªánh h·ªØu √≠ch."
        }
    },
    {
        "id": 334,
        "en": {
            "question": "The MIPS R4000 uses ____ bits for all internal and external data paths and for addresses, registers, and the ALU.",
            "options": [
                "A. 16",
                "B. 32",
                "C. 64",
                "D. 128"
            ],
            "answer": "C. 64",
            "explanation": "The MIPS R4000 was one of the first commercially available 64-bit microprocessors, featuring a full 64-bit architecture."
        },
        "vi": {
            "question": "MIPS R4000 s·ª≠ d·ª•ng ____ bit cho t·∫•t c·∫£ c√°c ƒë∆∞·ªùng d·∫´n d·ªØ li·ªáu n·ªôi b·ªô v√† b√™n ngo√†i v√† cho c√°c ƒë·ªãa ch·ªâ, thanh ghi v√† ALU.",
            "options": [
                "A. 16",
                "B. 32",
                "C. 64",
                "D. 128"
            ],
            "answer": "C. 64",
            "explanation": "MIPS R4000 l√† m·ªôt trong nh·ªØng b·ªô vi x·ª≠ l√Ω 64-bit th∆∞∆°ng m·∫°i ƒë·∫ßu ti√™n, c√≥ ki·∫øn tr√∫c 64-bit ƒë·∫ßy ƒë·ªß."
        }
    },
    {
        "id": 335,
        "en": {
            "question": "All processor instructions of the MIPS R series are encoded in a single ____ word format.",
            "options": [
                "A. 4-bit",
                "B. 8-bit",
                "C. 16-bit",
                "D. 32-bit"
            ],
            "answer": "D. 32-bit",
            "explanation": "A key characteristic of the MIPS RISC architecture is its fixed-length 32-bit instruction format, which simplifies instruction decoding."
        },
        "vi": {
            "question": "T·∫•t c·∫£ c√°c l·ªánh c·ªßa b·ªô x·ª≠ l√Ω d√≤ng MIPS R ƒë∆∞·ª£c m√£ h√≥a trong m·ªôt ƒë·ªãnh d·∫°ng t·ª´ duy nh·∫•t ____.",
            "options": [
                "A. 4-bit",
                "B. 8-bit",
                "C. 16-bit",
                "D. 32-bit"
            ],
            "answer": "D. 32-bit",
            "explanation": "M·ªôt ƒë·∫∑c ƒëi·ªÉm ch√≠nh c·ªßa ki·∫øn tr√∫c MIPS RISC l√† ƒë·ªãnh d·∫°ng l·ªánh 32-bit c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh, gi√∫p ƒë∆°n gi·∫£n h√≥a vi·ªác gi·∫£i m√£ l·ªánh."
        }
    },
    {
        "id": 336,
        "en": {
            "question": "The ____ is used for debugging.",
            "options": [
                "A. Direction flag",
                "B. Alignment check",
                "C. Trap flag",
                "D. Identification flag"
            ],
            "answer": "C. Trap flag",
            "explanation": "In the x86 architecture, setting the Trap Flag (TF) in the EFLAGS register puts the processor into single-step mode. After each instruction, the processor generates a debug exception, allowing a debugger to take control."
        },
        "vi": {
            "question": "____ ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ g·ª° l·ªói.",
            "options": [
                "A. Direction flag",
                "B. Alignment check",
                "C. Trap flag",
                "D. Identification flag"
            ],
            "answer": "C. Trap flag",
            "explanation": "Trong ki·∫øn tr√∫c x86, vi·ªác ƒë·∫∑t C·ªù B·∫´y (TF) trong thanh ghi EFLAGS s·∫Ω ƒë∆∞a b·ªô x·ª≠ l√Ω v√†o ch·∫ø ƒë·ªô t·ª´ng b∆∞·ªõc m·ªôt. Sau m·ªói l·ªánh, b·ªô x·ª≠ l√Ω t·∫°o ra m·ªôt ngo·∫°i l·ªá g·ª° l·ªói, cho ph√©p m·ªôt tr√¨nh g·ª° l·ªói ki·ªÉm so√°t."
        }
    },
    {
        "id": 337,
        "en": {
            "question": "The major cost in the life cycle of a system is hardware.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "The major cost in the life cycle of a computer system, especially for businesses, is typically software, including development, maintenance, and user training, not the initial hardware purchase."
        },
        "vi": {
            "question": "Chi ph√≠ ch√≠nh trong v√≤ng ƒë·ªùi c·ªßa m·ªôt h·ªá th·ªëng l√† ph·∫ßn c·ª©ng.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "Chi ph√≠ ch√≠nh trong v√≤ng ƒë·ªùi c·ªßa m·ªôt h·ªá th·ªëng m√°y t√≠nh, ƒë·∫∑c bi·ªát l√† ƒë·ªëi v·ªõi c√°c doanh nghi·ªáp, th∆∞·ªùng l√† ph·∫ßn m·ªÅm, bao g·ªìm ph√°t tri·ªÉn, b·∫£o tr√¨ v√† ƒë√†o t·∫°o ng∆∞·ªùi d√πng, ch·ª© kh√¥ng ph·∫£i l√† chi ph√≠ mua ph·∫ßn c·ª©ng ban ƒë·∫ßu."
        }
    },
    {
        "id": 338,
        "en": {
            "question": "A(n) ____ is a hardware signal generated to the processor.",
            "options": [
                "A. interrupt",
                "B. trap",
                "C. exception",
                "D. signal"
            ],
            "answer": "A. interrupt",
            "explanation": "Interrupts are asynchronous signals typically generated by external hardware (like I/O devices) to get the processor's attention. Traps and exceptions are synchronous and generated by the software/CPU itself."
        },
        "vi": {
            "question": "M·ªôt(n) ____ l√† m·ªôt t√≠n hi·ªáu ph·∫ßn c·ª©ng ƒë∆∞·ª£c t·∫°o ra cho b·ªô x·ª≠ l√Ω.",
            "options": [
                "A. ng·∫Øt (interrupt)",
                "B. b·∫´y (trap)",
                "C. ngo·∫°i l·ªá (exception)",
                "D. t√≠n hi·ªáu (signal)"
            ],
            "answer": "A. ng·∫Øt (interrupt)",
            "explanation": "C√°c ng·∫Øt l√† c√°c t√≠n hi·ªáu kh√¥ng ƒë·ªìng b·ªô th∆∞·ªùng ƒë∆∞·ª£c t·∫°o ra b·ªüi ph·∫ßn c·ª©ng b√™n ngo√†i (nh∆∞ c√°c thi·∫øt b·ªã I/O) ƒë·ªÉ thu h√∫t s·ª± ch√∫ √Ω c·ªßa b·ªô x·ª≠ l√Ω. C√°c b·∫´y v√† ngo·∫°i l·ªá l√† ƒë·ªìng b·ªô v√† ƒë∆∞·ª£c t·∫°o ra b·ªüi ch√≠nh ph·∫ßn m·ªÅm/CPU."
        }
    },
    {
        "id": 340,
        "en": {
            "question": "A ____ is an electronic circuit that produces an output signal that is a simple Boolean operation on its input signals.",
            "options": [
                "A. gate",
                "B. decoder",
                "C. counter",
                "D. flip-flop"
            ],
            "answer": "A. gate",
            "explanation": "This is a repeated question. It defines a logic gate."
        },
        "vi": {
            "question": "M·ªôt ____ l√† m·ªôt m·∫°ch ƒëi·ªán t·ª≠ t·∫°o ra m·ªôt t√≠n hi·ªáu ƒë·∫ßu ra l√† m·ªôt ph√©p to√°n Boolean ƒë∆°n gi·∫£n tr√™n c√°c t√≠n hi·ªáu ƒë·∫ßu v√†o c·ªßa n√≥.",
            "options": [
                "A. c·ªïng (gate)",
                "B. b·ªô gi·∫£i m√£ (decoder)",
                "C. b·ªô ƒë·∫øm (counter)",
                "D. flip-flop"
            ],
            "answer": "A. gate",
            "explanation": "ƒê√¢y l√† c√¢u h·ªèi l·∫∑p l·∫°i. N√≥ ƒë·ªãnh nghƒ©a m·ªôt c·ªïng logic."
        }
    },
    {
        "id": 341,
        "en": {
            "question": "Events in the digital computer are ____ to a clock pulse so that changes occur only when a clock pulse occurs.",
            "options": [
                "A. asynchronous",
                "B. related",
                "C. parallel",
                "D. synchronized"
            ],
            "answer": "D. synchronized",
            "explanation": "In a synchronous digital system, all state changes in sequential circuits (like registers and flip-flops) are coordinated by a global clock signal to ensure orderly operation."
        },
        "vi": {
            "question": "C√°c s·ª± ki·ªán trong m√°y t√≠nh k·ªπ thu·∫≠t s·ªë ƒë∆∞·ª£c ____ v·ªõi m·ªôt xung nh·ªãp sao cho c√°c thay ƒë·ªïi ch·ªâ x·∫£y ra khi m·ªôt xung nh·ªãp x·∫£y ra.",
            "options": [
                "A. b·∫•t ƒë·ªìng b·ªô",
                "B. li√™n quan",
                "C. song song",
                "D. ƒë·ªìng b·ªô h√≥a"
            ],
            "answer": "D. ƒë·ªìng b·ªô h√≥a",
            "explanation": "Trong m·ªôt h·ªá th·ªëng k·ªπ thu·∫≠t s·ªë ƒë·ªìng b·ªô, t·∫•t c·∫£ c√°c thay ƒë·ªïi tr·∫°ng th√°i trong c√°c m·∫°ch tu·∫ßn t·ª± (nh∆∞ c√°c thanh ghi v√† flip-flop) ƒë∆∞·ª£c ph·ªëi h·ª£p b·ªüi m·ªôt t√≠n hi·ªáu ƒë·ªìng h·ªì to√†n c·ª•c ƒë·ªÉ ƒë·∫£m b·∫£o ho·∫°t ƒë·ªông c√≥ tr·∫≠t t·ª±."
        }
    },
    {
        "id": 342,
        "en": {
            "question": "____ is used in digital circuits to control signal and data routing.",
            "options": [
                "A. Multiplexers",
                "B. Program counters",
                "C. Flip-flops",
                "D. Gates"
            ],
            "answer": "A. Multiplexers",
            "explanation": "A multiplexer (MUX) is a device that selects one of several input signals and forwards the selected input into a single output line. It acts as a data selector."
        },
        "vi": {
            "question": "____ ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c m·∫°ch k·ªπ thu·∫≠t s·ªë ƒë·ªÉ ƒëi·ªÅu khi·ªÉn t√≠n hi·ªáu v√† ƒë·ªãnh tuy·∫øn d·ªØ li·ªáu.",
            "options": [
                "A. B·ªô ƒëa h·ª£p (Multiplexers)",
                "B. B·ªô ƒë·∫øm ch∆∞∆°ng tr√¨nh",
                "C. Flip-flops",
                "D. C·ªïng"
            ],
            "answer": "A. B·ªô ƒëa h·ª£p (Multiplexers)",
            "explanation": "M·ªôt b·ªô ƒëa h·ª£p (MUX) l√† m·ªôt thi·∫øt b·ªã ch·ªçn m·ªôt trong nhi·ªÅu t√≠n hi·ªáu ƒë·∫ßu v√†o v√† chuy·ªÉn ti·∫øp ƒë·∫ßu v√†o ƒë∆∞·ª£c ch·ªçn v√†o m·ªôt ƒë∆∞·ªùng ƒë·∫ßu ra duy nh·∫•t. N√≥ ho·∫°t ƒë·ªông nh∆∞ m·ªôt b·ªô ch·ªçn d·ªØ li·ªáu."
        }
    },
    {
        "id": 343,
        "en": {
            "question": "The ____ flip-flop has two inputs and all possible combinations of input values are valid.",
            "options": [
                "A. J-K",
                "B. D",
                "C. S-R",
                "D. clocked S-R"
            ],
            "answer": "A. J-K",
            "explanation": "The J-K flip-flop improves upon the S-R flip-flop by handling the indeterminate state where S=R=1. In a J-K flip-flop, when J=K=1, the output toggles (flips to its opposite state), making all input combinations valid and useful."
        },
        "vi": {
            "question": "Flip-flop ____ c√≥ hai ƒë·∫ßu v√†o v√† t·∫•t c·∫£ c√°c t·ªï h·ª£p gi√° tr·ªã ƒë·∫ßu v√†o c√≥ th·ªÉ c√≥ ƒë·ªÅu h·ª£p l·ªá.",
            "options": [
                "A. J-K",
                "B. D",
                "C. S-R",
                "D. clocked S-R"
            ],
            "answer": "A. J-K",
            "explanation": "Flip-flop J-K c·∫£i ti·∫øn so v·ªõi flip-flop S-R b·∫±ng c√°ch x·ª≠ l√Ω tr·∫°ng th√°i kh√¥ng x√°c ƒë·ªãnh khi S=R=1. Trong m·ªôt flip-flop J-K, khi J=K=1, ƒë·∫ßu ra s·∫Ω ƒë·∫£o tr·∫°ng th√°i (chuy·ªÉn sang tr·∫°ng th√°i ƒë·ªëi di·ªán), l√†m cho t·∫•t c·∫£ c√°c t·ªï h·ª£p ƒë·∫ßu v√†o ƒë·ªÅu h·ª£p l·ªá v√† h·ªØu √≠ch."
        }
    },
    {
        "id": 344,
        "en": {
            "question": "Counters can be designated as ____.",
            "options": [
                "A. asynchronous",
                "B. synchronous",
                "C. both asynchronous and synchronous",
                "D. neither asynchronous nor synchronous"
            ],
            "answer": "C. both asynchronous and synchronous",
            "explanation": "Counters can be designed in two ways: asynchronous (ripple) counters where the output of one flip-flop clocks the next, and synchronous counters where all flip-flops share a common clock signal."
        },
        "vi": {
            "question": "C√°c b·ªô ƒë·∫øm c√≥ th·ªÉ ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh l√† ____.",
            "options": [
                "A. b·∫•t ƒë·ªìng b·ªô",
                "B. ƒë·ªìng b·ªô",
                "C. c·∫£ b·∫•t ƒë·ªìng b·ªô v√† ƒë·ªìng b·ªô",
                "D. kh√¥ng b·∫•t ƒë·ªìng b·ªô c≈©ng kh√¥ng ƒë·ªìng b·ªô"
            ],
            "answer": "C. c·∫£ b·∫•t ƒë·ªìng b·ªô v√† ƒë·ªìng b·ªô",
            "explanation": "C√°c b·ªô ƒë·∫øm c√≥ th·ªÉ ƒë∆∞·ª£c thi·∫øt k·∫ø theo hai c√°ch: b·ªô ƒë·∫øm b·∫•t ƒë·ªìng b·ªô (g·ª£n s√≥ng) n∆°i ƒë·∫ßu ra c·ªßa m·ªôt flip-flop l√†m xung nh·ªãp cho c√°i ti·∫øp theo, v√† b·ªô ƒë·∫øm ƒë·ªìng b·ªô n∆°i t·∫•t c·∫£ c√°c flip-flop chia s·∫ª m·ªôt t√≠n hi·ªáu xung nh·ªãp chung."
        }
    },
    {
        "id": 345,
        "en": {
            "question": "A boundary where the computer designer and the computer programmer can view the same machine is the instruction set of the machine.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "The Instruction Set Architecture (ISA) serves as the interface between software and hardware. The programmer writes code that compiles down to this instruction set, and the designer builds hardware that can execute it."
        },
        "vi": {
            "question": "M·ªôt ranh gi·ªõi n∆°i nh√† thi·∫øt k·∫ø m√°y t√≠nh v√† l·∫≠p tr√¨nh vi√™n m√°y t√≠nh c√≥ th·ªÉ xem c√πng m·ªôt m√°y l√† t·∫≠p l·ªánh c·ªßa m√°y.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "A. True",
            "explanation": "Ki·∫øn tr√∫c t·∫≠p l·ªánh (ISA) ƒë√≥ng vai tr√≤ l√† giao di·ªán gi·ªØa ph·∫ßn m·ªÅm v√† ph·∫ßn c·ª©ng. L·∫≠p tr√¨nh vi√™n vi·∫øt m√£ ƒë∆∞·ª£c bi√™n d·ªãch th√†nh t·∫≠p l·ªánh n√†y, v√† nh√† thi·∫øt k·∫ø x√¢y d·ª±ng ph·∫ßn c·ª©ng c√≥ th·ªÉ th·ª±c thi n√≥."
        }
    },
    {
        "id": 346,
        "en": {
            "question": "For the ____ mode, the operand is included in the instruction.",
            "options": [
                "A. immediate",
                "B. base",
                "C. register",
                "D. displacement"
            ],
            "answer": "A. immediate",
            "explanation": "In immediate addressing, the operand's value is literally part of the instruction itself, eliminating the need for a memory fetch to get the operand."
        },
        "vi": {
            "question": "ƒê·ªëi v·ªõi ch·∫ø ƒë·ªô ____, to√°n h·∫°ng ƒë∆∞·ª£c bao g·ªìm trong l·ªánh.",
            "options": [
                "A. t·ª©c th·ªùi (immediate)",
                "B. c∆° s·ªü (base)",
                "C. thanh ghi (register)",
                "D. d·ªãch chuy·ªÉn (displacement)"
            ],
            "answer": "A. t·ª©c th·ªùi (immediate)",
            "explanation": "Trong ƒë·ªãa ch·ªâ h√≥a t·ª©c th·ªùi, gi√° tr·ªã c·ªßa to√°n h·∫°ng th·ª±c s·ª± l√† m·ªôt ph·∫ßn c·ªßa ch√≠nh l·ªánh ƒë√≥, lo·∫°i b·ªè s·ª± c·∫ßn thi·∫øt ph·∫£i t√¨m n·∫°p b·ªô nh·ªõ ƒë·ªÉ l·∫•y to√°n h·∫°ng."
        }
    },
    {
        "id": 347,
        "en": {
            "question": "A ____ is an interrupt from software and it is invoked by the execution of an instruction.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "An interrupt is generated from hardware. A trap is an interrupt from software and it is invoked by the execution of an instruction."
        },
        "vi": {
            "question": "M·ªôt ng·∫Øt ƒë∆∞·ª£c t·∫°o ra t·ª´ ph·∫ßn m·ªÅm v√† n√≥ ƒë∆∞·ª£c g√¢y ra b·ªüi vi·ªác th·ª±c thi m·ªôt l·ªánh.",
            "options": [
                "A. True",
                "B. False"
            ],
            "answer": "B. False",
            "explanation": "M·ªôt ng·∫Øt (interrupt) ƒë∆∞·ª£c t·∫°o ra t·ª´ ph·∫ßn c·ª©ng. M·ªôt b·∫´y (trap) m·ªõi l√† ng·∫Øt t·ª´ ph·∫ßn m·ªÅm v√† ƒë∆∞·ª£c g√¢y ra b·ªüi vi·ªác th·ª±c thi m·ªôt l·ªánh."
        }
    },
    {
        "id": 348,
        "en": {
            "question": "MIPS R4000 uses ____ bits for all internal and external data paths and for addresses, registers, and the ALU.",
            "options": [
                "A. 16",
                "B. 32",
                "C. 64",
                "D. 128"
            ],
            "answer": "C. 64",
            "explanation": "This is a repeated question. MIPS R4000 is a 64-bit architecture."
        },
        "vi": {
            "question": "MIPS R4000 s·ª≠ d·ª•ng ____ bit cho t·∫•t c·∫£ c√°c ƒë∆∞·ªùng d·∫´n d·ªØ li·ªáu n·ªôi b·ªô v√† b√™n ngo√†i v√† cho c√°c ƒë·ªãa ch·ªâ, thanh ghi v√† ALU.",
            "options": [
                "A. 16",
                "B. 32",
                "C. 64",
                "D. 128"
            ],
            "answer": "C. 64",
            "explanation": "ƒê√¢y l√† c√¢u h·ªèi l·∫∑p l·∫°i. MIPS R4000 l√† m·ªôt ki·∫øn tr√∫c 64-bit."
        }
    },
    {
        "id": 349,
        "en": {
            "question": "All processor instructions of the MIPS R series are encoded in a single ____ word format.",
            "options": [
                "A. 4-bit",
                "B. 8-bit",
                "C. 16-bit",
                "D. 32-bit"
            ],
            "answer": "D. 32-bit",
            "explanation": "This is a repeated question. The MIPS architecture is known for its fixed-length 32-bit instructions."
        },
        "vi": {
            "question": "T·∫•t c·∫£ c√°c l·ªánh c·ªßa b·ªô x·ª≠ l√Ω d√≤ng MIPS R ƒë∆∞·ª£c m√£ h√≥a trong m·ªôt ƒë·ªãnh d·∫°ng t·ª´ duy nh·∫•t ____.",
            "options": [
                "A. 4-bit",
                "B. 8-bit",
                "C. 16-bit",
                "D. 32-bit"
            ],
            "answer": "D. 32-bit",
            "explanation": "ƒê√¢y l√† c√¢u h·ªèi l·∫∑p l·∫°i. Ki·∫øn tr√∫c MIPS n·ªïi ti·∫øng v·ªõi c√°c l·ªánh c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh 32-bit."
        }
    }
];

    // ======================================================
    // 2. QU·∫¢N L√ù TR·∫†NG TH√ÅI
    // ======================================================
    let state = {
        isVietnamese: true,
        activeTab: 'flashcard',
        
        // Flashcard State
        fcIndex: 0,
        filteredFlashcards: [], // Danh s√°ch flashcard sau khi l·ªçc

        // Quiz State
        quizPhase: 'setup',
        activeQuestions: [], 
        userAnswers: {}, 
        currentQuizIndex: 0
    };

    const texts = {
        vi: {
            setupTitle: "C·∫•u h√¨nh luy·ªán t·∫≠p", total: "C√≥ s·∫µn:", qCount: "2. S·ªë l∆∞·ª£ng c√¢u h·ªèi:", start: "B·∫Øt ƒë·∫ßu ngay üöÄ",
            map: "B·∫£n ƒë·ªì c√¢u h·ªèi", doing: "ƒêang luy·ªán t·∫≠p", submit: "N·ªôp b√†i & Xem ƒëi·ªÉm", resultTitle: "K·∫øt qu·∫£ b√†i l√†m",
            prev: "Tr∆∞·ªõc", next: "Sau", fcAns: "ƒê√°p √°n", fcExp: "Gi·∫£i th√≠ch",
            legCur: "ƒêang l√†m", legCor: "ƒê√∫ng", legWro: "Sai", qOf: "C√¢u"
        },
        en: {
            setupTitle: "Practice Config", total: "Available:", qCount: "2. Number of questions:", start: "Start Now üöÄ",
            map: "Question Map", doing: "Practice Mode", submit: "Submit & View Score", resultTitle: "Quiz Results",
            prev: "Prev", next: "Next", fcAns: "Answer", fcExp: "Explanation",
            legCur: "Current", legCor: "Correct", legWro: "Wrong", qOf: "Question"
        }
    };

    // ======================================================
    // 3. CORE & CATEGORY LOGIC
    // ======================================================
    function init() {
        // Kh·ªüi t·∫°o danh s√°ch danh m·ª•c
        const categories = getUniqueCategories();
        populateDropdown('fc-category-select', categories);
        populateDropdown('quiz-category-select', categories);

        // Kh·ªüi t·∫°o Flashcard m·∫∑c ƒë·ªãnh (All)
        updateFlashcardFilter();
        
        // Kh·ªüi t·∫°o Quiz Setup m·∫∑c ƒë·ªãnh
        updateQuizCountMax();

        updateLanguageTexts();
    }

    function getUniqueCategories() {
        const cats = new Set();
        quizData.forEach(q => {
            if(q.category) cats.add(q.category);
            else cats.add("Uncategorized");
        });
        return Array.from(cats).sort();
    }

    function populateDropdown(elementId, categories) {
        const sel = document.getElementById(elementId);
        // Gi·ªØ l·∫°i option ƒë·∫ßu ti√™n (All)
        sel.innerHTML = '<option value="all">-- T·∫•t c·∫£ ch·ªß ƒë·ªÅ --</option>';
        categories.forEach(cat => {
            const opt = document.createElement('option');
            opt.value = cat;
            opt.innerText = cat;
            sel.appendChild(opt);
        });
    }

    function updateLanguageTexts() {
        const t = state.isVietnamese ? texts.vi : texts.en;
        document.getElementById('txt-setup-title').innerText = t.setupTitle;
        document.getElementById('txt-total').innerText = t.total;
        document.getElementById('txt-q-count').innerText = t.qCount;
        document.getElementById('txt-start').innerText = t.start;
        document.getElementById('txt-map').innerText = t.map;
        document.getElementById('txt-doing').innerText = t.doing;
        document.getElementById('btn-prev').innerText = t.prev;
        document.getElementById('btn-next').innerText = t.next;
        document.getElementById('btn-submit').innerText = t.submit;
        document.getElementById('txt-result-title').innerText = t.resultTitle;
        document.getElementById('txt-fc-ans').innerText = t.fcAns;
        document.getElementById('txt-fc-exp').innerText = t.fcExp;
        document.getElementById('leg-current').innerText = t.legCur;
        document.getElementById('leg-correct').innerText = t.legCor;
        document.getElementById('leg-wrong').innerText = t.legWro;
    }

    function toggleLanguage() {
        state.isVietnamese = !state.isVietnamese;
        updateLanguageTexts();
        if (state.activeTab === 'flashcard') renderFlashcard();
        else {
            if (state.quizPhase === 'active') renderQuestionCard();
            if (state.quizPhase === 'result') renderResultView();
        }
    }

    function switchTab(tab) {
        state.activeTab = tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        
        const fcView = document.getElementById('flashcard-view');
        const quizSetup = document.getElementById('quiz-setup');
        const quizActive = document.getElementById('quiz-active');
        const quizResult = document.getElementById('quiz-result');
        const sidebar = document.getElementById('quiz-sidebar');

        if (tab === 'flashcard') {
            document.querySelectorAll('.tab-btn')[0].classList.add('active');
            fcView.classList.remove('hidden');
            
            quizSetup.classList.add('hidden');
            quizActive.classList.add('hidden');
            quizResult.classList.add('hidden');
            sidebar.classList.add('hidden');
        } else {
            document.querySelectorAll('.tab-btn')[1].classList.add('active');
            fcView.classList.add('hidden');
            
            if (state.quizPhase === 'setup') {
                quizSetup.classList.remove('hidden');
            } else if (state.quizPhase === 'active') {
                quizActive.classList.remove('hidden');
                sidebar.classList.remove('hidden');
            } else if (state.quizPhase === 'result') {
                quizResult.classList.remove('hidden');
                sidebar.classList.remove('hidden');
            }
        }
    }

    // ======================================================
    // 4. FLASHCARD LOGIC
    // ======================================================
    function updateFlashcardFilter() {
        const cat = document.getElementById('fc-category-select').value;
        if (cat === 'all') {
            state.filteredFlashcards = quizData;
        } else {
            state.filteredFlashcards = quizData.filter(q => (q.category || "Uncategorized") === cat);
        }
        state.fcIndex = 0; // Reset v·ªÅ ƒë·∫ßu
        renderFlashcard();
    }

    function renderFlashcard() {
        if (state.filteredFlashcards.length === 0) {
            document.getElementById('fc-content').innerHTML = "Kh√¥ng c√≥ c√¢u h·ªèi n√†o trong ch·ªß ƒë·ªÅ n√†y.";
            return;
        }
        
        const q = state.filteredFlashcards[state.fcIndex];
        const data = state.isVietnamese ? q.vi : q.en;
        const code = q.en.code ? `<pre>${q.en.code}</pre>` : '';
        
        document.querySelector('.flashcard').classList.remove('flipped');
        document.getElementById('fc-category-tag').innerText = q.category || "General";
        
        let html = `<div style="margin-bottom:15px; font-weight:bold;">#${q.id}</div>`;
        html += `<div>${data.question}</div>` + code;
        html += `<ul style="text-align:left; margin-top:15px; padding-left:20px;">`;
        data.options.forEach(o => html += `<li>${o}</li>`);
        html += `</ul>`;
        
        document.getElementById('fc-content').innerHTML = html;
        document.getElementById('fc-answer').innerText = data.answer;
        document.getElementById('fc-explanation').innerHTML = data.explanation;
        document.getElementById('fc-counter').innerText = `${state.fcIndex + 1} / ${state.filteredFlashcards.length}`;
    }

    function navFlashcard(dir) {
        let next = state.fcIndex + dir;
        if (next >= 0 && next < state.filteredFlashcards.length) {
            state.fcIndex = next;
            renderFlashcard();
        }
    }

    // ======================================================
    // 5. QUIZ SETUP & LOGIC
    // ======================================================
    function updateQuizCountMax() {
        const cat = document.getElementById('quiz-category-select').value;
        let count = 0;
        if (cat === 'all') count = quizData.length;
        else count = quizData.filter(q => (q.category || "Uncategorized") === cat).length;

        document.getElementById('total-qs').innerText = count;
        
        const input = document.getElementById('quiz-count-input');
        input.max = count;
        input.value = Math.min(20, count);
    }

    function startQuiz() {
        const cat = document.getElementById('quiz-category-select').value;
        let pool = [];
        
        if (cat === 'all') pool = [...quizData];
        else pool = quizData.filter(q => (q.category || "Uncategorized") === cat);

        if (pool.length === 0) {
            alert("Kh√¥ng c√≥ c√¢u h·ªèi n√†o trong ch·ªß ƒë·ªÅ n√†y!");
            return;
        }

        let count = parseInt(document.getElementById('quiz-count-input').value);
        if (count <= 0) count = 1;
        if (count > pool.length) count = pool.length;

        // Shuffle
        const shuffled = pool.sort(() => 0.5 - Math.random());
        state.activeQuestions = shuffled.slice(0, count);
        state.userAnswers = {};
        state.currentQuizIndex = 0;
        state.quizPhase = 'active';

        document.getElementById('quiz-setup').classList.add('hidden');
        document.getElementById('quiz-active').classList.remove('hidden');
        document.getElementById('quiz-sidebar').classList.remove('hidden');

        renderQuestionCard();
        renderMap();
    }

    function renderQuestionCard() {
        const idx = state.currentQuizIndex;
        const q = state.activeQuestions[idx];
        const data = state.isVietnamese ? q.vi : q.en;
        const code = q.en.code ? `<pre>${q.en.code}</pre>` : '';
        const t = state.isVietnamese ? texts.vi : texts.en;

        document.getElementById('quiz-progress').innerText = `${t.qOf} ${idx + 1}/${state.activeQuestions.length}`;
        document.getElementById('q-content').innerHTML = `<div>${data.question}</div>` + code;

        const ul = document.getElementById('q-options');
        ul.innerHTML = '';
        const expBox = document.getElementById('q-explanation');

        const ansState = state.userAnswers[idx];
        const isAnswered = !!ansState;
        const correctLabel = data.answer.trim().charAt(0); 
        const labels = ['A', 'B', 'C', 'D', 'E', 'F'];

        data.options.forEach((opt, i) => {
            const li = document.createElement('li');
            li.innerText = opt;
            li.setAttribute('data-label', labels[i]);

            if (isAnswered) {
                li.classList.add('disabled');
                if (labels[i] === correctLabel) li.classList.add('correct');
                if (labels[i] === ansState.selected && !ansState.isCorrect) li.classList.add('wrong');
            } else {
                li.onclick = () => handleAnswer(idx, labels[i], correctLabel);
            }
            ul.appendChild(li);
        });

        if (isAnswered) {
            expBox.style.display = 'block';
            const color = ansState.isCorrect ? 'var(--secondary-color)' : 'var(--danger-color)';
            const bg = ansState.isCorrect ? '#d4edda' : '#f8d7da';
            const status = ansState.isCorrect ? (state.isVietnamese ? "Ch√≠nh x√°c!" : "Correct!") : (state.isVietnamese ? "Sai r·ªìi!" : "Wrong!");
            
            expBox.style.background = bg;
            expBox.style.borderLeftColor = color;
            expBox.innerHTML = `<div style="color:${color}; font-weight:bold; margin-bottom:10px;">${status}</div>
                                <strong>${t.fcAns}:</strong> ${data.answer}<br><br>
                                <strong>${t.fcExp}:</strong> ${data.explanation}`;
        } else {
            expBox.style.display = 'none';
        }
        renderMapActiveState();
    }

    function handleAnswer(idx, selected, correct) {
        const isCorrect = selected === correct;
        state.userAnswers[idx] = { selected, isCorrect };
        renderQuestionCard();
        renderMap();
    }

    function navQuiz(dir) {
        let next = state.currentQuizIndex + dir;
        if (next >= 0 && next < state.activeQuestions.length) {
            state.currentQuizIndex = next;
            renderQuestionCard();
        }
    }

    // ======================================================
    // 6. FINISH & RESULT LOGIC
    // ======================================================
    function finishQuiz() {
        if(!confirm(state.isVietnamese ? "N·ªôp b√†i v√† xem k·∫øt qu·∫£?" : "Submit and view results?")) return;
        
        state.quizPhase = 'result';
        document.getElementById('quiz-active').classList.add('hidden');
        document.getElementById('quiz-result').classList.remove('hidden');

        // Calculate Score
        let correctCount = 0;
        for (let i = 0; i < state.activeQuestions.length; i++) {
            if (state.userAnswers[i] && state.userAnswers[i].isCorrect) correctCount++;
        }
        
        document.getElementById('score-val').innerText = `${correctCount}/${state.activeQuestions.length}`;
        const pct = Math.round((correctCount / state.activeQuestions.length) * 100);
        document.getElementById('score-percent').innerText = `(${pct}%)`;

        renderResultView();
        renderMap(); 
    }

    function renderResultView() {
        const list = document.getElementById('review-list');
        list.innerHTML = '';
        
        state.activeQuestions.forEach((q, idx) => {
            const data = state.isVietnamese ? q.vi : q.en;
            const code = q.en.code ? `<pre>${q.en.code}</pre>` : '';
            const ans = state.userAnswers[idx];
            const correctLabel = data.answer.trim().charAt(0);
            const labels = ['A', 'B', 'C', 'D', 'E', 'F'];

            const card = document.createElement('div');
            card.className = 'question-card review-card';
            card.id = `review-q-${idx}`;
            
            let statusHtml = '';
            if (ans) {
                statusHtml = ans.isCorrect ? 
                    `<span style="color:var(--secondary-color); font-weight:bold; float:right;">‚úî ƒê√∫ng</span>` : 
                    `<span style="color:var(--danger-color); font-weight:bold; float:right;">‚úò Sai</span>`;
            } else {
                statusHtml = `<span style="color:#666; float:right;">‚ö™ Ch∆∞a l√†m</span>`;
            }

            let html = `<div style="margin-bottom:10px; color:#555;">Question ${idx+1} <span style="color:#999; font-size:12px;">(${q.category})</span> ${statusHtml}</div>`;
            html += `<div>${data.question}</div>` + code;
            html += `<ul class="options-list" style="margin-top:15px;">`;
            
            data.options.forEach((opt, i) => {
                let cls = '';
                if (labels[i] === correctLabel) cls = 'correct';
                if (ans && !ans.isCorrect && labels[i] === ans.selected) cls = 'wrong';
                html += `<li class="${cls}" data-label="${labels[i]}">${opt}</li>`;
            });
            html += `</ul>`;
            
            html += `<div class="explanation-box" style="display:block; background:#f9f9f9; border-left-color:#666;">
                        <strong>${data.answer}</strong><br>${data.explanation}
                     </div>`;
            
            card.innerHTML = html;
            list.appendChild(card);
        });
    }

    function resetQuiz() {
        state.quizPhase = 'setup';
        document.getElementById('quiz-result').classList.add('hidden');
        document.getElementById('quiz-sidebar').classList.add('hidden');
        document.getElementById('quiz-setup').classList.remove('hidden');
        updateQuizCountMax();
    }

    // ======================================================
    // 7. MAP
    // ======================================================
    function renderMap() {
        const grid = document.getElementById('map-grid');
        grid.innerHTML = '';
        state.activeQuestions.forEach((_, idx) => {
            const btn = document.createElement('button');
            btn.className = 'map-btn';
            btn.id = `map-btn-${idx}`;
            btn.innerText = idx + 1;
            
            const ans = state.userAnswers[idx];
            if (ans) {
                if (ans.isCorrect) btn.classList.add('correct');
                else btn.classList.add('wrong');
            }

            btn.onclick = () => {
                if (state.quizPhase === 'result') {
                    document.getElementById(`review-q-${idx}`).scrollIntoView({behavior: 'smooth'});
                } else {
                    state.currentQuizIndex = idx;
                    renderQuestionCard();
                }
            };
            grid.appendChild(btn);
        });
        renderMapActiveState();
    }

    function renderMapActiveState() {
        if (state.quizPhase !== 'active') return;
        document.querySelectorAll('.map-btn').forEach(b => b.classList.remove('active'));
        const b = document.getElementById(`map-btn-${state.currentQuizIndex}`);
        if (b) b.classList.add('active');
    }

    // ======================================================
    // 8. SHORTCUTS
    // ======================================================
    document.addEventListener('keydown', function(event) {
        if (document.activeElement.tagName === 'INPUT') return;
        const key = event.key;

        if (state.activeTab === 'flashcard') {
            if (key === 'ArrowLeft') navFlashcard(-1);
            else if (key === 'ArrowRight') navFlashcard(1);
            else if (key === ' ' || key === 'Enter' || key === 'ArrowUp' || key === 'ArrowDown') {
                event.preventDefault();
                document.querySelector('.flashcard').classList.toggle('flipped');
            }
        } 
        else if (state.activeTab === 'quiz' && state.quizPhase === 'active') {
            if (key === 'ArrowLeft') navQuiz(-1);
            else if (key === 'ArrowRight') navQuiz(1);
            
            const idx = state.currentQuizIndex;
            if (!state.userAnswers[idx]) {
                const q = state.activeQuestions[idx];
                const data = state.isVietnamese ? q.vi : q.en;
                const correctLabel = data.answer.trim().charAt(0);
                const labels = ['A', 'B', 'C', 'D', 'E', 'F'];
                
                let selectedIndex = -1;
                if (['1', 'a', 'A'].includes(key)) selectedIndex = 0;
                else if (['2', 'b', 'B'].includes(key)) selectedIndex = 1;
                else if (['3', 'c', 'C'].includes(key)) selectedIndex = 2;
                else if (['4', 'd', 'D'].includes(key)) selectedIndex = 3;

                if (selectedIndex !== -1 && selectedIndex < data.options.length) {
                    handleAnswer(idx, labels[selectedIndex], correctLabel);
                }
            }
        }
    });

    // Start
    init();
</script>
</body>
</html>
